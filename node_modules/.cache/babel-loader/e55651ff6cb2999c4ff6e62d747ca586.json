{"ast":null,"code":"import{defaultMetricsDuration}from'../components/Metrics/Helper';export var HTTP_VERBS;(function(HTTP_VERBS){HTTP_VERBS[\"DELETE\"]=\"DELETE\";HTTP_VERBS[\"GET\"]=\"get\";HTTP_VERBS[\"PATCH\"]=\"patch\";HTTP_VERBS[\"POST\"]=\"post\";HTTP_VERBS[\"PUT\"]=\"put\";})(HTTP_VERBS||(HTTP_VERBS={}));export var MILLISECONDS=1000;export var UNIT_TIME={SECOND:1,MINUTE:60,HOUR:3600,DAY:24*3600};// Type-guarding TimeRange: executes first callback when range is a duration, or second callback when it's a bounded range, mapping to a value\nexport function guardTimeRange(range,ifDuration,ifBounded){if(range.from){var _b={from:range.from};if(range.to){_b.to=range.to;}return ifBounded(_b);}else{if(range.rangeDuration){return ifDuration(range.rangeDuration);}}// It shouldn't reach here a TimeRange should have DurationInSeconds or BoundsInMilliseconds\nreturn ifDuration(defaultMetricsDuration);}export var evalTimeRange=function evalTimeRange(range){var bounds=guardTimeRange(range,durationToBounds,function(b){return b;});return[bounds.from?new Date(bounds.from):new Date(),bounds.to?new Date(bounds.to):new Date()];};export var boundsToDuration=function boundsToDuration(bounds){return Math.floor(((bounds.to||new Date().getTime())-(bounds.from||new Date().getTime()))/1000);};export var durationToBounds=function durationToBounds(duration){return{from:new Date().getTime()-duration*1000};};export var isEqualTimeRange=function isEqualTimeRange(t1,t2){if(t1.from&&t2.from&&t1.from!==t2.from){return false;}if(t1.to&&t2.to&&t1.to!==t2.to){return false;}if(t1.rangeDuration&&t2.rangeDuration&&t1.rangeDuration!==t2.rangeDuration){return false;}return true;};","map":null,"metadata":{},"sourceType":"module"}