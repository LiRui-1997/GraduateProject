{"ast":null,"code":"import { defaultMetricsDuration } from '../components/Metrics/Helper';\nexport var HTTP_VERBS;\n\n(function (HTTP_VERBS) {\n  HTTP_VERBS[\"DELETE\"] = \"DELETE\";\n  HTTP_VERBS[\"GET\"] = \"get\";\n  HTTP_VERBS[\"PATCH\"] = \"patch\";\n  HTTP_VERBS[\"POST\"] = \"post\";\n  HTTP_VERBS[\"PUT\"] = \"put\";\n})(HTTP_VERBS || (HTTP_VERBS = {}));\n\nexport var MILLISECONDS = 1000;\nexport var UNIT_TIME = {\n  SECOND: 1,\n  MINUTE: 60,\n  HOUR: 3600,\n  DAY: 24 * 3600\n};\n// Type-guarding TimeRange: executes first callback when range is a duration, or second callback when it's a bounded range, mapping to a value\nexport function guardTimeRange(range, ifDuration, ifBounded) {\n  if (range.from) {\n    var _b = {\n      from: range.from\n    };\n\n    if (range.to) {\n      _b.to = range.to;\n    }\n\n    return ifBounded(_b);\n  } else {\n    if (range.rangeDuration) {\n      return ifDuration(range.rangeDuration);\n    }\n  } // It shouldn't reach here a TimeRange should have DurationInSeconds or BoundsInMilliseconds\n\n\n  return ifDuration(defaultMetricsDuration);\n}\nexport var evalTimeRange = function evalTimeRange(range) {\n  var bounds = guardTimeRange(range, durationToBounds, function (b) {\n    return b;\n  });\n  return [bounds.from ? new Date(bounds.from) : new Date(), bounds.to ? new Date(bounds.to) : new Date()];\n};\nexport var boundsToDuration = function boundsToDuration(bounds) {\n  return Math.floor(((bounds.to || new Date().getTime()) - (bounds.from || new Date().getTime())) / 1000);\n};\nexport var durationToBounds = function durationToBounds(duration) {\n  return {\n    from: new Date().getTime() - duration * 1000\n  };\n};\nexport var isEqualTimeRange = function isEqualTimeRange(t1, t2) {\n  if (t1.from && t2.from && t1.from !== t2.from) {\n    return false;\n  }\n\n  if (t1.to && t2.to && t1.to !== t2.to) {\n    return false;\n  }\n\n  if (t1.rangeDuration && t2.rangeDuration && t1.rangeDuration !== t2.rangeDuration) {\n    return false;\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/root/GraduateProject/src/types/Common.ts"],"names":["defaultMetricsDuration","HTTP_VERBS","MILLISECONDS","UNIT_TIME","SECOND","MINUTE","HOUR","DAY","guardTimeRange","range","ifDuration","ifBounded","from","b","to","rangeDuration","evalTimeRange","bounds","durationToBounds","Date","boundsToDuration","Math","floor","getTime","duration","isEqualTimeRange","t1","t2"],"mappings":"AAAA,SAASA,sBAAT,QAAuC,8BAAvC;AAQA,WAAYC,UAAZ;;WAAYA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;AAAAA,EAAAA,U;GAAAA,U,KAAAA,U;;AAUZ,OAAO,IAAMC,YAAY,GAAG,IAArB;AAEP,OAAO,IAAMC,SAAS,GAAG;AACvBC,EAAAA,MAAM,EAAE,CADe;AAEvBC,EAAAA,MAAM,EAAE,EAFe;AAGvBC,EAAAA,IAAI,EAAE,IAHiB;AAIvBC,EAAAA,GAAG,EAAE,KAAK;AAJa,CAAlB;AAyBP;AACA,OAAO,SAASC,cAAT,CACLC,KADK,EAELC,UAFK,EAGLC,SAHK,EAIF;AACH,MAAIF,KAAK,CAACG,IAAV,EAAgB;AACd,QAAMC,EAAuB,GAAG;AAC9BD,MAAAA,IAAI,EAAEH,KAAK,CAACG;AADkB,KAAhC;;AAGA,QAAIH,KAAK,CAACK,EAAV,EAAc;AACZD,MAAAA,EAAC,CAACC,EAAF,GAAOL,KAAK,CAACK,EAAb;AACD;;AACD,WAAOH,SAAS,CAACE,EAAD,CAAhB;AACD,GARD,MAQO;AACL,QAAIJ,KAAK,CAACM,aAAV,EAAyB;AACvB,aAAOL,UAAU,CAACD,KAAK,CAACM,aAAP,CAAjB;AACD;AACF,GAbE,CAcH;;;AACA,SAAOL,UAAU,CAACV,sBAAD,CAAjB;AACD;AAED,OAAO,IAAMgB,aAAa,GAAG,SAAhBA,aAAgB,CAACP,KAAD,EAAoC;AAC/D,MAAMQ,MAAM,GAAGT,cAAc,CAACC,KAAD,EAAQS,gBAAR,EAA0B,UAAAL,CAAC;AAAA,WAAIA,CAAJ;AAAA,GAA3B,CAA7B;AACA,SAAO,CAACI,MAAM,CAACL,IAAP,GAAc,IAAIO,IAAJ,CAASF,MAAM,CAACL,IAAhB,CAAd,GAAsC,IAAIO,IAAJ,EAAvC,EAAmDF,MAAM,CAACH,EAAP,GAAY,IAAIK,IAAJ,CAASF,MAAM,CAACH,EAAhB,CAAZ,GAAkC,IAAIK,IAAJ,EAArF,CAAP;AACD,CAHM;AAKP,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACH,MAAD,EAAqD;AACnF,SAAOI,IAAI,CAACC,KAAL,CAAW,CAAC,CAACL,MAAM,CAACH,EAAP,IAAa,IAAIK,IAAJ,GAAWI,OAAX,EAAd,KAAuCN,MAAM,CAACL,IAAP,IAAe,IAAIO,IAAJ,GAAWI,OAAX,EAAtD,CAAD,IAAgF,IAA3F,CAAP;AACD,CAFM;AAIP,OAAO,IAAML,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACM,QAAD,EAAuD;AACrF,SAAO;AACLZ,IAAAA,IAAI,EAAE,IAAIO,IAAJ,GAAWI,OAAX,KAAuBC,QAAQ,GAAG;AADnC,GAAP;AAGD,CAJM;AAMP,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,EAAD,EAAgBC,EAAhB,EAA2C;AACzE,MAAID,EAAE,CAACd,IAAH,IAAWe,EAAE,CAACf,IAAd,IAAsBc,EAAE,CAACd,IAAH,KAAYe,EAAE,CAACf,IAAzC,EAA+C;AAC7C,WAAO,KAAP;AACD;;AACD,MAAIc,EAAE,CAACZ,EAAH,IAASa,EAAE,CAACb,EAAZ,IAAkBY,EAAE,CAACZ,EAAH,KAAUa,EAAE,CAACb,EAAnC,EAAuC;AACrC,WAAO,KAAP;AACD;;AACD,MAAIY,EAAE,CAACX,aAAH,IAAoBY,EAAE,CAACZ,aAAvB,IAAwCW,EAAE,CAACX,aAAH,KAAqBY,EAAE,CAACZ,aAApE,EAAmF;AACjF,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD,CAXM","sourcesContent":["import { defaultMetricsDuration } from '../components/Metrics/Helper';\n\nexport type AppenderString = string;\n\nexport type UserName = string;\nexport type Password = string;\nexport type RawDate = string;\n\nexport enum HTTP_VERBS {\n  DELETE = 'DELETE',\n  GET = 'get',\n  PATCH = 'patch',\n  POST = 'post',\n  PUT = 'put'\n}\n\nexport type TargetKind = 'app' | 'service' | 'workload';\n\nexport const MILLISECONDS = 1000;\n\nexport const UNIT_TIME = {\n  SECOND: 1,\n  MINUTE: 60,\n  HOUR: 3600,\n  DAY: 24 * 3600\n};\n\nexport type TimeInMilliseconds = number;\nexport type TimeInSeconds = number;\n\nexport type IntervalInMilliseconds = number;\nexport type DurationInSeconds = number;\n\nexport type BoundsInMilliseconds = {\n  from?: TimeInMilliseconds;\n  to?: TimeInMilliseconds;\n};\n\n// Redux doesn't work well with type composition\nexport type TimeRange = {\n  from?: TimeInMilliseconds;\n  to?: TimeInMilliseconds;\n  rangeDuration?: DurationInSeconds;\n};\n\n// Type-guarding TimeRange: executes first callback when range is a duration, or second callback when it's a bounded range, mapping to a value\nexport function guardTimeRange<T>(\n  range: TimeRange,\n  ifDuration: (d: DurationInSeconds) => T,\n  ifBounded: (b: BoundsInMilliseconds) => T\n): T {\n  if (range.from) {\n    const b: BoundsInMilliseconds = {\n      from: range.from\n    };\n    if (range.to) {\n      b.to = range.to;\n    }\n    return ifBounded(b);\n  } else {\n    if (range.rangeDuration) {\n      return ifDuration(range.rangeDuration);\n    }\n  }\n  // It shouldn't reach here a TimeRange should have DurationInSeconds or BoundsInMilliseconds\n  return ifDuration(defaultMetricsDuration);\n}\n\nexport const evalTimeRange = (range: TimeRange): [Date, Date] => {\n  const bounds = guardTimeRange(range, durationToBounds, b => b);\n  return [bounds.from ? new Date(bounds.from) : new Date(), bounds.to ? new Date(bounds.to) : new Date()];\n};\n\nexport const boundsToDuration = (bounds: BoundsInMilliseconds): DurationInSeconds => {\n  return Math.floor(((bounds.to || new Date().getTime()) - (bounds.from || new Date().getTime())) / 1000);\n};\n\nexport const durationToBounds = (duration: DurationInSeconds): BoundsInMilliseconds => {\n  return {\n    from: new Date().getTime() - duration * 1000\n  };\n};\n\nexport const isEqualTimeRange = (t1: TimeRange, t2: TimeRange): boolean => {\n  if (t1.from && t2.from && t1.from !== t2.from) {\n    return false;\n  }\n  if (t1.to && t2.to && t1.to !== t2.to) {\n    return false;\n  }\n  if (t1.rangeDuration && t2.rangeDuration && t1.rangeDuration !== t2.rangeDuration) {\n    return false;\n  }\n  return true;\n};\n"]},"metadata":{},"sourceType":"module"}