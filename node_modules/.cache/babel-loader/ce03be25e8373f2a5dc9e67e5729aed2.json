{"ast":null,"code":"import _createForOfIteratorHelper from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { serverConfig } from '../../config';\nimport { generateRateForTolerance } from './ErrorRate';\nimport { generateRateForGraphTolerance } from './GraphEdgeStatus';\nimport { HealthAnnotationConfig } from '../HealthAnnotation';\nexport var emptyRate = function emptyRate() {\n  return {\n    requestRate: 0,\n    errorRate: 0,\n    errorRatio: 0\n  };\n};\nexport var DEFAULTCONF = {\n  http: new RegExp('^[4|5]\\\\d\\\\d$'),\n  grpc: new RegExp('^[1-9]$|^1[0-6]$')\n};\nexport var requestsErrorRateCode = function requestsErrorRateCode(requests) {\n  var rate = emptyRate();\n\n  for (var _i = 0, _Object$entries = Object.entries(requests); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        protocol = _Object$entries$_i[0],\n        req = _Object$entries$_i[1];\n\n    for (var _i2 = 0, _Object$entries2 = Object.entries(req); _i2 < _Object$entries2.length; _i2++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n          code = _Object$entries2$_i[0],\n          value = _Object$entries2$_i[1];\n\n      rate.requestRate += value;\n\n      if (Object.keys(DEFAULTCONF).includes(protocol) && DEFAULTCONF[protocol].test(code)) {\n        rate.errorRate += value;\n      }\n    }\n  }\n\n  return rate.requestRate === 0 ? -1 : rate.errorRate / rate.requestRate * 100;\n};\nexport var getHealthRateAnnotation = function getHealthRateAnnotation(config) {\n  return config && HealthAnnotationConfig.HEALTH_RATE in config ? config[HealthAnnotationConfig.HEALTH_RATE] : undefined;\n};\nexport var getErrorCodeRate = function getErrorCodeRate(requests) {\n  return {\n    inbound: requestsErrorRateCode(requests.inbound),\n    outbound: requestsErrorRateCode(requests.outbound)\n  };\n};\n/*\nCached this method to avoid use regexp in next calculations to improve performance\n */\n\nexport var checkExpr = function checkExpr(value, testV) {\n  var reg = value;\n\n  if (!reg) {\n    return true;\n  }\n\n  if (typeof value === 'string') {\n    reg = new RegExp(value);\n  }\n\n  return reg.test(testV);\n}; // Cache the configuration to avoid multiple calls to regExp\n\nexport var configCache = {};\nexport var getRateHealthConfig = function getRateHealthConfig(ns, name, kind) {\n  var key = ns + '_' + kind + '_' + name; // If we have the configuration cached then return it\n\n  if (configCache[key]) {\n    return configCache[key];\n  }\n\n  if (serverConfig.healthConfig && serverConfig.healthConfig.rate) {\n    var _iterator = _createForOfIteratorHelper(serverConfig.healthConfig.rate),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var rate = _step.value;\n\n        if (checkExpr(rate.namespace, ns) && checkExpr(rate.name, name) && checkExpr(rate.kind, kind)) {\n          configCache[key] = rate;\n          return rate;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return serverConfig.healthConfig.rate[serverConfig.healthConfig.rate.length - 1];\n};\n/*\nFor Responses object like { \"200\": { flags: { \"-\": 1.2, \"XXX\": 3.1}, hosts: ...} } Transform to RequestType\n\nReturn object like:  {\"http\": { \"200\": 4.3}}\n*/\n\nexport var transformEdgeResponses = function transformEdgeResponses(requests, protocol) {\n  var prot = {};\n  var result = {};\n  result[protocol] = prot;\n\n  for (var _i3 = 0, _Object$entries3 = Object.entries(requests); _i3 < _Object$entries3.length; _i3++) {\n    var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),\n        code = _Object$entries3$_i[0],\n        responseDetail = _Object$entries3$_i[1];\n\n    var percentRate = Object.values(responseDetail.flags).reduce(function (acc, value) {\n      return String(Number(acc) + Number(value));\n    });\n    result[protocol][code] = Number(percentRate);\n  }\n\n  return result;\n};\n/*\n For requests type like { \"http\": { \"200\": 3.2, \"501\": 2.3 } ...} and a Tolerance Configuration to apply calculate the RequestToleranceGraph[]\n\n Return an array object where each item is a type RequestToleranceGraph by tolerance configuration passed by parameter\n\n Sample:\n\n [{\n  tolerance: TOLERANCE CONFIGURATION,\n  requests: {\"http\": 4.3}\n }]\n where this requests are the sum of rates where match the tolerance configuration.\n\n*/\n\nexport var aggregate = function aggregate(request, tolerances) {\n  var graph = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var result = [];\n\n  if (request && tolerances) {\n    for (var _i4 = 0, _Object$values = Object.values(tolerances); _i4 < _Object$values.length; _i4++) {\n      var tol = _Object$values[_i4];\n      var newReqTol = {\n        tolerance: tol,\n        requests: {}\n      };\n      graph ? generateRateForGraphTolerance(newReqTol, request) : generateRateForTolerance(newReqTol, request);\n      result.push(newReqTol);\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/root/kiali-ui/src/types/ErrorRate/utils.ts"],"names":["serverConfig","generateRateForTolerance","generateRateForGraphTolerance","HealthAnnotationConfig","emptyRate","requestRate","errorRate","errorRatio","DEFAULTCONF","http","RegExp","grpc","requestsErrorRateCode","requests","rate","Object","entries","protocol","req","code","value","keys","includes","test","getHealthRateAnnotation","config","HEALTH_RATE","undefined","getErrorCodeRate","inbound","outbound","checkExpr","testV","reg","configCache","getRateHealthConfig","ns","name","kind","key","healthConfig","namespace","length","transformEdgeResponses","prot","result","responseDetail","percentRate","values","flags","reduce","acc","String","Number","aggregate","request","tolerances","graph","tol","newReqTol","tolerance","push"],"mappings":"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","sourcesContent":["import { RateHealthConfig, RegexConfig, ToleranceConfig } from '../ServerConfig';\nimport { serverConfig } from '../../config';\nimport { ResponseDetail, Responses } from '../Graph';\nimport { RequestHealth, RequestType } from '../Health';\nimport { Rate, RequestTolerance } from './types';\nimport { generateRateForTolerance } from './ErrorRate';\nimport { generateRateForGraphTolerance } from './GraphEdgeStatus';\nimport { HealthAnnotationType, HealthAnnotationConfig } from '../HealthAnnotation';\n\nexport const emptyRate = (): Rate => {\n  return { requestRate: 0, errorRate: 0, errorRatio: 0 };\n};\n\nexport const DEFAULTCONF = {\n  http: new RegExp('^[4|5]\\\\d\\\\d$'),\n  grpc: new RegExp('^[1-9]$|^1[0-6]$')\n};\n\nexport const requestsErrorRateCode = (requests: RequestType): number => {\n  const rate: Rate = emptyRate();\n  for (let [protocol, req] of Object.entries(requests)) {\n    for (let [code, value] of Object.entries(req)) {\n      rate.requestRate += value;\n      if (Object.keys(DEFAULTCONF).includes(protocol) && DEFAULTCONF[protocol].test(code)) {\n        rate.errorRate += value;\n      }\n    }\n  }\n  return rate.requestRate === 0 ? -1 : (rate.errorRate / rate.requestRate) * 100;\n};\n\nexport const getHealthRateAnnotation = (config?: HealthAnnotationType): string | undefined => {\n  return config && HealthAnnotationConfig.HEALTH_RATE in config\n    ? config[HealthAnnotationConfig.HEALTH_RATE]\n    : undefined;\n};\n\nexport const getErrorCodeRate = (requests: RequestHealth): { inbound: number; outbound: number } => {\n  return { inbound: requestsErrorRateCode(requests.inbound), outbound: requestsErrorRateCode(requests.outbound) };\n};\n\n/*\nCached this method to avoid use regexp in next calculations to improve performance\n */\nexport const checkExpr = (value: RegexConfig | undefined, testV: string): boolean => {\n  let reg = value;\n  if (!reg) {\n    return true;\n  }\n  if (typeof value === 'string') {\n    reg = new RegExp(value);\n  }\n  return (reg as RegExp).test(testV);\n};\n\n// Cache the configuration to avoid multiple calls to regExp\nexport let configCache: { [key: string]: RateHealthConfig } = {};\n\nexport const getRateHealthConfig = (ns: string, name: string, kind: string): RateHealthConfig => {\n  const key = ns + '_' + kind + '_' + name;\n  // If we have the configuration cached then return it\n  if (configCache[key]) {\n    return configCache[key];\n  }\n  if (serverConfig.healthConfig && serverConfig.healthConfig.rate) {\n    for (let rate of serverConfig.healthConfig.rate) {\n      if (checkExpr(rate.namespace, ns) && checkExpr(rate.name, name) && checkExpr(rate.kind, kind)) {\n        configCache[key] = rate;\n        return rate;\n      }\n    }\n  }\n  return serverConfig.healthConfig.rate[serverConfig.healthConfig.rate.length - 1];\n};\n\n/*\nFor Responses object like { \"200\": { flags: { \"-\": 1.2, \"XXX\": 3.1}, hosts: ...} } Transform to RequestType\n\nReturn object like:  {\"http\": { \"200\": 4.3}}\n*/\nexport const transformEdgeResponses = (requests: Responses, protocol: string): RequestType => {\n  const prot: { [key: string]: number } = {};\n  const result: RequestType = {};\n  result[protocol] = prot;\n  for (let [code, responseDetail] of Object.entries(requests)) {\n    const percentRate = Object.values((responseDetail as ResponseDetail).flags).reduce((acc, value) =>\n      String(Number(acc) + Number(value))\n    );\n    result[protocol][code] = Number(percentRate);\n  }\n\n  return result;\n};\n\n/*\n For requests type like { \"http\": { \"200\": 3.2, \"501\": 2.3 } ...} and a Tolerance Configuration to apply calculate the RequestToleranceGraph[]\n\n Return an array object where each item is a type RequestToleranceGraph by tolerance configuration passed by parameter\n\n Sample:\n\n [{\n  tolerance: TOLERANCE CONFIGURATION,\n  requests: {\"http\": 4.3}\n }]\n where this requests are the sum of rates where match the tolerance configuration.\n\n*/\nexport const aggregate = (\n  request: RequestType,\n  tolerances?: ToleranceConfig[],\n  graph: boolean = false\n): RequestTolerance[] => {\n  let result: RequestTolerance[] = [];\n  if (request && tolerances) {\n    for (let tol of Object.values(tolerances)) {\n      let newReqTol: RequestTolerance = { tolerance: tol, requests: {} };\n      graph ? generateRateForGraphTolerance(newReqTol, request) : generateRateForTolerance(newReqTol, request);\n      result.push(newReqTol);\n    }\n  }\n  return result;\n};\n"]},"metadata":{},"sourceType":"module"}