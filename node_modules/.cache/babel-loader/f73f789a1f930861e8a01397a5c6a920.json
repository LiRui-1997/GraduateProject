{"ast":null,"code":"import React from 'react';\nexport var windowIsUndefined = !(typeof window !== 'undefined' && window.document && window.document.createElement);\nexport function toArrayChildren(children) {\n  var ret = [];\n  React.Children.forEach(children, function (c) {\n    ret.push(c);\n  });\n  return ret;\n}\nexport function findChildInChildrenByKey(children, key) {\n  var ret = null;\n\n  if (children) {\n    children.forEach(function (c) {\n      if (ret || !c) {\n        return;\n      }\n\n      if (c.key === key) {\n        ret = c;\n      }\n    });\n  }\n\n  return ret;\n}\nexport function mergeChildren(prev, next) {\n  var ret = []; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n  var nextChildrenPending = {};\n  var pendingChildren = [];\n  var followChildrenKey;\n  prev.forEach(function (c) {\n    if (!c) {\n      return;\n    }\n\n    if (findChildInChildrenByKey(next, c.key)) {\n      if (pendingChildren.length) {\n        nextChildrenPending[c.key] = pendingChildren;\n        pendingChildren = [];\n      }\n\n      followChildrenKey = c.key;\n    } else if (c.key) {\n      pendingChildren.push(c);\n    }\n  });\n\n  if (!followChildrenKey) {\n    ret = ret.concat(pendingChildren);\n  }\n\n  next.forEach(function (c) {\n    if (!c) {\n      return;\n    }\n\n    if (nextChildrenPending.hasOwnProperty(c.key)) {\n      ret = ret.concat(nextChildrenPending[c.key]);\n    }\n\n    ret.push(c);\n\n    if (c.key === followChildrenKey) {\n      ret = ret.concat(pendingChildren);\n    }\n  });\n  return ret;\n}\nexport function transformArguments(arg, key, i) {\n  var result;\n\n  if (typeof arg === 'function') {\n    result = arg({\n      key: key,\n      index: i\n    });\n  } else {\n    result = arg;\n  }\n\n  if (Array.isArray(result)) {\n    if (result.length === 2) {\n      return result;\n    }\n\n    return [result[0], result[0]];\n  }\n\n  return [result, result];\n}","map":{"version":3,"sources":["/root/GraduateProject/node_modules/rc-queue-anim/es/utils.js"],"names":["React","windowIsUndefined","window","document","createElement","toArrayChildren","children","ret","Children","forEach","c","push","findChildInChildrenByKey","key","mergeChildren","prev","next","nextChildrenPending","pendingChildren","followChildrenKey","length","concat","hasOwnProperty","transformArguments","arg","i","result","index","Array","isArray"],"mappings":"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","sourcesContent":["import React from 'react';\nexport var windowIsUndefined = !(typeof window !== 'undefined' && window.document && window.document.createElement);\nexport function toArrayChildren(children) {\n  var ret = [];\n  React.Children.forEach(children, function (c) {\n    ret.push(c);\n  });\n  return ret;\n}\nexport function findChildInChildrenByKey(children, key) {\n  var ret = null;\n\n  if (children) {\n    children.forEach(function (c) {\n      if (ret || !c) {\n        return;\n      }\n\n      if (c.key === key) {\n        ret = c;\n      }\n    });\n  }\n\n  return ret;\n}\nexport function mergeChildren(prev, next) {\n  var ret = []; // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n  var nextChildrenPending = {};\n  var pendingChildren = [];\n  var followChildrenKey;\n  prev.forEach(function (c) {\n    if (!c) {\n      return;\n    }\n\n    if (findChildInChildrenByKey(next, c.key)) {\n      if (pendingChildren.length) {\n        nextChildrenPending[c.key] = pendingChildren;\n        pendingChildren = [];\n      }\n\n      followChildrenKey = c.key;\n    } else if (c.key) {\n      pendingChildren.push(c);\n    }\n  });\n\n  if (!followChildrenKey) {\n    ret = ret.concat(pendingChildren);\n  }\n\n  next.forEach(function (c) {\n    if (!c) {\n      return;\n    }\n\n    if (nextChildrenPending.hasOwnProperty(c.key)) {\n      ret = ret.concat(nextChildrenPending[c.key]);\n    }\n\n    ret.push(c);\n\n    if (c.key === followChildrenKey) {\n      ret = ret.concat(pendingChildren);\n    }\n  });\n  return ret;\n}\nexport function transformArguments(arg, key, i) {\n  var result;\n\n  if (typeof arg === 'function') {\n    result = arg({\n      key: key,\n      index: i\n    });\n  } else {\n    result = arg;\n  }\n\n  if (Array.isArray(result)) {\n    if (result.length === 2) {\n      return result;\n    }\n\n    return [result[0], result[0]];\n  }\n\n  return [result, result];\n}"]},"metadata":{},"sourceType":"module"}