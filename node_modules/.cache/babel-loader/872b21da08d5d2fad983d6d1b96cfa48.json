{"ast":null,"code":"import _createForOfIteratorHelper from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { EdgeLabelMode, GraphType, BoxByType, NodeType, UNKNOWN, TrafficRate, DefaultTrafficRates } from '../types/Graph';\nimport * as AlertUtils from '../utils/AlertUtils';\nimport { PromisesRegistry } from '../utils/CancelablePromises';\nimport * as API from './Api';\nimport { decorateGraphData } from '../store/Selectors/GraphData';\nimport EventEmitter from 'eventemitter3';\nimport { createSelector } from 'reselect';\nimport { NA } from 'types/Health';\nexport var EMPTY_GRAPH_DATA = {\n  nodes: [],\n  edges: []\n};\nvar PROMISE_KEY = 'CURRENT_REQUEST'; // GraphDataSource allows us to have multiple graphs in play, which functionally allows us to maintain\n// the master graph page as well as to offer mini-graphs in the detail pages.\n//\n// GraphDataSource (GDS) emits events asynchronously and has the potential to disrupt the expected\n// react+redux workflow typical of our components.  To avoid unexpected results here are some\n// [anti-]patterns for using GraphDataSource:\n//   - Do not set up GDS callbacks in nested components.  It is better to process the callbacks in the\n//     top-level component and then update props (via react or redux) and let the lower components update normally.\n//       - if A embeds B, do not have callbacks for the same GDS in A and B, just A\n//   - Avoid accessing GDS fields to access fetch information (elements, timestamps, fetchParameters, etc).  In\n//     short, the fields are volatile and can change at unexpected times.\n//       - Instead, in the callbacks save what you need to local variables or properties.  Then use them to\n//         trigger react/redux state changes normally.\n//   - Avoid passing a GDS as a property.\n//       - The only reason to do this is for an embedded component to access the GDS fields directly, which is\n//         an anti-pattern explained above.  Having said that, if you are SURE the GDS is stable, it will work\n//         (at this writing we still do this for mini-graphs).\n\nvar GraphDataSource = /*#__PURE__*/function () {\n  // Public methods\n  function GraphDataSource() {\n    var _this = this;\n\n    _classCallCheck(this, GraphDataSource);\n\n    this.graphDuration = void 0;\n    this.graphTimestamp = void 0;\n    this._errorMessage = void 0;\n    this._fetchParams = void 0;\n    this._isError = void 0;\n    this._isLoading = void 0;\n    this.eventEmitter = void 0;\n    this.graphElements = void 0;\n    this.promiseRegistry = void 0;\n    this.decoratedData = createSelector(function (graphData) {\n      return graphData;\n    }, function (graphData) {\n      return decorateGraphData(graphData);\n    });\n\n    this.fetchGraphData = function (fetchParams) {\n      var previousFetchParams = _this.fetchParameters; // Copy fetch parameters to a local attribute\n\n      _this._fetchParams = _objectSpread({}, fetchParams);\n\n      if (fetchParams.namespaces.length === 0) {\n        _this._isLoading = _this._isError = false;\n        _this.graphElements = EMPTY_GRAPH_DATA;\n        _this.graphDuration = 0;\n        _this.graphTimestamp = 0;\n\n        _this.emit('emptyNamespaces', fetchParams);\n\n        return;\n      }\n\n      var restParams = {\n        duration: fetchParams.duration + 's',\n        graphType: fetchParams.graphType,\n        includeIdleEdges: fetchParams.showIdleEdges,\n        injectServiceNodes: fetchParams.injectServiceNodes\n      };\n      var boxBy = [];\n\n      if (fetchParams.boxByCluster) {\n        boxBy.push(BoxByType.CLUSTER);\n      }\n\n      if (fetchParams.boxByNamespace) {\n        boxBy.push(BoxByType.NAMESPACE);\n      }\n\n      if (fetchParams.graphType === GraphType.APP || fetchParams.graphType === GraphType.VERSIONED_APP) {\n        boxBy.push(BoxByType.APP);\n      }\n\n      if (boxBy.length > 0) {\n        restParams.boxBy = boxBy.join(',');\n      }\n\n      if (fetchParams.queryTime) {\n        restParams.queryTime = String(Math.floor(fetchParams.queryTime / 1000));\n      } // Some appenders are expensive so only specify an appender if needed.\n\n\n      var appenders = 'deadNode,sidecarsCheck,serviceEntry,workloadEntry,istio,healthConfig';\n\n      if (fetchParams.showOperationNodes) {\n        appenders += ',aggregateNode';\n      }\n\n      if (!fetchParams.node && fetchParams.showIdleNodes) {\n        // note we only use the idleNode appender if this is NOT a drilled-in node graph and\n        // the user specifically requests to see idle nodes.\n        appenders += ',idleNode';\n      }\n\n      if (fetchParams.showSecurity) {\n        appenders += ',securityPolicy';\n      }\n\n      fetchParams.edgeLabels.forEach(function (edgeLabel) {\n        switch (edgeLabel) {\n          case EdgeLabelMode.RESPONSE_TIME_AVERAGE:\n            appenders += ',responseTime';\n            restParams.responseTime = 'avg';\n            break;\n\n          case EdgeLabelMode.RESPONSE_TIME_P50:\n            appenders += ',responseTime';\n            restParams.responseTime = '50';\n            break;\n\n          case EdgeLabelMode.RESPONSE_TIME_P95:\n            appenders += ',responseTime';\n            restParams.responseTime = '95';\n            break;\n\n          case EdgeLabelMode.RESPONSE_TIME_P99:\n            appenders += ',responseTime';\n            restParams.responseTime = '99';\n            break;\n\n          case EdgeLabelMode.THROUGHPUT_REQUEST:\n            appenders += ',throughput';\n            restParams.throughputType = 'request';\n            break;\n\n          case EdgeLabelMode.THROUGHPUT_RESPONSE:\n            appenders += ',throughput';\n            restParams.throughputType = 'response';\n            break;\n\n          case EdgeLabelMode.TRAFFIC_DISTRIBUTION:\n          case EdgeLabelMode.TRAFFIC_RATE:\n          default:\n            break;\n        }\n      });\n      restParams.appenders = appenders;\n      restParams.rateGrpc = 'none';\n      restParams.rateHttp = 'none';\n      restParams.rateTcp = 'none';\n      fetchParams.trafficRates.forEach(function (trafficRate) {\n        switch (trafficRate) {\n          case TrafficRate.GRPC_RECEIVED:\n            restParams.rateGrpc = 'received';\n            break;\n\n          case TrafficRate.GRPC_REQUEST:\n            restParams.rateGrpc = 'requests';\n            break;\n\n          case TrafficRate.GRPC_SENT:\n            restParams.rateGrpc = 'sent';\n            break;\n\n          case TrafficRate.GRPC_TOTAL:\n            restParams.rateGrpc = 'total';\n            break;\n\n          case TrafficRate.HTTP_REQUEST:\n            restParams.rateHttp = 'requests';\n            break;\n\n          case TrafficRate.TCP_RECEIVED:\n            restParams.rateTcp = 'received';\n            break;\n\n          case TrafficRate.TCP_SENT:\n            restParams.rateTcp = 'sent';\n            break;\n\n          case TrafficRate.TCP_TOTAL:\n            restParams.rateTcp = 'total';\n            break;\n\n          default:\n            break;\n        }\n      });\n      _this._isLoading = true;\n      _this._isError = false;\n\n      var isPreviousDataInvalid = previousFetchParams.namespaces.map(function (ns) {\n        return ns.name;\n      }).join() !== _this.fetchParameters.namespaces.map(function (ns) {\n        return ns.name;\n      }).join() || previousFetchParams.node !== _this.fetchParameters.node || previousFetchParams.graphType !== _this.fetchParameters.graphType || previousFetchParams.includeHealth !== _this.fetchParameters.includeHealth || previousFetchParams.injectServiceNodes !== _this.fetchParameters.injectServiceNodes || previousFetchParams.showOperationNodes !== _this.fetchParameters.showOperationNodes || previousFetchParams.showIdleNodes !== _this.fetchParameters.showIdleNodes;\n\n      if (isPreviousDataInvalid) {\n        // Reset the graph data\n        _this.graphElements = EMPTY_GRAPH_DATA;\n        _this.graphDuration = 0;\n        _this.graphTimestamp = 0;\n      }\n\n      _this.emit('loadStart', isPreviousDataInvalid, fetchParams);\n\n      if (fetchParams.node) {\n        _this.fetchDataForNode(restParams);\n      } else {\n        _this.fetchDataForNamespaces(restParams);\n      }\n    };\n\n    this.on = function (eventName, callback) {\n      _this.eventEmitter.on(eventName, callback);\n    };\n\n    this.removeListener = function (eventName, callback) {\n      _this.eventEmitter.removeListener(eventName, callback);\n    };\n\n    this.fetchForApp = function (duration, namespace, app) {\n      var params = _this.fetchForAppParams(duration, namespace, app);\n\n      params.showSecurity = true;\n\n      _this.fetchGraphData(params);\n    };\n\n    this.fetchForAppParams = function (duration, namespace, app) {\n      var params = GraphDataSource.defaultFetchParams(duration, namespace);\n      params.graphType = GraphType.APP;\n      params.node.nodeType = NodeType.APP;\n      params.node.app = app;\n      return params;\n    };\n\n    this.fetchForVersionedApp = function (duration, namespace, app) {\n      var params = _this.fetchForVersionedAppParams(duration, namespace, app);\n\n      params.showSecurity = true;\n\n      _this.fetchGraphData(params);\n    };\n\n    this.fetchForVersionedAppParams = function (duration, namespace, app) {\n      var params = GraphDataSource.defaultFetchParams(duration, namespace);\n      params.edgeLabels = [EdgeLabelMode.RESPONSE_TIME_GROUP, EdgeLabelMode.RESPONSE_TIME_P95, EdgeLabelMode.THROUGHPUT_GROUP, EdgeLabelMode.THROUGHPUT_REQUEST, EdgeLabelMode.TRAFFIC_DISTRIBUTION, EdgeLabelMode.TRAFFIC_RATE];\n      params.graphType = GraphType.VERSIONED_APP;\n      params.node.nodeType = NodeType.APP;\n      params.node.app = app;\n      return params;\n    };\n\n    this.fetchForWorkload = function (duration, namespace, workload) {\n      var params = _this.fetchForWorkloadParams(duration, namespace, workload);\n\n      params.showSecurity = true;\n\n      _this.fetchGraphData(params);\n    };\n\n    this.fetchForWorkloadParams = function (duration, namespace, workload) {\n      var params = GraphDataSource.defaultFetchParams(duration, namespace);\n      params.edgeLabels = [EdgeLabelMode.RESPONSE_TIME_GROUP, EdgeLabelMode.RESPONSE_TIME_P95, EdgeLabelMode.THROUGHPUT_GROUP, EdgeLabelMode.THROUGHPUT_REQUEST, EdgeLabelMode.TRAFFIC_DISTRIBUTION, EdgeLabelMode.TRAFFIC_RATE];\n      params.graphType = GraphType.WORKLOAD;\n      params.node.nodeType = NodeType.WORKLOAD;\n      params.node.workload = workload;\n      return params;\n    };\n\n    this.fetchForService = function (duration, namespace, service) {\n      var params = _this.fetchForServiceParams(duration, namespace, service);\n\n      params.showSecurity = true;\n\n      _this.fetchGraphData(params);\n    };\n\n    this.fetchForServiceParams = function (duration, namespace, service) {\n      var params = GraphDataSource.defaultFetchParams(duration, namespace);\n      params.edgeLabels = [EdgeLabelMode.RESPONSE_TIME_GROUP, EdgeLabelMode.RESPONSE_TIME_P95, EdgeLabelMode.THROUGHPUT_GROUP, EdgeLabelMode.THROUGHPUT_REQUEST, EdgeLabelMode.TRAFFIC_DISTRIBUTION, EdgeLabelMode.TRAFFIC_RATE];\n      params.graphType = GraphType.WORKLOAD;\n      params.node.nodeType = NodeType.SERVICE;\n      params.node.service = service;\n      return params;\n    };\n\n    this.fetchForNamespace = function (duration, namespace) {\n      var params = _this.fetchForNamespaceParams(duration, namespace);\n\n      _this.fetchGraphData(params);\n    };\n\n    this.fetchForNamespaceParams = function (duration, namespace) {\n      var params = GraphDataSource.defaultFetchParams(duration, namespace);\n      params.graphType = GraphType.WORKLOAD;\n      params.showSecurity = true;\n      return params;\n    };\n\n    this.emit = function (eventName) {\n      var _this$eventEmitter;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_this$eventEmitter = _this.eventEmitter).emit.apply(_this$eventEmitter, [eventName].concat(args));\n    };\n\n    this.fetchDataForNamespaces = function (restParams) {\n      restParams.namespaces = _this.fetchParameters.namespaces.map(function (namespace) {\n        return namespace.name;\n      }).join(',');\n\n      _this.promiseRegistry.register(PROMISE_KEY, API.getGraphElements(restParams)).then(function (response) {\n        var responseData = response.data;\n        _this.graphElements = responseData && responseData.elements ? responseData.elements : EMPTY_GRAPH_DATA;\n        _this.graphTimestamp = responseData && responseData.timestamp ? responseData.timestamp : 0;\n        _this.graphDuration = responseData && responseData.duration ? responseData.duration : 0;\n        var decoratedGraphElements = _this.graphData;\n\n        if (_this.fetchParameters.includeHealth) {\n          _this.fetchHealth(decoratedGraphElements);\n        } else {\n          _this._isLoading = _this._isError = false;\n\n          _this.emit('fetchSuccess', _this.graphTimestamp, _this.graphDuration, decoratedGraphElements, _this.fetchParameters);\n        }\n      }, function (error) {\n        _this._isLoading = false;\n\n        if (error.isCanceled) {\n          return;\n        }\n\n        _this._isError = true;\n        _this._errorMessage = API.getErrorString(error);\n        AlertUtils.addError('Cannot load the graph', error);\n\n        _this.emit('fetchError', \"Cannot load the graph: \".concat(_this.errorMessage), _this.fetchParameters);\n      });\n    };\n\n    this.fetchDataForNode = function (restParams) {\n      _this.promiseRegistry.register(PROMISE_KEY, API.getNodeGraphElements(_this.fetchParameters.node, restParams)).then(function (response) {\n        var responseData = response.data;\n        _this.graphElements = responseData && responseData.elements ? responseData.elements : EMPTY_GRAPH_DATA;\n        _this.graphTimestamp = responseData && responseData.timestamp ? responseData.timestamp : 0;\n        _this.graphDuration = responseData && responseData.duration ? responseData.duration : 0;\n        var decoratedGraphElements = _this.graphData;\n\n        if (_this.fetchParameters.includeHealth) {\n          _this.fetchHealth(decoratedGraphElements);\n        } else {\n          _this._isLoading = _this._isError = false;\n\n          _this.emit('fetchSuccess', _this.graphTimestamp, _this.graphDuration, decoratedGraphElements, _this.fetchParameters);\n        }\n      }, function (error) {\n        _this._isLoading = false;\n\n        if (error.isCanceled) {\n          return;\n        }\n\n        _this._isError = true;\n        _this._errorMessage = API.getErrorString(error);\n        AlertUtils.addError('Cannot load the graph', error);\n\n        _this.emit('fetchError', _this.errorMessage, _this.fetchParameters);\n      });\n    };\n\n    this.fetchHealth = function (decoratedGraphElements) {\n      if (!decoratedGraphElements.nodes || decoratedGraphElements.nodes.length === 0) {\n        _this._isLoading = false;\n\n        _this.emit('fetchSuccess', _this.graphTimestamp, _this.graphDuration, decoratedGraphElements, _this.fetchParameters);\n\n        return;\n      }\n\n      var duration = _this.graphDuration;\n      var queryTime = _this.graphTimestamp;\n      var appNamespacePromises = new Map();\n      var serviceNamespacePromises = new Map();\n      var workloadNamespacePromises = new Map();\n      var promiseToNode = new Map(); // Asynchronously fetch health\n\n      var _iterator = _createForOfIteratorHelper(decoratedGraphElements.nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var node = _step.value;\n\n          // ignore nodes that can not have health calculated due lack of access or lack of info\n          // note: UNKNOWN node is already marked inaccessible\n          if (node.data.isInaccessible) {\n            continue;\n          }\n\n          var namespace = node.data.namespace;\n          var nodeType = node.data.nodeType;\n          var workload = node.data.workload;\n          var workloadOk = workload && workload !== '' && workload !== UNKNOWN; // use workload health when workload is set and valid (workload nodes or versionApp nodes)\n\n          var useWorkloadHealth = nodeType === NodeType.WORKLOAD || nodeType === NodeType.APP && workloadOk;\n\n          if (useWorkloadHealth) {\n            var promise = workloadNamespacePromises.get(namespace);\n            var nodeHealth = {\n              node: node,\n              key: node.data.workload\n            };\n\n            if (!promise) {\n              promise = API.getNamespaceWorkloadHealth(namespace, duration, queryTime);\n              workloadNamespacePromises.set(namespace, promise);\n              promiseToNode.set(promise, [nodeHealth]);\n            } else {\n              var nodeHealths = promiseToNode.get(promise);\n              nodeHealths.push(nodeHealth);\n            }\n          } else {\n            switch (nodeType) {\n              case NodeType.APP:\n                {\n                  var _promise = appNamespacePromises.get(namespace);\n\n                  var _nodeHealth = {\n                    node: node,\n                    key: node.data.app\n                  };\n\n                  if (!_promise) {\n                    _promise = API.getNamespaceAppHealth(namespace, duration, queryTime);\n                    appNamespacePromises.set(namespace, _promise);\n                    promiseToNode.set(_promise, [_nodeHealth]);\n                  } else {\n                    var _nodeHealths = promiseToNode.get(_promise);\n\n                    _nodeHealths.push(_nodeHealth);\n                  }\n\n                  break;\n                }\n\n              case NodeType.BOX:\n                {\n                  if (node.data.isBox === BoxByType.APP) {\n                    var _promise2 = appNamespacePromises.get(namespace);\n\n                    var _nodeHealth2 = {\n                      node: node,\n                      key: node.data.app\n                    };\n\n                    if (!_promise2) {\n                      _promise2 = API.getNamespaceAppHealth(namespace, duration, queryTime);\n                      appNamespacePromises.set(namespace, _promise2);\n                      promiseToNode.set(_promise2, [_nodeHealth2]);\n                    } else {\n                      var _nodeHealths2 = promiseToNode.get(_promise2);\n\n                      _nodeHealths2.push(_nodeHealth2);\n                    }\n                  }\n\n                  break;\n                }\n\n              case NodeType.SERVICE:\n                {\n                  var _promise3 = serviceNamespacePromises.get(namespace);\n\n                  var _nodeHealth3 = {\n                    node: node,\n                    key: node.data.service\n                  };\n\n                  if (!_promise3) {\n                    _promise3 = API.getNamespaceServiceHealth(namespace, duration, queryTime);\n                    serviceNamespacePromises.set(namespace, _promise3);\n                    promiseToNode.set(_promise3, [_nodeHealth3]);\n                  } else {\n                    var _nodeHealths3 = promiseToNode.get(_promise3);\n\n                    _nodeHealths3.push(_nodeHealth3);\n                  }\n\n                  break;\n                }\n\n              default:\n                break;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var healthPromises = Array.from(appNamespacePromises.values());\n      healthPromises = healthPromises.concat(Array.from(serviceNamespacePromises.values()));\n      healthPromises = healthPromises.concat(Array.from(workloadNamespacePromises.values()));\n      new PromisesRegistry().registerAll('HEALTH_PROMISES', healthPromises).then(function (nsHealths) {\n        nsHealths.forEach(function (nsHealth, i) {\n          promiseToNode.get(healthPromises[i]).forEach(function (nh) {\n            var health = nsHealth[nh.key];\n\n            if (health) {\n              nh.node.data.health = health;\n              nh.node.data.healthStatus = health.getGlobalStatus().name;\n            } else {\n              nh.node.data.healthStatus = NA.name;\n              console.debug(\"No health found for [\".concat(nh.node.data.nodeType, \"] [\").concat(nh.key, \"]\"));\n            }\n          });\n        });\n        _this._isLoading = false;\n\n        _this.emit('fetchSuccess', _this.graphTimestamp, _this.graphDuration, decoratedGraphElements, _this.fetchParameters);\n      }, function (error) {\n        _this._isLoading = false;\n\n        if (error.isCanceled) {\n          return;\n        }\n\n        _this._isError = true;\n        _this._errorMessage = API.getErrorString(error);\n        AlertUtils.addError('Cannot load the graph [health]', error);\n\n        _this.emit('fetchError', _this.errorMessage, _this.fetchParameters);\n      });\n    };\n\n    this.graphElements = EMPTY_GRAPH_DATA;\n    this.graphDuration = 0;\n    this.graphTimestamp = 0;\n    this.eventEmitter = new EventEmitter();\n    this.promiseRegistry = new PromisesRegistry();\n    this._errorMessage = null;\n    this._fetchParams = {\n      duration: 0,\n      edgeLabels: [],\n      graphType: GraphType.VERSIONED_APP,\n      includeHealth: true,\n      injectServiceNodes: true,\n      namespaces: [],\n      showIdleEdges: false,\n      showIdleNodes: false,\n      showOperationNodes: false,\n      showSecurity: false,\n      trafficRates: []\n    };\n    this._isError = this._isLoading = false;\n  }\n\n  _createClass(GraphDataSource, [{\n    key: \"graphData\",\n    get: // Getters and setters\n    function get() {\n      return this.decoratedData(this.graphElements);\n    }\n  }, {\n    key: \"graphDefinition\",\n    get: function get() {\n      return {\n        duration: this.graphDuration,\n        elements: this.graphElements,\n        timestamp: this.graphTimestamp,\n        graphType: this.fetchParameters.graphType\n      };\n    }\n  }, {\n    key: \"errorMessage\",\n    get: function get() {\n      return this._errorMessage;\n    }\n  }, {\n    key: \"fetchParameters\",\n    get: function get() {\n      return this._fetchParams;\n    }\n  }, {\n    key: \"isError\",\n    get: function get() {\n      return this._isError;\n    }\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._isLoading;\n    }\n  }], [{\n    key: \"defaultFetchParams\",\n    value: // Private methods\n    function defaultFetchParams(duration, namespace) {\n      // queryTime defaults to server's 'now', leave unset\n      return {\n        boxByCluster: false,\n        boxByNamespace: false,\n        duration: duration,\n        edgeLabels: [],\n        graphType: GraphType.WORKLOAD,\n        includeHealth: true,\n        injectServiceNodes: true,\n        namespaces: [{\n          name: namespace\n        }],\n        node: {\n          app: '',\n          namespace: {\n            name: namespace\n          },\n          nodeType: NodeType.UNKNOWN,\n          service: '',\n          version: '',\n          workload: ''\n        },\n        showIdleEdges: false,\n        showIdleNodes: false,\n        showOperationNodes: false,\n        showSecurity: false,\n        trafficRates: DefaultTrafficRates\n      };\n    }\n  }]);\n\n  return GraphDataSource;\n}();\n\nexport { GraphDataSource as default };","map":{"version":3,"sources":["/root/kiali-ui/src/services/GraphDataSource.ts"],"names":["EdgeLabelMode","GraphType","BoxByType","NodeType","UNKNOWN","TrafficRate","DefaultTrafficRates","AlertUtils","PromisesRegistry","API","decorateGraphData","EventEmitter","createSelector","NA","EMPTY_GRAPH_DATA","nodes","edges","PROMISE_KEY","GraphDataSource","graphDuration","graphTimestamp","_errorMessage","_fetchParams","_isError","_isLoading","eventEmitter","graphElements","promiseRegistry","decoratedData","graphData","fetchGraphData","fetchParams","previousFetchParams","fetchParameters","namespaces","length","emit","restParams","duration","graphType","includeIdleEdges","showIdleEdges","injectServiceNodes","boxBy","boxByCluster","push","CLUSTER","boxByNamespace","NAMESPACE","APP","VERSIONED_APP","join","queryTime","String","Math","floor","appenders","showOperationNodes","node","showIdleNodes","showSecurity","edgeLabels","forEach","edgeLabel","RESPONSE_TIME_AVERAGE","responseTime","RESPONSE_TIME_P50","RESPONSE_TIME_P95","RESPONSE_TIME_P99","THROUGHPUT_REQUEST","throughputType","THROUGHPUT_RESPONSE","TRAFFIC_DISTRIBUTION","TRAFFIC_RATE","rateGrpc","rateHttp","rateTcp","trafficRates","trafficRate","GRPC_RECEIVED","GRPC_REQUEST","GRPC_SENT","GRPC_TOTAL","HTTP_REQUEST","TCP_RECEIVED","TCP_SENT","TCP_TOTAL","isPreviousDataInvalid","map","ns","name","includeHealth","fetchDataForNode","fetchDataForNamespaces","on","eventName","callback","removeListener","fetchForApp","namespace","app","params","fetchForAppParams","defaultFetchParams","nodeType","fetchForVersionedApp","fetchForVersionedAppParams","RESPONSE_TIME_GROUP","THROUGHPUT_GROUP","fetchForWorkload","workload","fetchForWorkloadParams","WORKLOAD","fetchForService","service","fetchForServiceParams","SERVICE","fetchForNamespace","fetchForNamespaceParams","args","register","getGraphElements","then","response","responseData","data","elements","timestamp","decoratedGraphElements","fetchHealth","error","isCanceled","getErrorString","addError","errorMessage","getNodeGraphElements","appNamespacePromises","Map","serviceNamespacePromises","workloadNamespacePromises","promiseToNode","isInaccessible","workloadOk","useWorkloadHealth","promise","get","nodeHealth","key","getNamespaceWorkloadHealth","set","nodeHealths","getNamespaceAppHealth","BOX","isBox","getNamespaceServiceHealth","healthPromises","Array","from","values","concat","registerAll","nsHealths","nsHealth","i","nh","health","healthStatus","getGlobalStatus","console","debug","version"],"mappings":"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","sourcesContent":["import { AppenderString, DurationInSeconds, TimeInMilliseconds, TimeInSeconds } from '../types/Common';\nimport {\n  DecoratedGraphElements,\n  EdgeLabelMode,\n  GraphDefinition,\n  GraphElements,\n  GraphType,\n  BoxByType,\n  NodeParamsType,\n  NodeType,\n  UNKNOWN,\n  DecoratedGraphNodeWrapper,\n  TrafficRate,\n  DefaultTrafficRates\n} from '../types/Graph';\nimport Namespace from '../types/Namespace';\nimport * as AlertUtils from '../utils/AlertUtils';\nimport { PromisesRegistry } from '../utils/CancelablePromises';\nimport * as API from './Api';\nimport { decorateGraphData } from '../store/Selectors/GraphData';\nimport EventEmitter from 'eventemitter3';\nimport { createSelector } from 'reselect';\nimport { NamespaceAppHealth, NamespaceServiceHealth, NamespaceWorkloadHealth, NA } from 'types/Health';\n\nexport const EMPTY_GRAPH_DATA = { nodes: [], edges: [] };\nconst PROMISE_KEY = 'CURRENT_REQUEST';\n\n// GraphDataSource allows us to have multiple graphs in play, which functionally allows us to maintain\n// the master graph page as well as to offer mini-graphs in the detail pages.\n//\n// GraphDataSource (GDS) emits events asynchronously and has the potential to disrupt the expected\n// react+redux workflow typical of our components.  To avoid unexpected results here are some\n// [anti-]patterns for using GraphDataSource:\n//   - Do not set up GDS callbacks in nested components.  It is better to process the callbacks in the\n//     top-level component and then update props (via react or redux) and let the lower components update normally.\n//       - if A embeds B, do not have callbacks for the same GDS in A and B, just A\n//   - Avoid accessing GDS fields to access fetch information (elements, timestamps, fetchParameters, etc).  In\n//     short, the fields are volatile and can change at unexpected times.\n//       - Instead, in the callbacks save what you need to local variables or properties.  Then use them to\n//         trigger react/redux state changes normally.\n//   - Avoid passing a GDS as a property.\n//       - The only reason to do this is for an embedded component to access the GDS fields directly, which is\n//         an anti-pattern explained above.  Having said that, if you are SURE the GDS is stable, it will work\n//         (at this writing we still do this for mini-graphs).\n\ntype EmitEvents = {\n  (eventName: 'loadStart', isPreviousDataInvalid: boolean, fetchParams: FetchParams): void;\n  (eventName: 'emptyNamespaces', fetchParams: FetchParams): void;\n  (eventName: 'fetchError', errorMessage: string | null, fetchParams: FetchParams): void;\n  (\n    eventName: 'fetchSuccess',\n    graphTimestamp: TimeInSeconds,\n    graphDuration: DurationInSeconds,\n    graphData: DecoratedGraphElements,\n    fetchParams: FetchParams\n  ): void;\n};\n\ntype NamespaceHealth = NamespaceAppHealth | NamespaceServiceHealth | NamespaceWorkloadHealth;\ntype NodeHealth = {\n  key: string;\n  node: DecoratedGraphNodeWrapper;\n};\n\nexport interface FetchParams {\n  boxByCluster?: boolean;\n  boxByNamespace?: boolean;\n  duration: DurationInSeconds;\n  edgeLabels: EdgeLabelMode[];\n  graphType: GraphType;\n  includeHealth: boolean;\n  injectServiceNodes: boolean;\n  namespaces: Namespace[];\n  node?: NodeParamsType;\n  queryTime?: TimeInMilliseconds; // default now\n  showIdleEdges: boolean;\n  showIdleNodes: boolean;\n  showOperationNodes: boolean;\n  showSecurity: boolean;\n  trafficRates: TrafficRate[];\n}\n\ntype OnEvents = {\n  (eventName: 'loadStart', callback: (isPreviousDataInvalid: boolean, fetchParams: FetchParams) => void): void;\n  (eventName: 'emptyNamespaces', callback: (fetchParams: FetchParams) => void): void;\n  (eventName: 'fetchError', callback: (errorMessage: string | null, fetchParams: FetchParams) => void): void;\n  (\n    eventName: 'fetchSuccess',\n    callback: (\n      graphTimestamp: TimeInSeconds,\n      graphDuration: DurationInSeconds,\n      graphData: DecoratedGraphElements,\n      fetchParams: FetchParams\n    ) => void\n  ): void;\n};\n\nexport default class GraphDataSource {\n  public graphDuration: DurationInSeconds;\n  public graphTimestamp: TimeInSeconds;\n\n  private _errorMessage: string | null;\n  private _fetchParams: FetchParams;\n  private _isError: boolean;\n  private _isLoading: boolean;\n\n  private eventEmitter: EventEmitter;\n  private graphElements: GraphElements;\n  private promiseRegistry: PromisesRegistry;\n  private decoratedData = createSelector(\n    (graphData: GraphElements) => graphData,\n    graphData => decorateGraphData(graphData)\n  );\n\n  // Public methods\n\n  constructor() {\n    this.graphElements = EMPTY_GRAPH_DATA;\n    this.graphDuration = 0;\n    this.graphTimestamp = 0;\n\n    this.eventEmitter = new EventEmitter();\n    this.promiseRegistry = new PromisesRegistry();\n\n    this._errorMessage = null;\n    this._fetchParams = {\n      duration: 0,\n      edgeLabels: [],\n      graphType: GraphType.VERSIONED_APP,\n      includeHealth: true,\n      injectServiceNodes: true,\n      namespaces: [],\n      showIdleEdges: false,\n      showIdleNodes: false,\n      showOperationNodes: false,\n      showSecurity: false,\n      trafficRates: []\n    };\n    this._isError = this._isLoading = false;\n  }\n\n  public fetchGraphData = (fetchParams: FetchParams) => {\n    const previousFetchParams = this.fetchParameters;\n\n    // Copy fetch parameters to a local attribute\n    this._fetchParams = { ...fetchParams };\n\n    if (fetchParams.namespaces.length === 0) {\n      this._isLoading = this._isError = false;\n      this.graphElements = EMPTY_GRAPH_DATA;\n      this.graphDuration = 0;\n      this.graphTimestamp = 0;\n      this.emit('emptyNamespaces', fetchParams);\n      return;\n    }\n\n    const restParams: any = {\n      duration: fetchParams.duration + 's',\n      graphType: fetchParams.graphType,\n      includeIdleEdges: fetchParams.showIdleEdges,\n      injectServiceNodes: fetchParams.injectServiceNodes\n    };\n\n    const boxBy: string[] = [];\n    if (fetchParams.boxByCluster) {\n      boxBy.push(BoxByType.CLUSTER);\n    }\n    if (fetchParams.boxByNamespace) {\n      boxBy.push(BoxByType.NAMESPACE);\n    }\n    if (fetchParams.graphType === GraphType.APP || fetchParams.graphType === GraphType.VERSIONED_APP) {\n      boxBy.push(BoxByType.APP);\n    }\n    if (boxBy.length > 0) {\n      restParams.boxBy = boxBy.join(',');\n    }\n\n    if (fetchParams.queryTime) {\n      restParams.queryTime = String(Math.floor(fetchParams.queryTime / 1000));\n    }\n\n    // Some appenders are expensive so only specify an appender if needed.\n    let appenders: AppenderString = 'deadNode,sidecarsCheck,serviceEntry,workloadEntry,istio,healthConfig';\n\n    if (fetchParams.showOperationNodes) {\n      appenders += ',aggregateNode';\n    }\n\n    if (!fetchParams.node && fetchParams.showIdleNodes) {\n      // note we only use the idleNode appender if this is NOT a drilled-in node graph and\n      // the user specifically requests to see idle nodes.\n      appenders += ',idleNode';\n    }\n\n    if (fetchParams.showSecurity) {\n      appenders += ',securityPolicy';\n    }\n\n    fetchParams.edgeLabels.forEach(edgeLabel => {\n      switch (edgeLabel) {\n        case EdgeLabelMode.RESPONSE_TIME_AVERAGE:\n          appenders += ',responseTime';\n          restParams.responseTime = 'avg';\n          break;\n        case EdgeLabelMode.RESPONSE_TIME_P50:\n          appenders += ',responseTime';\n          restParams.responseTime = '50';\n          break;\n        case EdgeLabelMode.RESPONSE_TIME_P95:\n          appenders += ',responseTime';\n          restParams.responseTime = '95';\n          break;\n        case EdgeLabelMode.RESPONSE_TIME_P99:\n          appenders += ',responseTime';\n          restParams.responseTime = '99';\n          break;\n        case EdgeLabelMode.THROUGHPUT_REQUEST:\n          appenders += ',throughput';\n          restParams.throughputType = 'request';\n          break;\n        case EdgeLabelMode.THROUGHPUT_RESPONSE:\n          appenders += ',throughput';\n          restParams.throughputType = 'response';\n          break;\n        case EdgeLabelMode.TRAFFIC_DISTRIBUTION:\n        case EdgeLabelMode.TRAFFIC_RATE:\n        default:\n          break;\n      }\n    });\n    restParams.appenders = appenders;\n\n    restParams.rateGrpc = 'none';\n    restParams.rateHttp = 'none';\n    restParams.rateTcp = 'none';\n\n    fetchParams.trafficRates.forEach(trafficRate => {\n      switch (trafficRate) {\n        case TrafficRate.GRPC_RECEIVED:\n          restParams.rateGrpc = 'received';\n          break;\n        case TrafficRate.GRPC_REQUEST:\n          restParams.rateGrpc = 'requests';\n          break;\n        case TrafficRate.GRPC_SENT:\n          restParams.rateGrpc = 'sent';\n          break;\n        case TrafficRate.GRPC_TOTAL:\n          restParams.rateGrpc = 'total';\n          break;\n        case TrafficRate.HTTP_REQUEST:\n          restParams.rateHttp = 'requests';\n          break;\n        case TrafficRate.TCP_RECEIVED:\n          restParams.rateTcp = 'received';\n          break;\n        case TrafficRate.TCP_SENT:\n          restParams.rateTcp = 'sent';\n          break;\n        case TrafficRate.TCP_TOTAL:\n          restParams.rateTcp = 'total';\n          break;\n        default:\n          break;\n      }\n    });\n\n    this._isLoading = true;\n    this._isError = false;\n\n    const isPreviousDataInvalid =\n      previousFetchParams.namespaces.map(ns => ns.name).join() !==\n        this.fetchParameters.namespaces.map(ns => ns.name).join() ||\n      previousFetchParams.node !== this.fetchParameters.node ||\n      previousFetchParams.graphType !== this.fetchParameters.graphType ||\n      previousFetchParams.includeHealth !== this.fetchParameters.includeHealth ||\n      previousFetchParams.injectServiceNodes !== this.fetchParameters.injectServiceNodes ||\n      previousFetchParams.showOperationNodes !== this.fetchParameters.showOperationNodes ||\n      previousFetchParams.showIdleNodes !== this.fetchParameters.showIdleNodes;\n\n    if (isPreviousDataInvalid) {\n      // Reset the graph data\n      this.graphElements = EMPTY_GRAPH_DATA;\n      this.graphDuration = 0;\n      this.graphTimestamp = 0;\n    }\n\n    this.emit('loadStart', isPreviousDataInvalid, fetchParams);\n    if (fetchParams.node) {\n      this.fetchDataForNode(restParams);\n    } else {\n      this.fetchDataForNamespaces(restParams);\n    }\n  };\n\n  public on: OnEvents = (eventName: any, callback: any) => {\n    this.eventEmitter.on(eventName, callback);\n  };\n\n  public removeListener: OnEvents = (eventName: any, callback: any) => {\n    this.eventEmitter.removeListener(eventName, callback);\n  };\n\n  // Some helpers\n\n  public fetchForApp = (duration: DurationInSeconds, namespace: string, app: string) => {\n    const params = this.fetchForAppParams(duration, namespace, app);\n    params.showSecurity = true;\n    this.fetchGraphData(params);\n  };\n\n  public fetchForAppParams = (duration: DurationInSeconds, namespace: string, app: string): FetchParams => {\n    const params = GraphDataSource.defaultFetchParams(duration, namespace);\n    params.graphType = GraphType.APP;\n    params.node!.nodeType = NodeType.APP;\n    params.node!.app = app;\n    return params;\n  };\n\n  public fetchForVersionedApp = (duration: DurationInSeconds, namespace: string, app: string) => {\n    const params = this.fetchForVersionedAppParams(duration, namespace, app);\n    params.showSecurity = true;\n    this.fetchGraphData(params);\n  };\n\n  public fetchForVersionedAppParams = (duration: DurationInSeconds, namespace: string, app: string): FetchParams => {\n    const params = GraphDataSource.defaultFetchParams(duration, namespace);\n    params.edgeLabels = [\n      EdgeLabelMode.RESPONSE_TIME_GROUP,\n      EdgeLabelMode.RESPONSE_TIME_P95,\n      EdgeLabelMode.THROUGHPUT_GROUP,\n      EdgeLabelMode.THROUGHPUT_REQUEST,\n      EdgeLabelMode.TRAFFIC_DISTRIBUTION,\n      EdgeLabelMode.TRAFFIC_RATE\n    ];\n    params.graphType = GraphType.VERSIONED_APP;\n    params.node!.nodeType = NodeType.APP;\n    params.node!.app = app;\n    return params;\n  };\n\n  public fetchForWorkload = (duration: DurationInSeconds, namespace: string, workload: string) => {\n    const params = this.fetchForWorkloadParams(duration, namespace, workload);\n    params.showSecurity = true;\n    this.fetchGraphData(params);\n  };\n\n  public fetchForWorkloadParams = (duration: DurationInSeconds, namespace: string, workload: string): FetchParams => {\n    const params = GraphDataSource.defaultFetchParams(duration, namespace);\n    params.edgeLabels = [\n      EdgeLabelMode.RESPONSE_TIME_GROUP,\n      EdgeLabelMode.RESPONSE_TIME_P95,\n      EdgeLabelMode.THROUGHPUT_GROUP,\n      EdgeLabelMode.THROUGHPUT_REQUEST,\n      EdgeLabelMode.TRAFFIC_DISTRIBUTION,\n      EdgeLabelMode.TRAFFIC_RATE\n    ];\n    params.graphType = GraphType.WORKLOAD;\n    params.node!.nodeType = NodeType.WORKLOAD;\n    params.node!.workload = workload;\n    return params;\n  };\n\n  public fetchForService = (duration: DurationInSeconds, namespace: string, service: string) => {\n    const params = this.fetchForServiceParams(duration, namespace, service);\n    params.showSecurity = true;\n    this.fetchGraphData(params);\n  };\n\n  public fetchForServiceParams = (duration: DurationInSeconds, namespace: string, service: string): FetchParams => {\n    const params = GraphDataSource.defaultFetchParams(duration, namespace);\n    params.edgeLabels = [\n      EdgeLabelMode.RESPONSE_TIME_GROUP,\n      EdgeLabelMode.RESPONSE_TIME_P95,\n      EdgeLabelMode.THROUGHPUT_GROUP,\n      EdgeLabelMode.THROUGHPUT_REQUEST,\n      EdgeLabelMode.TRAFFIC_DISTRIBUTION,\n      EdgeLabelMode.TRAFFIC_RATE\n    ];\n    params.graphType = GraphType.WORKLOAD;\n    params.node!.nodeType = NodeType.SERVICE;\n    params.node!.service = service;\n    return params;\n  };\n\n  public fetchForNamespace = (duration: DurationInSeconds, namespace: string) => {\n    const params = this.fetchForNamespaceParams(duration, namespace);\n    this.fetchGraphData(params);\n  };\n\n  public fetchForNamespaceParams = (duration: DurationInSeconds, namespace: string): FetchParams => {\n    const params = GraphDataSource.defaultFetchParams(duration, namespace);\n    params.graphType = GraphType.WORKLOAD;\n    params.showSecurity = true;\n    return params;\n  };\n\n  // Private methods\n\n  private static defaultFetchParams(duration: DurationInSeconds, namespace: string): FetchParams {\n    // queryTime defaults to server's 'now', leave unset\n    return {\n      boxByCluster: false,\n      boxByNamespace: false,\n      duration: duration,\n      edgeLabels: [],\n      graphType: GraphType.WORKLOAD,\n      includeHealth: true,\n      injectServiceNodes: true,\n      namespaces: [{ name: namespace }],\n      node: {\n        app: '',\n        namespace: { name: namespace },\n        nodeType: NodeType.UNKNOWN,\n        service: '',\n        version: '',\n        workload: ''\n      },\n      showIdleEdges: false,\n      showIdleNodes: false,\n      showOperationNodes: false,\n      showSecurity: false,\n      trafficRates: DefaultTrafficRates\n    };\n  }\n\n  private emit: EmitEvents = (eventName: any, ...args) => {\n    this.eventEmitter.emit(eventName, ...args);\n  };\n\n  private fetchDataForNamespaces = (restParams: any) => {\n    restParams.namespaces = this.fetchParameters.namespaces.map(namespace => namespace.name).join(',');\n    this.promiseRegistry.register(PROMISE_KEY, API.getGraphElements(restParams)).then(\n      response => {\n        const responseData: any = response.data;\n        this.graphElements = responseData && responseData.elements ? responseData.elements : EMPTY_GRAPH_DATA;\n        this.graphTimestamp = responseData && responseData.timestamp ? responseData.timestamp : 0;\n        this.graphDuration = responseData && responseData.duration ? responseData.duration : 0;\n        const decoratedGraphElements = this.graphData;\n        if (this.fetchParameters.includeHealth) {\n          this.fetchHealth(decoratedGraphElements);\n        } else {\n          this._isLoading = this._isError = false;\n          this.emit(\n            'fetchSuccess',\n            this.graphTimestamp,\n            this.graphDuration,\n            decoratedGraphElements,\n            this.fetchParameters\n          );\n        }\n      },\n      error => {\n        this._isLoading = false;\n        if (error.isCanceled) {\n          return;\n        }\n\n        this._isError = true;\n        this._errorMessage = API.getErrorString(error);\n        AlertUtils.addError('Cannot load the graph', error);\n        this.emit('fetchError', `Cannot load the graph: ${this.errorMessage}`, this.fetchParameters);\n      }\n    );\n  };\n\n  private fetchDataForNode = (restParams: any) => {\n    this.promiseRegistry.register(PROMISE_KEY, API.getNodeGraphElements(this.fetchParameters.node!, restParams)).then(\n      response => {\n        const responseData: any = response.data;\n        this.graphElements = responseData && responseData.elements ? responseData.elements : EMPTY_GRAPH_DATA;\n        this.graphTimestamp = responseData && responseData.timestamp ? responseData.timestamp : 0;\n        this.graphDuration = responseData && responseData.duration ? responseData.duration : 0;\n        const decoratedGraphElements = this.graphData;\n        if (this.fetchParameters.includeHealth) {\n          this.fetchHealth(decoratedGraphElements);\n        } else {\n          this._isLoading = this._isError = false;\n          this.emit(\n            'fetchSuccess',\n            this.graphTimestamp,\n            this.graphDuration,\n            decoratedGraphElements,\n            this.fetchParameters\n          );\n        }\n      },\n      error => {\n        this._isLoading = false;\n        if (error.isCanceled) {\n          return;\n        }\n\n        this._isError = true;\n        this._errorMessage = API.getErrorString(error);\n        AlertUtils.addError('Cannot load the graph', error);\n        this.emit('fetchError', this.errorMessage, this.fetchParameters);\n      }\n    );\n  };\n\n  // Limit health fetches to only the necessary namespaces for the necessary types\n  private fetchHealth = (decoratedGraphElements: DecoratedGraphElements) => {\n    if (!decoratedGraphElements.nodes || decoratedGraphElements.nodes.length === 0) {\n      this._isLoading = false;\n      this.emit('fetchSuccess', this.graphTimestamp, this.graphDuration, decoratedGraphElements, this.fetchParameters);\n\n      return;\n    }\n\n    const duration = this.graphDuration;\n    const queryTime = this.graphTimestamp;\n    const appNamespacePromises = new Map<string, Promise<NamespaceAppHealth>>();\n    const serviceNamespacePromises = new Map<string, Promise<NamespaceServiceHealth>>();\n    const workloadNamespacePromises = new Map<string, Promise<NamespaceWorkloadHealth>>();\n\n    const promiseToNode = new Map<Promise<NamespaceHealth>, NodeHealth[]>();\n\n    // Asynchronously fetch health\n    for (const node of decoratedGraphElements.nodes) {\n      // ignore nodes that can not have health calculated due lack of access or lack of info\n      // note: UNKNOWN node is already marked inaccessible\n      if (node.data.isInaccessible) {\n        continue;\n      }\n      const namespace = node.data.namespace;\n      const nodeType = node.data.nodeType;\n      const workload = node.data.workload;\n      const workloadOk = workload && workload !== '' && workload !== UNKNOWN;\n      // use workload health when workload is set and valid (workload nodes or versionApp nodes)\n      const useWorkloadHealth = nodeType === NodeType.WORKLOAD || (nodeType === NodeType.APP && workloadOk);\n\n      if (useWorkloadHealth) {\n        let promise = workloadNamespacePromises.get(namespace);\n        const nodeHealth = { node: node, key: node.data.workload! };\n        if (!promise) {\n          promise = API.getNamespaceWorkloadHealth(namespace, duration, queryTime);\n          workloadNamespacePromises.set(namespace, promise);\n          promiseToNode.set(promise, [nodeHealth]);\n        } else {\n          const nodeHealths = promiseToNode.get(promise);\n          nodeHealths!.push(nodeHealth);\n        }\n      } else {\n        switch (nodeType) {\n          case NodeType.APP: {\n            let promise = appNamespacePromises.get(namespace);\n            const nodeHealth = { node: node, key: node.data.app! };\n            if (!promise) {\n              promise = API.getNamespaceAppHealth(namespace, duration, queryTime);\n              appNamespacePromises.set(namespace, promise);\n              promiseToNode.set(promise, [nodeHealth]);\n            } else {\n              const nodeHealths = promiseToNode.get(promise);\n              nodeHealths!.push(nodeHealth);\n            }\n            break;\n          }\n          case NodeType.BOX: {\n            if (node.data.isBox === BoxByType.APP) {\n              let promise = appNamespacePromises.get(namespace);\n              const nodeHealth = { node: node, key: node.data.app! };\n              if (!promise) {\n                promise = API.getNamespaceAppHealth(namespace, duration, queryTime);\n                appNamespacePromises.set(namespace, promise);\n                promiseToNode.set(promise, [nodeHealth]);\n              } else {\n                const nodeHealths = promiseToNode.get(promise);\n                nodeHealths!.push(nodeHealth);\n              }\n            }\n            break;\n          }\n          case NodeType.SERVICE: {\n            let promise = serviceNamespacePromises.get(namespace);\n            const nodeHealth = { node: node, key: node.data.service! };\n            if (!promise) {\n              promise = API.getNamespaceServiceHealth(namespace, duration, queryTime);\n              serviceNamespacePromises.set(namespace, promise);\n              promiseToNode.set(promise, [nodeHealth]);\n            } else {\n              const nodeHealths = promiseToNode.get(promise);\n              nodeHealths!.push(nodeHealth);\n            }\n            break;\n          }\n          default:\n            break;\n        }\n      }\n    }\n\n    let healthPromises: Promise<NamespaceHealth>[] = Array.from(appNamespacePromises.values());\n    healthPromises = healthPromises.concat(Array.from(serviceNamespacePromises.values()));\n    healthPromises = healthPromises.concat(Array.from(workloadNamespacePromises.values()));\n\n    new PromisesRegistry().registerAll('HEALTH_PROMISES', healthPromises).then(\n      nsHealths => {\n        nsHealths.forEach((nsHealth, i) => {\n          promiseToNode.get(healthPromises[i])!.forEach(nh => {\n            const health = nsHealth[nh.key];\n            if (health) {\n              nh.node.data.health = health;\n              nh.node.data.healthStatus = health.getGlobalStatus().name;\n            } else {\n              nh.node.data.healthStatus = NA.name;\n              console.debug(`No health found for [${nh.node.data.nodeType}] [${nh.key}]`);\n            }\n          });\n        });\n\n        this._isLoading = false;\n        this.emit(\n          'fetchSuccess',\n          this.graphTimestamp,\n          this.graphDuration,\n          decoratedGraphElements,\n          this.fetchParameters\n        );\n      },\n      error => {\n        this._isLoading = false;\n        if (error.isCanceled) {\n          return;\n        }\n\n        this._isError = true;\n        this._errorMessage = API.getErrorString(error);\n        AlertUtils.addError('Cannot load the graph [health]', error);\n        this.emit('fetchError', this.errorMessage, this.fetchParameters);\n      }\n    );\n  };\n\n  // Getters and setters\n  public get graphData(): DecoratedGraphElements {\n    return this.decoratedData(this.graphElements);\n  }\n\n  public get graphDefinition(): GraphDefinition {\n    return {\n      duration: this.graphDuration,\n      elements: this.graphElements,\n      timestamp: this.graphTimestamp,\n      graphType: this.fetchParameters.graphType\n    };\n  }\n\n  public get errorMessage(): string | null {\n    return this._errorMessage;\n  }\n\n  public get fetchParameters(): FetchParams {\n    return this._fetchParams;\n  }\n\n  public get isError(): boolean {\n    return this._isError;\n  }\n\n  public get isLoading(): boolean {\n    return this._isLoading;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}