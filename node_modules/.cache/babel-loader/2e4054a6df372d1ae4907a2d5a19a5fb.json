{"ast":null,"code":"import _toConsumableArray from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as API from 'services/Api';\nimport * as AlertUtils from 'utils/AlertUtils';\nimport { getTimeRangeMicros } from 'utils/tracing/TracingHelper';\nimport transformTraceData from 'utils/tracing/TraceTransform';\nexport var TracesFetcher = /*#__PURE__*/function () {\n  function TracesFetcher(onChange, onErrors) {\n    var _this = this;\n\n    _classCallCheck(this, TracesFetcher);\n\n    this.onChange = onChange;\n    this.onErrors = onErrors;\n    this.lastFetchMicros = undefined;\n\n    this.fetch = function (o, oldTraces) {\n      var range = getTimeRangeMicros();\n\n      if (range.to) {\n        // Closed time frame (looking in past)\n        // Turning off incremental refresh as it doesn't make sense with bounded end time\n        _this.lastFetchMicros = undefined;\n      } // Incremental refresh\n\n\n      var traces = _this.lastFetchMicros ? oldTraces.filter(function (t) {\n        return t.startTime >= range.from;\n      }) : [];\n      var q = {\n        startMicros: _this.lastFetchMicros || range.from,\n        endMicros: range.to,\n        tags: o.tags,\n        limit: o.spanLimit,\n        minDuration: o.minDuration ? Math.floor(1000 * o.minDuration) : undefined\n      };\n      var apiCall = o.targetKind === 'app' ? API.getAppTraces : o.targetKind === 'service' ? API.getServiceTraces : API.getWorkloadTraces;\n      apiCall(o.namespace, o.target, q).then(function (response) {\n        var newTraces = response.data.data ? response.data.data.map(function (trace) {\n          return transformTraceData(trace);\n        }).filter(function (trace) {\n          return trace !== null;\n        }) : [];\n        traces = traces // It may happen that a previous trace was updated. If so, replace it (remove from old).\n        .filter(function (oldTrace) {\n          return !newTraces.map(function (newTrace) {\n            return newTrace.traceID;\n          }).includes(oldTrace.traceID);\n        }).concat(newTraces); // Update last fetch time only if we had some results\n        // So that if Jaeger DB hadn't time to ingest data, it's still going to be fetched next time\n\n        if (traces.length > 0) {\n          _this.lastFetchMicros = Math.max.apply(Math, _toConsumableArray(traces.map(function (s) {\n            return s.startTime;\n          })));\n        }\n\n        _this.onChange(traces, response.data.jaegerServiceName);\n\n        if (response.data.errors && response.data.errors.length > 0) {\n          _this.onErrors(response.data.errors);\n        }\n      }).catch(function (error) {\n        AlertUtils.addError('Could not fetch traces.', error);\n\n        _this.onErrors([{\n          msg: String(error)\n        }]);\n      });\n    };\n  }\n\n  _createClass(TracesFetcher, [{\n    key: \"resetLastFetchTime\",\n    value: function resetLastFetchTime() {\n      this.lastFetchMicros = undefined;\n    }\n  }]);\n\n  return TracesFetcher;\n}();","map":{"version":3,"sources":["/root/GraduateProject/src/components/JaegerIntegration/TracesFetcher.ts"],"names":["API","AlertUtils","getTimeRangeMicros","transformTraceData","TracesFetcher","onChange","onErrors","lastFetchMicros","undefined","fetch","o","oldTraces","range","to","traces","filter","t","startTime","from","q","startMicros","endMicros","tags","limit","spanLimit","minDuration","Math","floor","apiCall","targetKind","getAppTraces","getServiceTraces","getWorkloadTraces","namespace","target","then","response","newTraces","data","map","trace","oldTrace","newTrace","traceID","includes","concat","length","max","s","jaegerServiceName","errors","catch","error","addError","msg","String"],"mappings":"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","sourcesContent":["import * as API from 'services/Api';\nimport * as AlertUtils from 'utils/AlertUtils';\nimport { JaegerTrace, JaegerError } from 'types/JaegerInfo';\nimport { TracingQuery } from 'types/Tracing';\nimport { TargetKind } from 'types/Common';\nimport { getTimeRangeMicros } from 'utils/tracing/TracingHelper';\nimport transformTraceData from 'utils/tracing/TraceTransform';\n\nexport type FetchOptions = {\n  namespace: string;\n  target: string;\n  targetKind: TargetKind;\n  spanLimit: number;\n  tags: string;\n  minDuration?: number;\n};\n\nexport class TracesFetcher {\n  private lastFetchMicros: number | undefined = undefined;\n\n  constructor(\n    private onChange: (traces: JaegerTrace[], jaegerServiceName: string) => void,\n    private onErrors: (err: JaegerError[]) => void\n  ) {}\n\n  fetch = (o: FetchOptions, oldTraces: JaegerTrace[]) => {\n    const range = getTimeRangeMicros();\n    if (range.to) {\n      // Closed time frame (looking in past)\n      // Turning off incremental refresh as it doesn't make sense with bounded end time\n      this.lastFetchMicros = undefined;\n    }\n    // Incremental refresh\n    let traces = this.lastFetchMicros ? oldTraces.filter(t => t.startTime >= range.from) : [];\n    const q: TracingQuery = {\n      startMicros: this.lastFetchMicros || range.from,\n      endMicros: range.to,\n      tags: o.tags,\n      limit: o.spanLimit,\n      minDuration: o.minDuration ? Math.floor(1000 * o.minDuration) : undefined\n    };\n    const apiCall =\n      o.targetKind === 'app'\n        ? API.getAppTraces\n        : o.targetKind === 'service'\n        ? API.getServiceTraces\n        : API.getWorkloadTraces;\n    apiCall(o.namespace, o.target, q)\n      .then(response => {\n        const newTraces = response.data.data\n          ? (response.data.data\n              .map(trace => transformTraceData(trace))\n              .filter(trace => trace !== null) as JaegerTrace[])\n          : [];\n        traces = traces\n          // It may happen that a previous trace was updated. If so, replace it (remove from old).\n          .filter(oldTrace => !newTraces.map(newTrace => newTrace.traceID).includes(oldTrace.traceID))\n          .concat(newTraces);\n        // Update last fetch time only if we had some results\n        // So that if Jaeger DB hadn't time to ingest data, it's still going to be fetched next time\n        if (traces.length > 0) {\n          this.lastFetchMicros = Math.max(...traces.map(s => s.startTime));\n        }\n        this.onChange(traces, response.data.jaegerServiceName);\n        if (response.data.errors && response.data.errors.length > 0) {\n          this.onErrors(response.data.errors);\n        }\n      })\n      .catch(error => {\n        AlertUtils.addError('Could not fetch traces.', error);\n        this.onErrors([{ msg: String(error) }]);\n      });\n  };\n\n  resetLastFetchTime() {\n    this.lastFetchMicros = undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}