{"ast":null,"code":"import _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar _jsxFileName = \"/root/kiali-ui/src/components/TrafficList/TrafficDetails.tsx\";\nimport * as React from 'react';\nimport { Card, CardBody, Grid, GridItem } from '@patternfly/react-core';\nimport * as AlertUtils from '../../utils/AlertUtils';\nimport { NodeType } from '../../types/Graph';\nimport { RenderComponentScroll } from '../Nav/Page';\nimport { MetricsObjectTypes } from '../../types/Metrics';\nimport GraphDataSource from 'services/GraphDataSource';\nimport TrafficListComponent from 'components/TrafficList/TrafficListComponent';\nimport * as FilterHelper from '../FilterList/FilterHelper';\nimport * as TrafficListFilters from './FiltersAndSorts';\nimport { connect } from 'react-redux';\nimport { durationSelector } from '../../store/Selectors';\n\nvar TrafficDetails = /*#__PURE__*/function (_React$Component) {\n  _inherits(TrafficDetails, _React$Component);\n\n  var _super = _createSuper(TrafficDetails);\n\n  function TrafficDetails(props) {\n    var _this;\n\n    _classCallCheck(this, TrafficDetails);\n\n    _this = _super.call(this, props);\n    _this.graphDataSource = new GraphDataSource();\n\n    _this.fetchDataSource = function () {\n      switch (_this.props.itemType) {\n        case MetricsObjectTypes.SERVICE:\n          {\n            var params = _this.graphDataSource.fetchForServiceParams(_this.props.duration, _this.props.namespace, _this.props.itemName);\n\n            params.includeHealth = false;\n\n            _this.graphDataSource.fetchGraphData(params);\n\n            break;\n          }\n\n        case MetricsObjectTypes.WORKLOAD:\n          {\n            var _params = _this.graphDataSource.fetchForWorkloadParams(_this.props.duration, _this.props.namespace, _this.props.itemName);\n\n            _params.includeHealth = false;\n            _params.injectServiceNodes = false;\n\n            _this.graphDataSource.fetchGraphData(_params);\n\n            break;\n          }\n\n        case MetricsObjectTypes.APP:\n          {\n            var _params2 = _this.graphDataSource.fetchForAppParams(_this.props.duration, _this.props.namespace, _this.props.itemName);\n\n            _params2.includeHealth = false;\n            _params2.injectServiceNodes = false;\n\n            _this.graphDataSource.fetchGraphData(_params2);\n\n            break;\n          }\n      }\n    };\n\n    _this.graphDsFetchSuccess = function () {\n      _this.processTrafficData(_this.graphDataSource.graphDefinition);\n    };\n\n    _this.graphDsFetchError = function (errorMessage) {\n      if (errorMessage !== '') {\n        errorMessage = 'Could not fetch traffic data: ' + errorMessage;\n      } else {\n        errorMessage = 'Could not fetch traffic data.';\n      }\n\n      AlertUtils.addError(errorMessage);\n    };\n\n    _this.buildTrafficNode = function (prefix, node) {\n      // given restrictions on fetch options the node type should be either App, Workload or [outbound] service\n      switch (node.nodeType) {\n        case NodeType.APP:\n          return {\n            id: \"\".concat(prefix, \"-\").concat(node.id),\n            type: node.nodeType,\n            namespace: node.namespace,\n            name: node.app || 'unknown',\n            version: node.version || '',\n            isInaccessible: node.isInaccessible || false\n          };\n\n        case NodeType.SERVICE:\n          return {\n            id: \"\".concat(prefix, \"-\").concat(node.id),\n            type: node.nodeType,\n            namespace: node.namespace,\n            name: node.service || 'unknown',\n            isServiceEntry: node.isServiceEntry,\n            isInaccessible: node.isInaccessible || false,\n            destServices: node.destServices,\n            healthAnnotation: node.hasHealthConfig\n          };\n\n        default:\n          return {\n            id: \"\".concat(prefix, \"-\").concat(node.id),\n            type: NodeType.WORKLOAD,\n            namespace: node.namespace,\n            name: node.workload || 'unknown',\n            isInaccessible: node.isInaccessible || false,\n            healthAnnotation: node.hasHealthConfig\n          };\n      }\n    };\n\n    _this.processTraffic = function (edges, nodes, myNode) {\n      var traffic = [];\n      edges.forEach(function (edge) {\n        var sourceNode = nodes['id-' + edge.data.source];\n        var targetNode = nodes['id-' + edge.data.target];\n\n        if (myNode.id === edge.data.source) {\n          var trafficItem = {\n            direction: 'outbound',\n            node: _this.buildTrafficNode('out', targetNode),\n            traffic: edge.data.traffic\n          };\n          traffic.push(trafficItem);\n        } else if (myNode.id === edge.data.target) {\n          var _trafficItem = {\n            direction: 'inbound',\n            node: _this.buildTrafficNode('in', sourceNode),\n            traffic: edge.data.traffic\n          };\n          traffic.push(_trafficItem);\n        }\n      });\n      return {\n        traffic: traffic\n      };\n    };\n\n    _this.processTrafficData = function (traffic) {\n      if (!traffic || !traffic.elements.nodes || !traffic.elements.edges || traffic.elements.nodes.length === 0 || traffic.elements.edges.length === 0) {\n        _this.setState({\n          traffic: []\n        });\n\n        return;\n      } // Index nodes by id and find the node of the queried item\n\n\n      var nodes = {};\n      var myNode = {\n        id: '',\n        nodeType: NodeType.UNKNOWN,\n        cluster: '',\n        namespace: ''\n      };\n      traffic.elements.nodes.forEach(function (element) {\n        // Ignore box nodes. They are not relevant for the traffic list because we\n        // are interested in the actual apps.\n        if (!element.data.isBox) {\n          nodes['id-' + element.data.id] = element.data;\n\n          if (element.data.namespace) {\n            var isMyWorkload = _this.props.itemType === MetricsObjectTypes.WORKLOAD && element.data.nodeType === NodeType.WORKLOAD && _this.props.itemName === element.data.workload;\n            var isMyApp = _this.props.itemType === MetricsObjectTypes.APP && element.data.nodeType === NodeType.APP && _this.props.itemName === element.data.app;\n            var isMyService = _this.props.itemType === MetricsObjectTypes.SERVICE && element.data.nodeType === NodeType.SERVICE && _this.props.itemName === element.data.service;\n\n            if (isMyWorkload || isMyApp || isMyService) {\n              myNode = element.data;\n            }\n          }\n        }\n      });\n\n      if (myNode.id === '') {\n        // Graph endpoint didn't return a graph for the current node.\n        _this.setState({\n          traffic: []\n        });\n\n        return;\n      } // Process the direct inbound/outbound traffic to/from the item of interest.\n\n\n      _this.setState(_this.processTraffic(traffic.elements.edges, nodes, myNode));\n    };\n\n    _this.state = {\n      traffic: []\n    };\n    return _this;\n  }\n\n  _createClass(TrafficDetails, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.graphDataSource.on('fetchSuccess', this.graphDsFetchSuccess);\n      this.graphDataSource.on('fetchError', this.graphDsFetchError);\n      this.fetchDataSource();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.graphDataSource.removeListener('fetchSuccess', this.graphDsFetchSuccess);\n      this.graphDataSource.removeListener('fetchError', this.graphDsFetchError);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var durationChanged = prevProps.duration !== this.props.duration;\n      var itemNameChanged = prevProps.itemName !== this.props.itemName;\n      var itemTypeChanged = prevProps.itemType !== this.props.itemType;\n      var namespaceChanged = prevProps.namespace !== this.props.namespace;\n      var refreshChanged = prevProps.lastRefreshAt !== this.props.lastRefreshAt;\n\n      if (durationChanged || itemNameChanged || itemTypeChanged || namespaceChanged || refreshChanged) {\n        this.fetchDataSource();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RenderComponentScroll, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 113,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(Grid, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 114,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(GridItem, {\n        span: 12,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 115,\n          columnNumber: 13\n        }\n      }, /*#__PURE__*/React.createElement(Card, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 116,\n          columnNumber: 15\n        }\n      }, /*#__PURE__*/React.createElement(CardBody, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 117,\n          columnNumber: 17\n        }\n      }, /*#__PURE__*/React.createElement(TrafficListComponent, {\n        currentSortField: FilterHelper.currentSortField(TrafficListFilters.sortFields),\n        isSortAscending: FilterHelper.isCurrentSortAscending(),\n        trafficItems: this.state.traffic,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 118,\n          columnNumber: 19\n        }\n      })))))));\n    }\n  }]);\n\n  return TrafficDetails;\n}(React.Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    duration: durationSelector(state),\n    lastRefreshAt: state.globalState.lastRefreshAt\n  };\n};\n\nvar TrafficDetailsContainer = connect(mapStateToProps)(TrafficDetails);\nexport default TrafficDetailsContainer;","map":{"version":3,"sources":["/root/kiali-ui/src/components/TrafficList/TrafficDetails.tsx"],"names":["React","Card","CardBody","Grid","GridItem","AlertUtils","NodeType","RenderComponentScroll","MetricsObjectTypes","GraphDataSource","TrafficListComponent","FilterHelper","TrafficListFilters","connect","durationSelector","TrafficDetails","props","graphDataSource","fetchDataSource","itemType","SERVICE","params","fetchForServiceParams","duration","namespace","itemName","includeHealth","fetchGraphData","WORKLOAD","fetchForWorkloadParams","injectServiceNodes","APP","fetchForAppParams","graphDsFetchSuccess","processTrafficData","graphDefinition","graphDsFetchError","errorMessage","addError","buildTrafficNode","prefix","node","nodeType","id","type","name","app","version","isInaccessible","service","isServiceEntry","destServices","healthAnnotation","hasHealthConfig","workload","processTraffic","edges","nodes","myNode","traffic","forEach","edge","sourceNode","data","source","targetNode","target","trafficItem","direction","push","elements","length","setState","UNKNOWN","cluster","element","isBox","isMyWorkload","isMyApp","isMyService","state","on","removeListener","prevProps","durationChanged","itemNameChanged","itemTypeChanged","namespaceChanged","refreshChanged","lastRefreshAt","currentSortField","sortFields","isCurrentSortAscending","Component","mapStateToProps","globalState","TrafficDetailsContainer"],"mappings":";;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,IAAT,EAAeC,QAAf,EAAyBC,IAAzB,EAA+BC,QAA/B,QAA+C,wBAA/C;AACA,OAAO,KAAKC,UAAZ,MAA4B,wBAA5B;AACA,SAIEC,QAJF,QAQO,mBARP;AASA,SAASC,qBAAT,QAAsC,aAAtC;AACA,SAASC,kBAAT,QAAmC,qBAAnC;AACA,OAAOC,eAAP,MAA4B,0BAA5B;AAEA,OAAOC,oBAAP,MAAiC,6CAAjC;AACA,OAAO,KAAKC,YAAZ,MAA8B,4BAA9B;AACA,OAAO,KAAKC,kBAAZ,MAAoC,mBAApC;AAEA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,gBAAT,QAAiC,uBAAjC;;IAuDMC,c;;;;;AAGJ,0BAAYC,KAAZ,EAAwC;AAAA;;AAAA;;AACtC,8BAAMA,KAAN;AADsC,UAFhCC,eAEgC,GAFd,IAAIR,eAAJ,EAEc;;AAAA,UAoDhCS,eApDgC,GAoDd,YAAM;AAC9B,cAAQ,MAAKF,KAAL,CAAWG,QAAnB;AACE,aAAKX,kBAAkB,CAACY,OAAxB;AAAiC;AAC/B,gBAAMC,MAAM,GAAG,MAAKJ,eAAL,CAAqBK,qBAArB,CACb,MAAKN,KAAL,CAAWO,QADE,EAEb,MAAKP,KAAL,CAAWQ,SAFE,EAGb,MAAKR,KAAL,CAAWS,QAHE,CAAf;;AAKAJ,YAAAA,MAAM,CAACK,aAAP,GAAuB,KAAvB;;AACA,kBAAKT,eAAL,CAAqBU,cAArB,CAAoCN,MAApC;;AACA;AACD;;AACD,aAAKb,kBAAkB,CAACoB,QAAxB;AAAkC;AAChC,gBAAMP,OAAM,GAAG,MAAKJ,eAAL,CAAqBY,sBAArB,CACb,MAAKb,KAAL,CAAWO,QADE,EAEb,MAAKP,KAAL,CAAWQ,SAFE,EAGb,MAAKR,KAAL,CAAWS,QAHE,CAAf;;AAKAJ,YAAAA,OAAM,CAACK,aAAP,GAAuB,KAAvB;AACAL,YAAAA,OAAM,CAACS,kBAAP,GAA4B,KAA5B;;AACA,kBAAKb,eAAL,CAAqBU,cAArB,CAAoCN,OAApC;;AACA;AACD;;AACD,aAAKb,kBAAkB,CAACuB,GAAxB;AAA6B;AAC3B,gBAAMV,QAAM,GAAG,MAAKJ,eAAL,CAAqBe,iBAArB,CACb,MAAKhB,KAAL,CAAWO,QADE,EAEb,MAAKP,KAAL,CAAWQ,SAFE,EAGb,MAAKR,KAAL,CAAWS,QAHE,CAAf;;AAKAJ,YAAAA,QAAM,CAACK,aAAP,GAAuB,KAAvB;AACAL,YAAAA,QAAM,CAACS,kBAAP,GAA4B,KAA5B;;AACA,kBAAKb,eAAL,CAAqBU,cAArB,CAAoCN,QAApC;;AACA;AACD;AAhCH;AAkCD,KAvFuC;;AAAA,UAyFhCY,mBAzFgC,GAyFV,YAAM;AAClC,YAAKC,kBAAL,CAAwB,MAAKjB,eAAL,CAAqBkB,eAA7C;AACD,KA3FuC;;AAAA,UA6FhCC,iBA7FgC,GA6FZ,UAACC,YAAD,EAAiC;AAC3D,UAAIA,YAAY,KAAK,EAArB,EAAyB;AACvBA,QAAAA,YAAY,GAAG,mCAAmCA,YAAlD;AACD,OAFD,MAEO;AACLA,QAAAA,YAAY,GAAG,+BAAf;AACD;;AAEDhC,MAAAA,UAAU,CAACiC,QAAX,CAAoBD,YAApB;AACD,KArGuC;;AAAA,UAuGhCE,gBAvGgC,GAuGb,UAACC,MAAD,EAAuBC,IAAvB,EAA4D;AACrF;AACA,cAAQA,IAAI,CAACC,QAAb;AACE,aAAKpC,QAAQ,CAACyB,GAAd;AACE,iBAAO;AACLY,YAAAA,EAAE,YAAKH,MAAL,cAAeC,IAAI,CAACE,EAApB,CADG;AAELC,YAAAA,IAAI,EAAEH,IAAI,CAACC,QAFN;AAGLlB,YAAAA,SAAS,EAAEiB,IAAI,CAACjB,SAHX;AAILqB,YAAAA,IAAI,EAAEJ,IAAI,CAACK,GAAL,IAAY,SAJb;AAKLC,YAAAA,OAAO,EAAEN,IAAI,CAACM,OAAL,IAAgB,EALpB;AAMLC,YAAAA,cAAc,EAAEP,IAAI,CAACO,cAAL,IAAuB;AANlC,WAAP;;AAQF,aAAK1C,QAAQ,CAACc,OAAd;AACE,iBAAO;AACLuB,YAAAA,EAAE,YAAKH,MAAL,cAAeC,IAAI,CAACE,EAApB,CADG;AAELC,YAAAA,IAAI,EAAEH,IAAI,CAACC,QAFN;AAGLlB,YAAAA,SAAS,EAAEiB,IAAI,CAACjB,SAHX;AAILqB,YAAAA,IAAI,EAAEJ,IAAI,CAACQ,OAAL,IAAgB,SAJjB;AAKLC,YAAAA,cAAc,EAAET,IAAI,CAACS,cALhB;AAMLF,YAAAA,cAAc,EAAEP,IAAI,CAACO,cAAL,IAAuB,KANlC;AAOLG,YAAAA,YAAY,EAAEV,IAAI,CAACU,YAPd;AAQLC,YAAAA,gBAAgB,EAAEX,IAAI,CAACY;AARlB,WAAP;;AAUF;AACE,iBAAO;AACLV,YAAAA,EAAE,YAAKH,MAAL,cAAeC,IAAI,CAACE,EAApB,CADG;AAELC,YAAAA,IAAI,EAAEtC,QAAQ,CAACsB,QAFV;AAGLJ,YAAAA,SAAS,EAAEiB,IAAI,CAACjB,SAHX;AAILqB,YAAAA,IAAI,EAAEJ,IAAI,CAACa,QAAL,IAAiB,SAJlB;AAKLN,YAAAA,cAAc,EAAEP,IAAI,CAACO,cAAL,IAAuB,KALlC;AAMLI,YAAAA,gBAAgB,EAAEX,IAAI,CAACY;AANlB,WAAP;AAtBJ;AA+BD,KAxIuC;;AAAA,UA0IhCE,cA1IgC,GA0If,UACvBC,KADuB,EAEvBC,KAFuB,EAGvBC,MAHuB,EAIpB;AACH,UAAMC,OAAsB,GAAG,EAA/B;AAEAH,MAAAA,KAAK,CAACI,OAAN,CAAc,UAAAC,IAAI,EAAI;AACpB,YAAMC,UAAU,GAAGL,KAAK,CAAC,QAAQI,IAAI,CAACE,IAAL,CAAUC,MAAnB,CAAxB;AACA,YAAMC,UAAU,GAAGR,KAAK,CAAC,QAAQI,IAAI,CAACE,IAAL,CAAUG,MAAnB,CAAxB;;AACA,YAAIR,MAAM,CAACf,EAAP,KAAckB,IAAI,CAACE,IAAL,CAAUC,MAA5B,EAAoC;AAClC,cAAMG,WAAwB,GAAG;AAC/BC,YAAAA,SAAS,EAAE,UADoB;AAE/B3B,YAAAA,IAAI,EAAE,MAAKF,gBAAL,CAAsB,KAAtB,EAA6B0B,UAA7B,CAFyB;AAG/BN,YAAAA,OAAO,EAAEE,IAAI,CAACE,IAAL,CAAUJ;AAHY,WAAjC;AAKAA,UAAAA,OAAO,CAACU,IAAR,CAAaF,WAAb;AACD,SAPD,MAOO,IAAIT,MAAM,CAACf,EAAP,KAAckB,IAAI,CAACE,IAAL,CAAUG,MAA5B,EAAoC;AACzC,cAAMC,YAAwB,GAAG;AAC/BC,YAAAA,SAAS,EAAE,SADoB;AAE/B3B,YAAAA,IAAI,EAAE,MAAKF,gBAAL,CAAsB,IAAtB,EAA4BuB,UAA5B,CAFyB;AAG/BH,YAAAA,OAAO,EAAEE,IAAI,CAACE,IAAL,CAAUJ;AAHY,WAAjC;AAKAA,UAAAA,OAAO,CAACU,IAAR,CAAaF,YAAb;AACD;AACF,OAlBD;AAoBA,aAAO;AAAER,QAAAA,OAAO,EAAEA;AAAX,OAAP;AACD,KAtKuC;;AAAA,UAwKhCzB,kBAxKgC,GAwKX,UAACyB,OAAD,EAAqC;AAChE,UACE,CAACA,OAAD,IACA,CAACA,OAAO,CAACW,QAAR,CAAiBb,KADlB,IAEA,CAACE,OAAO,CAACW,QAAR,CAAiBd,KAFlB,IAGAG,OAAO,CAACW,QAAR,CAAiBb,KAAjB,CAAuBc,MAAvB,KAAkC,CAHlC,IAIAZ,OAAO,CAACW,QAAR,CAAiBd,KAAjB,CAAuBe,MAAvB,KAAkC,CALpC,EAME;AACA,cAAKC,QAAL,CAAc;AAAEb,UAAAA,OAAO,EAAE;AAAX,SAAd;;AACA;AACD,OAV+D,CAYhE;;;AACA,UAAMF,KAAuC,GAAG,EAAhD;AACA,UAAIC,MAAqB,GAAG;AAAEf,QAAAA,EAAE,EAAE,EAAN;AAAUD,QAAAA,QAAQ,EAAEpC,QAAQ,CAACmE,OAA7B;AAAsCC,QAAAA,OAAO,EAAE,EAA/C;AAAmDlD,QAAAA,SAAS,EAAE;AAA9D,OAA5B;AAEAmC,MAAAA,OAAO,CAACW,QAAR,CAAiBb,KAAjB,CAAuBG,OAAvB,CAA+B,UAAAe,OAAO,EAAI;AACxC;AACA;AACA,YAAI,CAACA,OAAO,CAACZ,IAAR,CAAaa,KAAlB,EAAyB;AACvBnB,UAAAA,KAAK,CAAC,QAAQkB,OAAO,CAACZ,IAAR,CAAapB,EAAtB,CAAL,GAAiCgC,OAAO,CAACZ,IAAzC;;AACA,cAAIY,OAAO,CAACZ,IAAR,CAAavC,SAAjB,EAA4B;AAC1B,gBAAMqD,YAAY,GAChB,MAAK7D,KAAL,CAAWG,QAAX,KAAwBX,kBAAkB,CAACoB,QAA3C,IACA+C,OAAO,CAACZ,IAAR,CAAarB,QAAb,KAA0BpC,QAAQ,CAACsB,QADnC,IAEA,MAAKZ,KAAL,CAAWS,QAAX,KAAwBkD,OAAO,CAACZ,IAAR,CAAaT,QAHvC;AAIA,gBAAMwB,OAAO,GACX,MAAK9D,KAAL,CAAWG,QAAX,KAAwBX,kBAAkB,CAACuB,GAA3C,IACA4C,OAAO,CAACZ,IAAR,CAAarB,QAAb,KAA0BpC,QAAQ,CAACyB,GADnC,IAEA,MAAKf,KAAL,CAAWS,QAAX,KAAwBkD,OAAO,CAACZ,IAAR,CAAajB,GAHvC;AAIA,gBAAMiC,WAAW,GACf,MAAK/D,KAAL,CAAWG,QAAX,KAAwBX,kBAAkB,CAACY,OAA3C,IACAuD,OAAO,CAACZ,IAAR,CAAarB,QAAb,KAA0BpC,QAAQ,CAACc,OADnC,IAEA,MAAKJ,KAAL,CAAWS,QAAX,KAAwBkD,OAAO,CAACZ,IAAR,CAAad,OAHvC;;AAKA,gBAAI4B,YAAY,IAAIC,OAAhB,IAA2BC,WAA/B,EAA4C;AAC1CrB,cAAAA,MAAM,GAAGiB,OAAO,CAACZ,IAAjB;AACD;AACF;AACF;AACF,OAxBD;;AA0BA,UAAIL,MAAM,CAACf,EAAP,KAAc,EAAlB,EAAsB;AACpB;AACA,cAAK6B,QAAL,CAAc;AAAEb,UAAAA,OAAO,EAAE;AAAX,SAAd;;AACA;AACD,OA9C+D,CAgDhE;;;AACA,YAAKa,QAAL,CAAc,MAAKjB,cAAL,CAAoBI,OAAO,CAACW,QAAR,CAAiBd,KAArC,EAA6CC,KAA7C,EAAoDC,MAApD,CAAd;AACD,KA1NuC;;AAEtC,UAAKsB,KAAL,GAAa;AACXrB,MAAAA,OAAO,EAAE;AADE,KAAb;AAFsC;AAKvC;;;;WAED,6BAAoB;AAClB,WAAK1C,eAAL,CAAqBgE,EAArB,CAAwB,cAAxB,EAAwC,KAAKhD,mBAA7C;AACA,WAAKhB,eAAL,CAAqBgE,EAArB,CAAwB,YAAxB,EAAsC,KAAK7C,iBAA3C;AACA,WAAKlB,eAAL;AACD;;;WAED,gCAAuB;AACrB,WAAKD,eAAL,CAAqBiE,cAArB,CAAoC,cAApC,EAAoD,KAAKjD,mBAAzD;AACA,WAAKhB,eAAL,CAAqBiE,cAArB,CAAoC,YAApC,EAAkD,KAAK9C,iBAAvD;AACD;;;WAED,4BAAmB+C,SAAnB,EAAmD;AACjD,UAAMC,eAAe,GAAGD,SAAS,CAAC5D,QAAV,KAAuB,KAAKP,KAAL,CAAWO,QAA1D;AACA,UAAM8D,eAAe,GAAGF,SAAS,CAAC1D,QAAV,KAAuB,KAAKT,KAAL,CAAWS,QAA1D;AACA,UAAM6D,eAAe,GAAGH,SAAS,CAAChE,QAAV,KAAuB,KAAKH,KAAL,CAAWG,QAA1D;AACA,UAAMoE,gBAAgB,GAAGJ,SAAS,CAAC3D,SAAV,KAAwB,KAAKR,KAAL,CAAWQ,SAA5D;AACA,UAAMgE,cAAc,GAAGL,SAAS,CAACM,aAAV,KAA4B,KAAKzE,KAAL,CAAWyE,aAA9D;;AAEA,UAAIL,eAAe,IAAIC,eAAnB,IAAsCC,eAAtC,IAAyDC,gBAAzD,IAA6EC,cAAjF,EAAiG;AAC/F,aAAKtE,eAAL;AACD;AACF;;;WAED,kBAAS;AACP,0BACE,uDACE,oBAAC,qBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACE,oBAAC,IAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACE,oBAAC,QAAD;AAAU,QAAA,IAAI,EAAE,EAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACE,oBAAC,IAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACE,oBAAC,QAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACE,oBAAC,oBAAD;AACE,QAAA,gBAAgB,EAAEP,YAAY,CAAC+E,gBAAb,CAA8B9E,kBAAkB,CAAC+E,UAAjD,CADpB;AAEE,QAAA,eAAe,EAAEhF,YAAY,CAACiF,sBAAb,EAFnB;AAGE,QAAA,YAAY,EAAE,KAAKZ,KAAL,CAAWrB,OAH3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QADF,CADF,CADF,CADF,CADF,CADF,CADF;AAmBD;;;;EArD0B3D,KAAK,CAAC6F,S;;AAgOnC,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAACd,KAAD,EAA0B;AAChD,SAAO;AACLzD,IAAAA,QAAQ,EAAET,gBAAgB,CAACkE,KAAD,CADrB;AAELS,IAAAA,aAAa,EAAET,KAAK,CAACe,WAAN,CAAkBN;AAF5B,GAAP;AAID,CALD;;AAOA,IAAMO,uBAAuB,GAAGnF,OAAO,CAACiF,eAAD,CAAP,CAAyB/E,cAAzB,CAAhC;AACA,eAAeiF,uBAAf","sourcesContent":["import * as React from 'react';\nimport { Card, CardBody, Grid, GridItem } from '@patternfly/react-core';\nimport * as AlertUtils from '../../utils/AlertUtils';\nimport {\n  GraphDefinition,\n  GraphEdgeWrapper,\n  GraphNodeData,\n  NodeType,\n  DestService,\n  ProtocolTraffic,\n  SEInfo\n} from '../../types/Graph';\nimport { RenderComponentScroll } from '../Nav/Page';\nimport { MetricsObjectTypes } from '../../types/Metrics';\nimport GraphDataSource from 'services/GraphDataSource';\nimport { DurationInSeconds, TimeInMilliseconds } from 'types/Common';\nimport TrafficListComponent from 'components/TrafficList/TrafficListComponent';\nimport * as FilterHelper from '../FilterList/FilterHelper';\nimport * as TrafficListFilters from './FiltersAndSorts';\nimport { KialiAppState } from '../../store/Store';\nimport { connect } from 'react-redux';\nimport { durationSelector } from '../../store/Selectors';\nimport { HealthAnnotationType } from '../../types/HealthAnnotation';\n\nexport interface AppNode {\n  id: string;\n  type: NodeType.APP;\n  namespace: string;\n  name: string;\n  version: string;\n  isInaccessible: boolean;\n}\n\nexport interface WorkloadNode {\n  id: string;\n  type: NodeType.WORKLOAD;\n  namespace: string;\n  name: string;\n  isInaccessible: boolean;\n  healthAnnotation?: HealthAnnotationType;\n}\n\nexport interface ServiceNode {\n  id: string;\n  type: NodeType.SERVICE;\n  namespace: string;\n  name: string;\n  isInaccessible: boolean;\n  isServiceEntry?: SEInfo;\n  destServices?: DestService[];\n  healthAnnotation?: HealthAnnotationType;\n}\n\nexport type TrafficNode = AppNode | ServiceNode | WorkloadNode;\n\nexport type TrafficDirection = 'inbound' | 'outbound';\n\nexport interface TrafficItem {\n  direction: TrafficDirection;\n  node: TrafficNode;\n  proxy?: TrafficItem;\n  traffic: ProtocolTraffic;\n}\n\ntype TrafficDetailsProps = {\n  duration: DurationInSeconds;\n  itemName: string;\n  itemType: MetricsObjectTypes;\n  namespace: string;\n  lastRefreshAt: TimeInMilliseconds;\n};\n\ntype TrafficDetailsState = {\n  traffic: TrafficItem[];\n};\n\nclass TrafficDetails extends React.Component<TrafficDetailsProps, TrafficDetailsState> {\n  private graphDataSource = new GraphDataSource();\n\n  constructor(props: TrafficDetailsProps) {\n    super(props);\n    this.state = {\n      traffic: []\n    };\n  }\n\n  componentDidMount() {\n    this.graphDataSource.on('fetchSuccess', this.graphDsFetchSuccess);\n    this.graphDataSource.on('fetchError', this.graphDsFetchError);\n    this.fetchDataSource();\n  }\n\n  componentWillUnmount() {\n    this.graphDataSource.removeListener('fetchSuccess', this.graphDsFetchSuccess);\n    this.graphDataSource.removeListener('fetchError', this.graphDsFetchError);\n  }\n\n  componentDidUpdate(prevProps: TrafficDetailsProps) {\n    const durationChanged = prevProps.duration !== this.props.duration;\n    const itemNameChanged = prevProps.itemName !== this.props.itemName;\n    const itemTypeChanged = prevProps.itemType !== this.props.itemType;\n    const namespaceChanged = prevProps.namespace !== this.props.namespace;\n    const refreshChanged = prevProps.lastRefreshAt !== this.props.lastRefreshAt;\n\n    if (durationChanged || itemNameChanged || itemTypeChanged || namespaceChanged || refreshChanged) {\n      this.fetchDataSource();\n    }\n  }\n\n  render() {\n    return (\n      <>\n        <RenderComponentScroll>\n          <Grid>\n            <GridItem span={12}>\n              <Card>\n                <CardBody>\n                  <TrafficListComponent\n                    currentSortField={FilterHelper.currentSortField(TrafficListFilters.sortFields)}\n                    isSortAscending={FilterHelper.isCurrentSortAscending()}\n                    trafficItems={this.state.traffic}\n                  />\n                </CardBody>\n              </Card>\n            </GridItem>\n          </Grid>\n        </RenderComponentScroll>\n      </>\n    );\n  }\n\n  private fetchDataSource = () => {\n    switch (this.props.itemType) {\n      case MetricsObjectTypes.SERVICE: {\n        const params = this.graphDataSource.fetchForServiceParams(\n          this.props.duration,\n          this.props.namespace,\n          this.props.itemName\n        );\n        params.includeHealth = false;\n        this.graphDataSource.fetchGraphData(params);\n        break;\n      }\n      case MetricsObjectTypes.WORKLOAD: {\n        const params = this.graphDataSource.fetchForWorkloadParams(\n          this.props.duration,\n          this.props.namespace,\n          this.props.itemName\n        );\n        params.includeHealth = false;\n        params.injectServiceNodes = false;\n        this.graphDataSource.fetchGraphData(params);\n        break;\n      }\n      case MetricsObjectTypes.APP: {\n        const params = this.graphDataSource.fetchForAppParams(\n          this.props.duration,\n          this.props.namespace,\n          this.props.itemName\n        );\n        params.includeHealth = false;\n        params.injectServiceNodes = false;\n        this.graphDataSource.fetchGraphData(params);\n        break;\n      }\n    }\n  };\n\n  private graphDsFetchSuccess = () => {\n    this.processTrafficData(this.graphDataSource.graphDefinition);\n  };\n\n  private graphDsFetchError = (errorMessage: string | null) => {\n    if (errorMessage !== '') {\n      errorMessage = 'Could not fetch traffic data: ' + errorMessage;\n    } else {\n      errorMessage = 'Could not fetch traffic data.';\n    }\n\n    AlertUtils.addError(errorMessage);\n  };\n\n  private buildTrafficNode = (prefix: 'in' | 'out', node: GraphNodeData): TrafficNode => {\n    // given restrictions on fetch options the node type should be either App, Workload or [outbound] service\n    switch (node.nodeType) {\n      case NodeType.APP:\n        return {\n          id: `${prefix}-${node.id}`,\n          type: node.nodeType,\n          namespace: node.namespace,\n          name: node.app || 'unknown',\n          version: node.version || '',\n          isInaccessible: node.isInaccessible || false\n        };\n      case NodeType.SERVICE:\n        return {\n          id: `${prefix}-${node.id}`,\n          type: node.nodeType,\n          namespace: node.namespace,\n          name: node.service || 'unknown',\n          isServiceEntry: node.isServiceEntry,\n          isInaccessible: node.isInaccessible || false,\n          destServices: node.destServices,\n          healthAnnotation: node.hasHealthConfig\n        };\n      default:\n        return {\n          id: `${prefix}-${node.id}`,\n          type: NodeType.WORKLOAD,\n          namespace: node.namespace,\n          name: node.workload || 'unknown',\n          isInaccessible: node.isInaccessible || false,\n          healthAnnotation: node.hasHealthConfig\n        };\n    }\n  };\n\n  private processTraffic = (\n    edges: GraphEdgeWrapper[],\n    nodes: { [key: string]: GraphNodeData },\n    myNode: GraphNodeData\n  ) => {\n    const traffic: TrafficItem[] = [];\n\n    edges.forEach(edge => {\n      const sourceNode = nodes['id-' + edge.data.source];\n      const targetNode = nodes['id-' + edge.data.target];\n      if (myNode.id === edge.data.source) {\n        const trafficItem: TrafficItem = {\n          direction: 'outbound',\n          node: this.buildTrafficNode('out', targetNode),\n          traffic: edge.data.traffic!\n        };\n        traffic.push(trafficItem);\n      } else if (myNode.id === edge.data.target) {\n        const trafficItem: TrafficItem = {\n          direction: 'inbound',\n          node: this.buildTrafficNode('in', sourceNode),\n          traffic: edge.data.traffic!\n        };\n        traffic.push(trafficItem);\n      }\n    });\n\n    return { traffic: traffic };\n  };\n\n  private processTrafficData = (traffic: GraphDefinition | null) => {\n    if (\n      !traffic ||\n      !traffic.elements.nodes ||\n      !traffic.elements.edges ||\n      traffic.elements.nodes.length === 0 ||\n      traffic.elements.edges.length === 0\n    ) {\n      this.setState({ traffic: [] });\n      return;\n    }\n\n    // Index nodes by id and find the node of the queried item\n    const nodes: { [key: string]: GraphNodeData } = {};\n    let myNode: GraphNodeData = { id: '', nodeType: NodeType.UNKNOWN, cluster: '', namespace: '' };\n\n    traffic.elements.nodes.forEach(element => {\n      // Ignore box nodes. They are not relevant for the traffic list because we\n      // are interested in the actual apps.\n      if (!element.data.isBox) {\n        nodes['id-' + element.data.id] = element.data;\n        if (element.data.namespace) {\n          const isMyWorkload =\n            this.props.itemType === MetricsObjectTypes.WORKLOAD &&\n            element.data.nodeType === NodeType.WORKLOAD &&\n            this.props.itemName === element.data.workload;\n          const isMyApp =\n            this.props.itemType === MetricsObjectTypes.APP &&\n            element.data.nodeType === NodeType.APP &&\n            this.props.itemName === element.data.app;\n          const isMyService =\n            this.props.itemType === MetricsObjectTypes.SERVICE &&\n            element.data.nodeType === NodeType.SERVICE &&\n            this.props.itemName === element.data.service;\n\n          if (isMyWorkload || isMyApp || isMyService) {\n            myNode = element.data;\n          }\n        }\n      }\n    });\n\n    if (myNode.id === '') {\n      // Graph endpoint didn't return a graph for the current node.\n      this.setState({ traffic: [] });\n      return;\n    }\n\n    // Process the direct inbound/outbound traffic to/from the item of interest.\n    this.setState(this.processTraffic(traffic.elements.edges!, nodes, myNode));\n  };\n}\n\nconst mapStateToProps = (state: KialiAppState) => {\n  return {\n    duration: durationSelector(state),\n    lastRefreshAt: state.globalState.lastRefreshAt\n  };\n};\n\nconst TrafficDetailsContainer = connect(mapStateToProps)(TrafficDetails);\nexport default TrafficDetailsContainer;\n"]},"metadata":{},"sourceType":"module"}