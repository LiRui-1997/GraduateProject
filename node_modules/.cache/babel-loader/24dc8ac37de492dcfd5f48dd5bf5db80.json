{"ast":null,"code":"import _toConsumableArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar _jsxFileName = \"/root/kiali-ui/src/components/CytoscapeGraph/CytoscapeGraph.tsx\";\nimport * as React from 'react';\nimport ReactResizeDetector from 'react-resize-detector';\nimport { BoxByType, CLUSTER_DEFAULT, CytoscapeGlobalScratchNamespace, NodeType, UNKNOWN } from '../../types/Graph';\nimport { addInfo } from 'utils/AlertUtils';\nimport { angleBetweenVectors, squaredDistance, normalize } from '../../utils/MathUtils';\nimport { CytoscapeContextMenuWrapper } from './CytoscapeContextMenu';\nimport * as CytoscapeGraphUtils from './CytoscapeGraphUtils';\nimport { CyNode, isCore, isEdge, isNode } from './CytoscapeGraphUtils';\nimport { CytoscapeReactWrapper } from './CytoscapeReactWrapper';\nimport { showTrace, hideTrace } from './CytoscapeTrace';\nimport EmptyGraphLayout from './EmptyGraphLayout';\nimport FocusAnimation from './FocusAnimation';\nimport { GraphHighlighter } from './graphs/GraphHighlighter';\nimport TrafficRenderer from './TrafficAnimation/TrafficRenderer';\nimport { serverConfig } from 'config';\nimport { decoratedNodeData } from './CytoscapeGraphUtils';\n\n// exporting this class for testing\nvar CytoscapeGraph = /*#__PURE__*/function (_React$Component) {\n  _inherits(CytoscapeGraph, _React$Component);\n\n  var _super = _createSuper(CytoscapeGraph);\n\n  // for dbl-click support\n  function CytoscapeGraph(props) {\n    var _this;\n\n    _classCallCheck(this, CytoscapeGraph);\n\n    _this = _super.call(this, props);\n    _this.contextMenuRef = void 0;\n    _this.cy = void 0;\n    _this.customViewport = void 0;\n    _this.cytoscapeReactWrapperRef = void 0;\n    _this.focusSelector = void 0;\n    _this.graphHighlighter = void 0;\n    _this.namespaceChanged = void 0;\n    _this.needsInitialLayout = void 0;\n    _this.nodeChanged = void 0;\n    _this.resetSelection = false;\n    _this.trafficRenderer = void 0;\n    _this.userBoxSelected = void 0;\n\n    _this.onResize = function () {\n      if (_this.cy) {\n        _this.cy.resize(); // always fit to the newly sized space\n\n\n        _this.safeFit(_this.cy, true);\n      }\n    };\n\n    _this.selectTarget = function (target) {\n      var isTapped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (_this.props.isMiniGraph && isTapped) {\n        return;\n      }\n\n      if (_this.cy) {\n        _this.cy.$(':selected').selectify().unselect().unselectify();\n\n        if (target && !isCore(target)) {\n          target.selectify().select().unselectify();\n        }\n      }\n    };\n\n    _this.selectTargetAndUpdateSummary = function (target) {\n      _this.selectTarget(target);\n\n      var event = {\n        summaryType: target.data(CyNode.isBox) ? 'box' : 'node',\n        summaryTarget: target\n      };\n\n      if (_this.props.updateSummary) {\n        _this.props.updateSummary(event);\n      }\n\n      _this.graphHighlighter.onClick(event);\n    };\n\n    _this.handleDoubleTap = function (event) {\n      if (_this.props.onNodeDoubleTap && CytoscapeGraph.isCyNodeClickEvent(event)) {\n        _this.props.onNodeDoubleTap(CytoscapeGraph.buildTapEventArgs(event));\n      }\n    };\n\n    _this.handleTap = function (event) {\n      if (_this.props.updateSummary) {\n        _this.props.updateSummary(event);\n      }\n\n      if (_this.props.onNodeTap && CytoscapeGraph.isCyNodeClickEvent(event)) {\n        _this.props.onNodeTap(CytoscapeGraph.buildTapEventArgs(event));\n      }\n\n      if (!_this.props.isMiniGraph) {\n        _this.graphHighlighter.onClick(event);\n      } else if (_this.props.onEdgeTap && CytoscapeGraph.isCyEdgeClickEvent(event)) {\n        _this.props.onEdgeTap(CytoscapeGraph.buildTapEventArgs(event));\n      }\n    };\n\n    _this.handleMouseIn = function (event) {\n      _this.graphHighlighter.onMouseIn(event);\n    };\n\n    _this.handleMouseOut = function (event) {\n      _this.graphHighlighter.onMouseOut(event);\n    };\n\n    _this.contextMenuRef = React.createRef();\n    _this.customViewport = false;\n    _this.cytoscapeReactWrapperRef = React.createRef();\n    _this.focusSelector = props.focusSelector;\n    _this.namespaceChanged = false;\n    _this.needsInitialLayout = false;\n    _this.nodeChanged = false;\n    return _this;\n  }\n\n  _createClass(CytoscapeGraph, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.cyInitialization(this.getCy());\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      this.nodeChanged = this.nodeChanged || this.props.graphData.fetchParams.node !== nextProps.graphData.fetchParams.node; // only update on display changes for the existing graph. Duration or refreshInterval changes don't\n      // affect display. Options that trigger a graph refresh will have an update when the refresh\n      // completes (showIdleNodes, showSecurity, showServiceNodes, etc).\n\n      var result = this.props.edgeLabels !== nextProps.edgeLabels || this.props.graphData.isLoading !== nextProps.graphData.isLoading || this.props.graphData.elements !== nextProps.graphData.elements || this.props.layout !== nextProps.layout || this.props.compressOnHide !== nextProps.compressOnHide || this.props.showMissingSidecars !== nextProps.showMissingSidecars || this.props.showTrafficAnimation !== nextProps.showTrafficAnimation || this.props.showVirtualServices !== nextProps.showVirtualServices || this.props.trace !== nextProps.trace;\n      return result;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this2 = this;\n\n      if (this.props.graphData.isLoading) {\n        return;\n      }\n\n      var cy = this.getCy();\n\n      if (!cy) {\n        return;\n      }\n\n      var updateLayout = false;\n\n      if (this.needsInitialLayout || this.nodeNeedsRelayout() || this.namespaceNeedsRelayout(prevProps.graphData.elements, this.props.graphData.elements) || this.elementsNeedRelayout(prevProps.graphData.elements, this.props.graphData.elements) || this.props.layout.name !== prevProps.layout.name) {\n        updateLayout = true;\n        this.needsInitialLayout = false;\n      }\n\n      this.processGraphUpdate(cy, updateLayout).then(function (_response) {\n        // pre-select node if provided\n        var node = _this2.props.graphData.fetchParams.node;\n\n        if (node && cy && cy.$(':selected').length === 0) {\n          var selector = \"[namespace = \\\"\".concat(node.namespace.name, \"\\\"][nodeType = \\\"\").concat(node.nodeType, \"\\\"]\");\n\n          switch (node.nodeType) {\n            case NodeType.AGGREGATE:\n              selector = selector + \"[aggregate = '\" + node.aggregate + \"'][aggregateValue = '\" + node.aggregateValue + \"']\";\n              break;\n\n            case NodeType.APP:\n            case NodeType.BOX:\n              // we only support app box node graphs, treat like an app node\n              selector = selector + \"[app = '\" + node.app + \"']\";\n\n              if (node.version && node.version !== UNKNOWN) {\n                selector = selector + \"[version = '\" + node.version + \"']\";\n              }\n\n              break;\n\n            case NodeType.SERVICE:\n              selector = selector + \"[service = '\" + node.service + \"']\";\n              break;\n\n            default:\n              selector = selector + \"[workload = '\" + node.workload + \"']\";\n          }\n\n          var eles = cy.nodes(selector);\n\n          if (eles.length > 0) {\n            var target = eles[0]; // default app to the whole app box, when appropriate\n\n            if ((node.nodeType === NodeType.APP || node.nodeType === NodeType.BOX) && !node.version && target.isChild() && target.parent()[0].data(CyNode.isBox) === BoxByType.APP) {\n              target = target.parent()[0];\n            }\n\n            _this2.selectTargetAndUpdateSummary(target);\n          }\n        }\n\n        if (_this2.props.trace) {\n          showTrace(cy, _this2.props.graphData.fetchParams.graphType, _this2.props.trace);\n        } else if (!_this2.props.trace && prevProps.trace) {\n          hideTrace(cy);\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      return /*#__PURE__*/React.createElement(\"div\", {\n        id: \"cytoscape-container\",\n        className: this.props.containerClassName,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 237,\n          columnNumber: 7\n        }\n      }, /*#__PURE__*/React.createElement(ReactResizeDetector, {\n        handleWidth: true,\n        handleHeight: true,\n        skipOnMount: false,\n        onResize: this.onResize,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 238,\n          columnNumber: 9\n        }\n      }), /*#__PURE__*/React.createElement(EmptyGraphLayout, {\n        action: this.props.onEmptyGraphAction,\n        elements: this.props.graphData.elements,\n        error: this.props.graphData.errorMessage,\n        isLoading: this.props.graphData.isLoading,\n        isError: !!this.props.graphData.isError,\n        isMiniGraph: this.props.isMiniGraph,\n        namespaces: this.props.graphData.fetchParams.namespaces,\n        showIdleNodes: this.props.showIdleNodes,\n        toggleIdleNodes: this.props.toggleIdleNodes,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 239,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(CytoscapeContextMenuWrapper, {\n        ref: this.contextMenuRef,\n        edgeContextMenuContent: this.props.contextMenuEdgeComponent,\n        nodeContextMenuContent: this.props.contextMenuNodeComponent,\n        groupContextMenuContent: this.props.contextMenuGroupComponent,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 250,\n          columnNumber: 11\n        }\n      }), /*#__PURE__*/React.createElement(CytoscapeReactWrapper, {\n        ref: function ref(e) {\n          return _this3.setCytoscapeReactWrapperRef(e);\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 256,\n          columnNumber: 11\n        }\n      })));\n    }\n  }, {\n    key: \"getCy\",\n    value: function getCy() {\n      return this.cytoscapeReactWrapperRef.current ? this.cytoscapeReactWrapperRef.current.getCy() : null;\n    }\n  }, {\n    key: \"setCytoscapeReactWrapperRef\",\n    value: function setCytoscapeReactWrapperRef(cyRef) {\n      this.cytoscapeReactWrapperRef.current = cyRef;\n      this.cyInitialization(this.getCy());\n    }\n  }, {\n    key: \"cyInitialization\",\n    value: function cyInitialization(cy) {\n      var _this4 = this;\n\n      if (!cy) {\n        return;\n      } // Caches the cy instance that is currently in use.\n      // If that cy instance is the same one we are being asked to initialize, do NOT initialize it again;\n      // this would add duplicate callbacks and would screw up the graph highlighter. If, however,\n      // we are being asked to initialize a different cy instance, we assume the current one is now obsolete\n      // so we do want to initialize the new cy instance.\n\n\n      if (this.cy === cy) {\n        return;\n      }\n\n      this.cy = cy;\n      this.cy.boxSelectionEnabled(true);\n      this.contextMenuRef.current.connectCy(this.cy);\n      this.graphHighlighter = new GraphHighlighter(cy);\n      this.trafficRenderer = new TrafficRenderer(cy);\n\n      var getCytoscapeBaseEvent = function getCytoscapeBaseEvent(event) {\n        var target = event.target;\n\n        if (target === cy) {\n          return {\n            summaryType: 'graph',\n            summaryTarget: cy\n          };\n        } else if (isNode(target)) {\n          if (target.data(CyNode.isBox)) {\n            return {\n              summaryType: 'box',\n              summaryTarget: target\n            };\n          } else {\n            return {\n              summaryType: 'node',\n              summaryTarget: target\n            };\n          }\n        } else if (isEdge(target)) {\n          return {\n            summaryType: 'edge',\n            summaryTarget: target\n          };\n        } else {\n          return null;\n        }\n      };\n\n      var findRelatedNode = function findRelatedNode(element) {\n        // Skip top-level node, this one has margins that we don't want to consider.\n        if (element.getAttribute(CytoscapeGraph.DataNodeId)) {\n          return null;\n        }\n\n        while (element && element.getAttribute) {\n          var dataNodeId = element.getAttribute(CytoscapeGraph.DataNodeId);\n\n          if (dataNodeId) {\n            return dataNodeId;\n          }\n\n          element = element.parentNode;\n        }\n\n        return null;\n      };\n\n      cy.on('tap', function (event) {\n        // Check if we clicked a label, if so stop processing the event right away.\n        if (event.originalEvent) {\n          var element = document.elementFromPoint(event.originalEvent.clientX, event.originalEvent.clientY);\n          var realTargetId = findRelatedNode(element);\n\n          if (realTargetId) {\n            var realTarget = cy.$id(realTargetId);\n\n            if (realTarget) {\n              event.preventDefault();\n              realTarget.trigger('tap');\n              return;\n            }\n          }\n        }\n\n        var tapped = event.target;\n\n        if (CytoscapeGraph.tapTimeout) {\n          // cancel any single-tap timer in progress\n          clearTimeout(CytoscapeGraph.tapTimeout);\n          CytoscapeGraph.tapTimeout = null;\n\n          if (tapped === CytoscapeGraph.tapTarget) {\n            // if we click the same target again, perform double-tap\n            tapped = null;\n            CytoscapeGraph.tapTarget = null;\n            var cytoscapeEvent = getCytoscapeBaseEvent(event);\n\n            if (cytoscapeEvent) {\n              _this4.handleDoubleTap(cytoscapeEvent);\n            }\n          }\n        }\n\n        if (tapped) {\n          // start single-tap timer\n          CytoscapeGraph.tapTarget = tapped;\n          CytoscapeGraph.tapTimeout = setTimeout(function () {\n            // timer expired without a follow-up click, so perform single-tap\n            CytoscapeGraph.tapTarget = null;\n            var cytoscapeEvent = getCytoscapeBaseEvent(event);\n\n            if (cytoscapeEvent) {\n              _this4.handleTap(cytoscapeEvent);\n\n              _this4.selectTarget(event.target, true);\n            }\n          }, CytoscapeGraph.doubleTapMs);\n        }\n      }); // Note that at the time of writing (on my chrome) the order of box events:\n      // 1) boxstart\n      // 2) boxend\n      // 3) box, a separate event for each boxselected element\n      // The boxselect event never seems to fire. boxend does not seem to supply the boxselected collection (why?).\n      // So, boxend seems not useful. I don't see a way to do this other than to 'fit' each time we add an elem.\n\n      cy.on('boxstart', function (evt) {\n        var cytoscapeEvent = getCytoscapeBaseEvent(evt);\n\n        if (cytoscapeEvent) {\n          _this4.userBoxSelected = cy.collection();\n        }\n      });\n      cy.on('box', function (evt) {\n        var cytoscapeEvent = getCytoscapeBaseEvent(evt);\n\n        if (cytoscapeEvent) {\n          var elements = evt.target;\n\n          if (elements) {\n            elements.forEach(function (e) {\n              if (e.data(CyNode.nodeType) !== NodeType.BOX) {\n                var _this4$userBoxSelecte;\n\n                _this4.userBoxSelected = (_this4$userBoxSelecte = _this4.userBoxSelected) === null || _this4$userBoxSelecte === void 0 ? void 0 : _this4$userBoxSelecte.add(elements);\n              }\n            });\n            CytoscapeGraphUtils.safeFit(cy, _this4.userBoxSelected);\n            _this4.customViewport = true;\n          }\n        }\n      });\n      cy.on('mouseover', 'node,edge', function (evt) {\n        var cytoscapeEvent = getCytoscapeBaseEvent(evt);\n\n        if (cytoscapeEvent) {\n          _this4.handleMouseIn(cytoscapeEvent);\n        }\n      });\n      cy.on('mouseout', 'node,edge', function (evt) {\n        var cytoscapeEvent = getCytoscapeBaseEvent(evt);\n\n        if (cytoscapeEvent) {\n          _this4.handleMouseOut(cytoscapeEvent);\n        }\n      });\n      cy.on('viewport', function (evt) {\n        var cytoscapeEvent = getCytoscapeBaseEvent(evt);\n\n        if (cytoscapeEvent) {\n          _this4.customViewport = true;\n        }\n      }); // 'fit' is a custom event that we emit allowing us to reset cytoscapeGraph.customViewport\n\n      cy.on('fit', function (evt) {\n        var cytoscapeEvent = getCytoscapeBaseEvent(evt);\n\n        if (cytoscapeEvent) {\n          _this4.customViewport = false;\n        }\n      });\n      cy.on('nodehtml-create-or-update', 'node', function (evt, data) {\n        var label = data.label,\n            isNew = data.isNew;\n        var target = evt.target; // This is the DOM node of the label, if we want the cyNode it is `target`\n\n        var node = label.getNode(); // Assign to the label node (the DOM element) an id that matches the cy node.\n        // This is so that when we click, we can identify if the clicked label belongs to\n        // any cy node and select it\n        // Note that we don't add an actual listener to this DOM node. We use the cy click event, this proved to be more\n        // stable than adding a listener. As we only want the contents to match and not the whole node (which is bigger).\n\n        if (isNew) {\n          node.setAttribute('data-node-id', target.id());\n        } // Skip parent nodes from bounding expansion calculation, their size is defined by their contents, so no point in\n        // messing with these values.\n\n\n        if (target.isParent()) {\n          return;\n        } // The code below expands the bounds of a node, taking into consideration the labels. This is important not only\n        // for displaying the label, but to avoid nodes overlapping with other labels.\n        // We assume that a label is placed centered in the bottom part of a node.\n        // The algorithm is:\n        // - Take the old bounds-expansion\n        // - Get the bounding-box of a node (without taking into account the overlays  i.e. the one that appears on click)\n        // - Compute the required extra width as the label width minus the bounding box width\n        //   - This will yield a a positive number if we need more space, or negative if we need less space.\n        // - Compute the required height as the height of the label. Since the label is at the bottom, we only need that.\n        //   If its center was aligned with the center of the node, we would do a similar operation as with the width.\n        // - Spread the required width as extra space in the left area and space in the right area of the cy node\n        //   (half in each side)\n        // - Required height is only needed at the bottom, so we now that we always have to grow at the bottom by this value.\n\n\n        var oldBE = target.numericStyle('bounds-expansion');\n\n        if (oldBE.length === 1) {\n          oldBE = Array(4).fill(oldBE[0]);\n        } // Do not include the \"click\" overlay on the bounding box calc\n\n\n        var bb = target.boundingBox({\n          includeOverlays: false\n        });\n\n        var newBE = _toConsumableArray(oldBE);\n\n        var requiredWidth = node.offsetWidth - bb.w;\n        var requiredHeight = node.offsetHeight;\n        newBE[1] += requiredWidth * 0.5;\n        newBE[3] += requiredWidth * 0.5;\n        newBE[2] = requiredHeight; // Ensure we don't end with negative values in our bounds-expansion\n\n        newBE = newBE.map(function (val) {\n          return Math.max(val, 0);\n        });\n\n        var compareBoundsExpansion = function compareBoundsExpansion(be1, be2) {\n          if (be1.length !== be2.length) {\n            return false;\n          }\n\n          var delta = 0.00001;\n\n          for (var i = 0; i < be1.length; ++i) {\n            if (Math.abs(be1[i] - be2[i]) > delta) {\n              return false;\n            }\n          }\n\n          return true;\n        }; // Only trigger an update if it really changed, else just skip to avoid this function to call again\n\n\n        if (!compareBoundsExpansion(oldBE, newBE)) {\n          target.style('bounds-expansion', newBE); // bounds-expansion changed. Make sure we tell our parent (if any) to update as well (so he can update the label position).\n\n          if (target.isChild()) {\n            // The timeout ensures that the previous value is already applied\n            setTimeout(function () {\n              if (!target.cy().destroyed()) {\n                target.cy(). // because we are using an extension\n                nodeHtmlLabel().updateNodeLabel(target.parent());\n              }\n            }, 0);\n          }\n        }\n      });\n      cy.on('layoutstop', function (_evt) {\n        // Don't allow a large zoom if the graph has a few nodes (nodes would look too big).\n        _this4.safeFit(cy);\n\n        _this4.fixLoopOverlap(cy);\n      });\n      cy.ready(function (evt) {\n        if (_this4.props.onReady) {\n          _this4.props.onReady(evt.cy);\n        }\n\n        _this4.needsInitialLayout = true;\n      });\n      cy.on('destroy', function (_evt) {\n        _this4.trafficRenderer.stop();\n\n        _this4.trafficRenderer = undefined;\n        _this4.cy = undefined;\n\n        if (_this4.props.updateSummary) {\n          _this4.props.updateSummary({\n            summaryType: 'graph',\n            summaryTarget: undefined\n          });\n        }\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus(cy) {\n      if (!this.focusSelector) {\n        return;\n      } // only perform the focus one time\n\n\n      var focusSelector = this.focusSelector;\n      this.focusSelector = undefined;\n      var selected = cy.$(focusSelector);\n\n      if (!selected) {\n        addInfo('Could not focus on requested node. The node may be idle or hidden.', true, undefined, \"\".concat(focusSelector));\n        return;\n      } // If there is only one, select it\n\n\n      if (selected.length === 1) {\n        this.selectTargetAndUpdateSummary(selected[0]);\n      } else {\n        // If we have many elements, try to check if a compound in this query contains everything, if so, select it.\n        var compound = selected.filter('$node > node');\n\n        if (compound && compound.length === 1 && selected.subtract(compound).same(compound.children())) {\n          this.selectTargetAndUpdateSummary(compound[0]);\n          selected = compound;\n        }\n      } // Start animation\n\n\n      new FocusAnimation(cy).start(selected);\n    }\n  }, {\n    key: \"safeFit\",\n    value: function safeFit(cy, force) {\n      if (!force && this.customViewport) {\n        return;\n      }\n\n      this.focus(cy);\n      CytoscapeGraphUtils.safeFit(cy);\n    }\n  }, {\n    key: \"processGraphUpdate\",\n    value: function processGraphUpdate(cy, updateLayout) {\n      var _serverConfig$cluster,\n          _this5 = this;\n\n      this.trafficRenderer.pause();\n      var isTheGraphSelected = cy.$(':selected').length === 0;\n\n      if (this.resetSelection) {\n        if (!isTheGraphSelected) {\n          this.selectTarget();\n          this.handleTap({\n            summaryType: 'graph',\n            summaryTarget: cy\n          });\n        }\n\n        this.resetSelection = false;\n      }\n\n      var globalScratchData = {\n        activeNamespaces: this.props.graphData.fetchParams.namespaces,\n        edgeLabels: this.props.edgeLabels,\n        homeCluster: (serverConfig === null || serverConfig === void 0 ? void 0 : (_serverConfig$cluster = serverConfig.clusterInfo) === null || _serverConfig$cluster === void 0 ? void 0 : _serverConfig$cluster.name) || CLUSTER_DEFAULT,\n        graphType: this.props.graphData.fetchParams.graphType,\n        trafficRates: this.props.graphData.fetchParams.trafficRates,\n        showMissingSidecars: this.props.showMissingSidecars,\n        showSecurity: this.props.showSecurity,\n        showVirtualServices: this.props.showVirtualServices\n      };\n      cy.scratch(CytoscapeGlobalScratchNamespace, globalScratchData);\n      cy.startBatch(); // KIALI-1291 issue was caused because some layouts (can't tell if all) do reuse the existing positions.\n      // We got some issues when changing from/to cola/cose, as the nodes started to get far away from each other.\n      // Previously we deleted the nodes prior to a layout update, this was too much and it seems that only reseting the\n      // positions to 0,0 makes the layout more predictable.\n\n      if (updateLayout) {\n        cy.nodes().positions({\n          x: 0,\n          y: 0\n        });\n      } // update the entire set of nodes and edges to keep the graph up-to-date\n\n\n      cy.json({\n        elements: this.props.graphData.elements\n      });\n      cy.endBatch(); // Run layout outside of the batch operation for it to take effect on the new nodes,\n      // Layouts can run async so wait until it completes to finish the graph update.\n\n      if (updateLayout) {\n        return new Promise(function (resolve, _reject) {\n          CytoscapeGraphUtils.runLayout(cy, _this5.props.layout).then(function (_response) {\n            _this5.finishGraphUpdate(cy, isTheGraphSelected);\n\n            resolve();\n          });\n        });\n      } else {\n        this.finishGraphUpdate(cy, isTheGraphSelected);\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: \"finishGraphUpdate\",\n    value: function finishGraphUpdate(cy, isTheGraphSelected) {\n      // We opt-in for manual selection to be able to control when to select a node/edge\n      // https://github.com/cytoscape/cytoscape.js/issues/1145#issuecomment-153083828\n      cy.nodes().unselectify();\n      cy.edges().unselectify(); // Verify our current selection is still valid, if not, select the graph\n\n      if (!isTheGraphSelected && cy.$(':selected').length === 0) {\n        this.handleTap({\n          summaryType: 'graph',\n          summaryTarget: cy\n        });\n      }\n\n      if (this.props.showTrafficAnimation) {\n        this.trafficRenderer.start(cy.edges());\n      } // notify that the graph has been updated\n\n\n      if (this.props.setUpdateTime) {\n        this.props.setUpdateTime(Date.now());\n      }\n    }\n  }, {\n    key: \"namespaceNeedsRelayout\",\n    value: function namespaceNeedsRelayout(prevElements, nextElements) {\n      var needsRelayout = this.namespaceChanged && prevElements !== nextElements;\n\n      if (needsRelayout) {\n        this.namespaceChanged = false;\n      }\n\n      return needsRelayout;\n    }\n  }, {\n    key: \"nodeNeedsRelayout\",\n    value: function nodeNeedsRelayout() {\n      var needsRelayout = this.nodeChanged;\n\n      if (needsRelayout) {\n        this.nodeChanged = false;\n      }\n\n      return needsRelayout;\n    }\n  }, {\n    key: \"elementsNeedRelayout\",\n    value: // To know if we should re-layout, we need to know if any element changed\n    // Do a quick round by comparing the number of nodes and edges, if different\n    // a change is expected.\n    // If we have the same number of elements, compare the ids, if we find one that isn't\n    // in the other, we can be sure that there are changes.\n    // Worst case is when they are the same, avoid that.\n    function elementsNeedRelayout(prevElements, nextElements) {\n      if (prevElements === nextElements) {\n        return false;\n      }\n\n      if (!prevElements || !nextElements || !prevElements.nodes || !prevElements.edges || !nextElements.nodes || !nextElements.edges || prevElements.nodes.length !== nextElements.nodes.length || prevElements.edges.length !== nextElements.edges.length) {\n        return true;\n      } // If both have the same ids, we don't need to relayout\n\n\n      return !(this.nodeOrEdgeArrayHasSameIds(nextElements.nodes, prevElements.nodes) && this.nodeOrEdgeArrayHasSameIds(nextElements.edges, prevElements.edges));\n    }\n  }, {\n    key: \"nodeOrEdgeArrayHasSameIds\",\n    value: function nodeOrEdgeArrayHasSameIds(a, b) {\n      var aIds = a.map(function (e) {\n        return e.id;\n      }).sort();\n      return b.map(function (e) {\n        return e.id;\n      }).sort().every(function (eId, index) {\n        return eId === aIds[index];\n      });\n    }\n  }, {\n    key: \"fixLoopOverlap\",\n    value: function fixLoopOverlap(cy) {\n      cy.$(':loop').forEach(function (loop) {\n        var node = loop.source();\n        var otherEdges = node.connectedEdges().subtract(loop);\n        var minDistance = 1; // Default values in rads (taken from cytoscape docs)\n\n        var DEFAULT_LOOP_SWEEP = -1.5707;\n        var DEFAULT_LOOP_DIRECTION = -0.7854;\n        loop.style('loop-direction', DEFAULT_LOOP_DIRECTION);\n        loop.style('loop-sweep', DEFAULT_LOOP_SWEEP);\n        var found = false; // Check if we have any other edge that overlaps with any of our loop edges\n        // this uses cytoscape forEach (https://js.cytoscape.org/#eles.forEach)\n\n        otherEdges.forEach(function (edge) {\n          var testPoint = edge.source().same(node) ? edge.sourceEndpoint() : edge.targetEndpoint();\n\n          if (squaredDistance(testPoint, loop.sourceEndpoint()) <= minDistance || squaredDistance(testPoint, loop.targetEndpoint()) <= minDistance) {\n            found = true;\n            return false; // break the inner cytoscape forEach\n          }\n\n          return; // return to avoid typescript error about \"not all code paths return a value\"\n        });\n\n        if (!found) {\n          return;\n        } // Simple case, one other edge, just move the loop-direction half the default loop-sweep value to avoid the edge\n\n\n        if (otherEdges.length === 1) {\n          var loopDirection = loop.numericStyle('loop-direction') - loop.numericStyle('loop-sweep') * 0.5;\n          loop.style('loop-direction', loopDirection);\n          return;\n        } // Compute every angle between the top (12 oâ€™clock position)\n        // We store the angles as radians and positive numbers, thus we add PI to the negative angles.\n\n\n        var usedAngles = [];\n        otherEdges.forEach(function (edge) {\n          var testPoint = edge.source().same(node) ? edge.sourceEndpoint() : edge.targetEndpoint();\n          var angle = angleBetweenVectors(normalize({\n            x: testPoint.x - node.position().x,\n            y: testPoint.y - node.position().y\n          }), {\n            x: 0,\n            y: 1\n          });\n          usedAngles.push(angle < 0 ? angle + 2 * Math.PI : angle);\n        });\n        usedAngles.sort(function (a, b) {\n          return a - b;\n        }); // Try to fit our loop in the longest arc\n        // Iterate over the found angles and find the longest distance\n\n        var maxArc = {\n          start: 0,\n          end: 0,\n          value: 0\n        };\n\n        for (var i = 0; i < usedAngles.length; ++i) {\n          var start = i === 0 ? usedAngles[usedAngles.length - 1] : usedAngles[i - 1];\n          var end = usedAngles[i];\n          var arc = Math.abs(start - end);\n\n          if (arc > maxArc.value) {\n            maxArc.value = arc;\n            maxArc.start = start;\n            maxArc.end = end;\n          }\n        } // If the max arc is 1.0 radians (the biggest gap is of about 50 deg), the node is already too busy, ignore it\n\n\n        if (maxArc.value < 1.0) {\n          return;\n        }\n\n        if (maxArc.start > maxArc.end) {\n          // To ensure the difference between end and start goes in the way we want, we add a full circle to our end\n          maxArc.end += Math.PI * 2;\n        }\n\n        if (maxArc.value <= -DEFAULT_LOOP_SWEEP) {\n          // Make it slightly smaller to be able to fit\n          // loop-sweep is related to the distance between the start and end of our loop edge\n          loop.style('loop-sweep', -maxArc.value * 0.9);\n          maxArc.start += maxArc.value * 0.05;\n          maxArc.end -= maxArc.value * 0.05;\n        } // Move the loop to the center of the arc, loop-direction is related to the middle point of the loop\n\n\n        loop.style('loop-direction', maxArc.start + (maxArc.end - maxArc.start) * 0.5);\n      });\n    }\n  }], [{\n    key: \"buildTapEventArgs\",\n    value: function buildTapEventArgs(event) {\n      var target = event.summaryTarget;\n      var targetType = event.summaryType;\n      var targetOrBoxChildren = targetType === 'box' ? target.descendants() : target;\n\n      if (targetType === 'edge') {\n        var nodeSource = decoratedNodeData(target.source());\n        var nodeTarget = decoratedNodeData(target.target());\n        return {\n          namespace: nodeSource.namespace,\n          type: nodeSource.nodeType,\n          source: nodeSource[nodeSource.nodeType],\n          target: nodeTarget[nodeTarget.nodeType]\n        };\n      } // Invoke callback\n\n\n      return {\n        aggregate: target.data(CyNode.aggregate),\n        aggregateValue: target.data(CyNode.aggregateValue),\n        app: target.data(CyNode.app),\n        hasMissingSC: targetOrBoxChildren.every(function (t) {\n          return t.data(CyNode.hasMissingSC);\n        }),\n        isBox: target.data(CyNode.isBox),\n        isIdle: targetOrBoxChildren.every(function (t) {\n          return t.data(CyNode.isIdle);\n        }),\n        isInaccessible: target.data(CyNode.isInaccessible),\n        isOutside: target.data(CyNode.isOutside),\n        isServiceEntry: target.data(CyNode.isServiceEntry),\n        namespace: target.data(CyNode.namespace),\n        nodeType: target.data(CyNode.nodeType),\n        service: target.data(CyNode.service),\n        version: targetType === 'box' ? undefined : target.data(CyNode.version),\n        workload: target.data(CyNode.workload)\n      };\n    }\n  }, {\n    key: \"isCyNodeClickEvent\",\n    value: function isCyNodeClickEvent(event) {\n      var targetType = event.summaryType;\n\n      if (targetType !== 'node' && targetType !== 'box') {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"isCyEdgeClickEvent\",\n    value: function isCyEdgeClickEvent(event) {\n      var targetType = event.summaryType;\n      return targetType === 'edge';\n    }\n  }]);\n\n  return CytoscapeGraph;\n}(React.Component);\n\nCytoscapeGraph.contextTypes = {\n  router: function router() {\n    return null;\n  }\n};\nCytoscapeGraph.defaultProps = {\n  isMiniGraph: false\n};\nCytoscapeGraph.doubleTapMs = 350;\nCytoscapeGraph.tapTarget = void 0;\nCytoscapeGraph.tapTimeout = void 0;\nCytoscapeGraph.DataNodeId = 'data-node-id';\nexport { CytoscapeGraph as default };","map":{"version":3,"sources":["/root/kiali-ui/src/components/CytoscapeGraph/CytoscapeGraph.tsx"],"names":["React","ReactResizeDetector","BoxByType","CLUSTER_DEFAULT","CytoscapeGlobalScratchNamespace","NodeType","UNKNOWN","addInfo","angleBetweenVectors","squaredDistance","normalize","CytoscapeContextMenuWrapper","CytoscapeGraphUtils","CyNode","isCore","isEdge","isNode","CytoscapeReactWrapper","showTrace","hideTrace","EmptyGraphLayout","FocusAnimation","GraphHighlighter","TrafficRenderer","serverConfig","decoratedNodeData","CytoscapeGraph","props","contextMenuRef","cy","customViewport","cytoscapeReactWrapperRef","focusSelector","graphHighlighter","namespaceChanged","needsInitialLayout","nodeChanged","resetSelection","trafficRenderer","userBoxSelected","onResize","resize","safeFit","selectTarget","target","isTapped","isMiniGraph","$","selectify","unselect","unselectify","select","selectTargetAndUpdateSummary","event","summaryType","data","isBox","summaryTarget","updateSummary","onClick","handleDoubleTap","onNodeDoubleTap","isCyNodeClickEvent","buildTapEventArgs","handleTap","onNodeTap","onEdgeTap","isCyEdgeClickEvent","handleMouseIn","onMouseIn","handleMouseOut","onMouseOut","createRef","cyInitialization","getCy","nextProps","graphData","fetchParams","node","result","edgeLabels","isLoading","elements","layout","compressOnHide","showMissingSidecars","showTrafficAnimation","showVirtualServices","trace","prevProps","updateLayout","nodeNeedsRelayout","namespaceNeedsRelayout","elementsNeedRelayout","name","processGraphUpdate","then","_response","length","selector","namespace","nodeType","AGGREGATE","aggregate","aggregateValue","APP","BOX","app","version","SERVICE","service","workload","eles","nodes","isChild","parent","graphType","containerClassName","onEmptyGraphAction","errorMessage","isError","namespaces","showIdleNodes","toggleIdleNodes","contextMenuEdgeComponent","contextMenuNodeComponent","contextMenuGroupComponent","e","setCytoscapeReactWrapperRef","current","cyRef","boxSelectionEnabled","connectCy","getCytoscapeBaseEvent","findRelatedNode","element","getAttribute","DataNodeId","dataNodeId","parentNode","on","originalEvent","document","elementFromPoint","clientX","clientY","realTargetId","realTarget","$id","preventDefault","trigger","tapped","tapTimeout","clearTimeout","tapTarget","cytoscapeEvent","setTimeout","doubleTapMs","evt","collection","forEach","add","label","isNew","getNode","setAttribute","id","isParent","oldBE","numericStyle","Array","fill","bb","boundingBox","includeOverlays","newBE","requiredWidth","offsetWidth","w","requiredHeight","offsetHeight","map","val","Math","max","compareBoundsExpansion","be1","be2","delta","i","abs","style","destroyed","nodeHtmlLabel","updateNodeLabel","_evt","fixLoopOverlap","ready","onReady","stop","undefined","selected","compound","filter","subtract","same","children","start","force","focus","pause","isTheGraphSelected","globalScratchData","activeNamespaces","homeCluster","clusterInfo","trafficRates","showSecurity","scratch","startBatch","positions","x","y","json","endBatch","Promise","resolve","_reject","runLayout","finishGraphUpdate","edges","setUpdateTime","Date","now","prevElements","nextElements","needsRelayout","nodeOrEdgeArrayHasSameIds","a","b","aIds","sort","every","eId","index","loop","source","otherEdges","connectedEdges","minDistance","DEFAULT_LOOP_SWEEP","DEFAULT_LOOP_DIRECTION","found","edge","testPoint","sourceEndpoint","targetEndpoint","loopDirection","usedAngles","angle","position","push","PI","maxArc","end","value","arc","targetType","targetOrBoxChildren","descendants","nodeSource","nodeTarget","type","hasMissingSC","t","isIdle","isInaccessible","isOutside","isServiceEntry","Component","contextTypes","router","defaultProps"],"mappings":"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","sourcesContent":["import * as Cy from 'cytoscape';\nimport { Core } from 'cytoscape';\nimport { EdgeSingular } from 'cytoscape';\nimport { NodeSingular } from 'cytoscape';\nimport * as React from 'react';\nimport ReactResizeDetector from 'react-resize-detector';\nimport { GraphData } from 'pages/Graph/GraphPage';\nimport { IntervalInMilliseconds, TimeInMilliseconds } from '../../types/Common';\nimport {\n  BoxByType,\n  CLUSTER_DEFAULT,\n  CytoscapeBaseEvent,\n  CytoscapeClickEvent,\n  CytoscapeGlobalScratchData,\n  CytoscapeGlobalScratchNamespace,\n  CytoscapeMouseInEvent,\n  CytoscapeMouseOutEvent,\n  EdgeLabelMode,\n  Layout,\n  NodeParamsType,\n  NodeType,\n  UNKNOWN\n} from '../../types/Graph';\nimport { JaegerTrace } from 'types/JaegerInfo';\nimport Namespace from '../../types/Namespace';\nimport { addInfo } from 'utils/AlertUtils';\nimport { angleBetweenVectors, squaredDistance, normalize } from '../../utils/MathUtils';\nimport { CytoscapeContextMenuWrapper, NodeContextMenuType, EdgeContextMenuType } from './CytoscapeContextMenu';\nimport * as CytoscapeGraphUtils from './CytoscapeGraphUtils';\nimport { CyNode, isCore, isEdge, isNode } from './CytoscapeGraphUtils';\nimport { CytoscapeReactWrapper } from './CytoscapeReactWrapper';\nimport { showTrace, hideTrace } from './CytoscapeTrace';\nimport EmptyGraphLayout from './EmptyGraphLayout';\nimport FocusAnimation from './FocusAnimation';\nimport { GraphHighlighter } from './graphs/GraphHighlighter';\nimport TrafficRenderer from './TrafficAnimation/TrafficRenderer';\nimport { serverConfig } from 'config';\nimport { decoratedNodeData } from './CytoscapeGraphUtils';\n\ntype CytoscapeGraphProps = {\n  compressOnHide: boolean;\n  containerClassName?: string;\n  contextMenuEdgeComponent?: EdgeContextMenuType;\n  contextMenuGroupComponent?: NodeContextMenuType;\n  contextMenuNodeComponent?: NodeContextMenuType;\n  edgeLabels: EdgeLabelMode[];\n  graphData: GraphData;\n  focusSelector?: string;\n  isMiniGraph: boolean;\n  isMTLSEnabled: boolean;\n  layout: Layout;\n  onEmptyGraphAction?: () => void;\n  onNodeDoubleTap?: (e: GraphNodeDoubleTapEvent) => void;\n  onEdgeTap?: (e: GraphEdgeTapEvent) => void;\n  onNodeTap?: (e: GraphNodeTapEvent) => void;\n  onReady?: (cytoscapeRef: any) => void;\n  refreshInterval: IntervalInMilliseconds;\n  setActiveNamespaces?: (namespace: Namespace[]) => void;\n  setNode?: (node?: NodeParamsType) => void;\n  setTraceId?: (traceId?: string) => void;\n  setUpdateTime?: (val: TimeInMilliseconds) => void;\n  showIdleEdges: boolean;\n  showIdleNodes: boolean;\n  showMissingSidecars: boolean;\n  showOperationNodes: boolean;\n  showSecurity: boolean;\n  showServiceNodes: boolean;\n  showTrafficAnimation: boolean;\n  showVirtualServices: boolean;\n  toggleIdleNodes: () => void;\n  trace?: JaegerTrace;\n  updateSummary?: (event: CytoscapeClickEvent) => void;\n};\n\nexport interface GraphEdgeTapEvent {\n  namespace: string;\n  type: string;\n  source: string;\n  target: string;\n}\n\nexport interface GraphNodeTapEvent {\n  aggregate?: string;\n  aggregateValue?: string;\n  app: string;\n  hasMissingSC: boolean;\n  isBox?: string;\n  isInaccessible: boolean;\n  isOutside: boolean;\n  isServiceEntry: boolean;\n  isIdle: boolean;\n  namespace: string;\n  nodeType: NodeType;\n  service: string;\n  version?: string;\n  workload: string;\n}\n\nexport interface GraphNodeDoubleTapEvent extends GraphNodeTapEvent {}\n\n// exporting this class for testing\nexport default class CytoscapeGraph extends React.Component<CytoscapeGraphProps> {\n  static contextTypes = {\n    router: () => null\n  };\n  static defaultProps = {\n    isMiniGraph: false\n  };\n  // for dbl-click support\n  static doubleTapMs = 350;\n  static tapTarget: any;\n  static tapTimeout: any;\n  static readonly DataNodeId = 'data-node-id';\n\n  private readonly contextMenuRef: React.RefObject<CytoscapeContextMenuWrapper>;\n  private cy?: Cy.Core;\n  private customViewport: boolean;\n  private cytoscapeReactWrapperRef: any;\n  private focusSelector?: string;\n  private graphHighlighter?: GraphHighlighter;\n  private namespaceChanged: boolean;\n  private needsInitialLayout: boolean;\n  private nodeChanged: boolean;\n  private resetSelection: boolean = false;\n  private trafficRenderer?: TrafficRenderer;\n  private userBoxSelected?: Cy.Collection;\n\n  constructor(props: CytoscapeGraphProps) {\n    super(props);\n    this.contextMenuRef = React.createRef<CytoscapeContextMenuWrapper>();\n    this.customViewport = false;\n    this.cytoscapeReactWrapperRef = React.createRef();\n    this.focusSelector = props.focusSelector;\n    this.namespaceChanged = false;\n    this.needsInitialLayout = false;\n    this.nodeChanged = false;\n  }\n\n  componentDidMount() {\n    this.cyInitialization(this.getCy()!);\n  }\n\n  shouldComponentUpdate(nextProps: CytoscapeGraphProps) {\n    this.nodeChanged =\n      this.nodeChanged || this.props.graphData.fetchParams.node !== nextProps.graphData.fetchParams.node;\n\n    // only update on display changes for the existing graph. Duration or refreshInterval changes don't\n    // affect display. Options that trigger a graph refresh will have an update when the refresh\n    // completes (showIdleNodes, showSecurity, showServiceNodes, etc).\n    let result =\n      this.props.edgeLabels !== nextProps.edgeLabels ||\n      this.props.graphData.isLoading !== nextProps.graphData.isLoading ||\n      this.props.graphData.elements !== nextProps.graphData.elements ||\n      this.props.layout !== nextProps.layout ||\n      this.props.compressOnHide !== nextProps.compressOnHide ||\n      this.props.showMissingSidecars !== nextProps.showMissingSidecars ||\n      this.props.showTrafficAnimation !== nextProps.showTrafficAnimation ||\n      this.props.showVirtualServices !== nextProps.showVirtualServices ||\n      this.props.trace !== nextProps.trace;\n\n    return result;\n  }\n\n  componentDidUpdate(prevProps: CytoscapeGraphProps) {\n    if (this.props.graphData.isLoading) {\n      return;\n    }\n\n    const cy = this.getCy();\n    if (!cy) {\n      return;\n    }\n\n    let updateLayout = false;\n    if (\n      this.needsInitialLayout ||\n      this.nodeNeedsRelayout() ||\n      this.namespaceNeedsRelayout(prevProps.graphData.elements, this.props.graphData.elements) ||\n      this.elementsNeedRelayout(prevProps.graphData.elements, this.props.graphData.elements) ||\n      this.props.layout.name !== prevProps.layout.name\n    ) {\n      updateLayout = true;\n      this.needsInitialLayout = false;\n    }\n\n    this.processGraphUpdate(cy, updateLayout).then(_response => {\n      // pre-select node if provided\n      const node = this.props.graphData.fetchParams.node;\n      if (node && cy && cy.$(':selected').length === 0) {\n        let selector = `[namespace = \"${node.namespace.name}\"][nodeType = \"${node.nodeType}\"]`;\n        switch (node.nodeType) {\n          case NodeType.AGGREGATE:\n            selector =\n              selector + \"[aggregate = '\" + node.aggregate! + \"'][aggregateValue = '\" + node.aggregateValue! + \"']\";\n            break;\n          case NodeType.APP:\n          case NodeType.BOX: // we only support app box node graphs, treat like an app node\n            selector = selector + \"[app = '\" + node.app + \"']\";\n            if (node.version && node.version !== UNKNOWN) {\n              selector = selector + \"[version = '\" + node.version + \"']\";\n            }\n            break;\n          case NodeType.SERVICE:\n            selector = selector + \"[service = '\" + node.service + \"']\";\n            break;\n          default:\n            selector = selector + \"[workload = '\" + node.workload + \"']\";\n        }\n\n        const eles = cy.nodes(selector);\n        if (eles.length > 0) {\n          let target = eles[0];\n          // default app to the whole app box, when appropriate\n          if (\n            (node.nodeType === NodeType.APP || node.nodeType === NodeType.BOX) &&\n            !node.version &&\n            target.isChild() &&\n            target.parent()[0].data(CyNode.isBox) === BoxByType.APP\n          ) {\n            target = target.parent()[0];\n          }\n\n          this.selectTargetAndUpdateSummary(target);\n        }\n      }\n\n      if (this.props.trace) {\n        showTrace(cy, this.props.graphData.fetchParams.graphType, this.props.trace);\n      } else if (!this.props.trace && prevProps.trace) {\n        hideTrace(cy);\n      }\n    });\n  }\n\n  render() {\n    return (\n      <div id=\"cytoscape-container\" className={this.props.containerClassName}>\n        <ReactResizeDetector handleWidth={true} handleHeight={true} skipOnMount={false} onResize={this.onResize} />\n        <EmptyGraphLayout\n          action={this.props.onEmptyGraphAction}\n          elements={this.props.graphData.elements}\n          error={this.props.graphData.errorMessage}\n          isLoading={this.props.graphData.isLoading}\n          isError={!!this.props.graphData.isError}\n          isMiniGraph={this.props.isMiniGraph}\n          namespaces={this.props.graphData.fetchParams.namespaces}\n          showIdleNodes={this.props.showIdleNodes}\n          toggleIdleNodes={this.props.toggleIdleNodes}\n        >\n          <CytoscapeContextMenuWrapper\n            ref={this.contextMenuRef}\n            edgeContextMenuContent={this.props.contextMenuEdgeComponent}\n            nodeContextMenuContent={this.props.contextMenuNodeComponent}\n            groupContextMenuContent={this.props.contextMenuGroupComponent}\n          />\n          <CytoscapeReactWrapper ref={e => this.setCytoscapeReactWrapperRef(e)} />\n        </EmptyGraphLayout>\n      </div>\n    );\n  }\n\n  getCy(): Cy.Core | null {\n    return this.cytoscapeReactWrapperRef.current ? this.cytoscapeReactWrapperRef.current.getCy() : null;\n  }\n\n  static buildTapEventArgs(event: CytoscapeClickEvent): GraphNodeTapEvent | GraphEdgeTapEvent {\n    const target = event.summaryTarget;\n    const targetType = event.summaryType;\n    const targetOrBoxChildren = targetType === 'box' ? target.descendants() : target;\n\n    if (targetType === 'edge') {\n      const nodeSource = decoratedNodeData(target.source());\n      const nodeTarget = decoratedNodeData(target.target());\n      return {\n        namespace: nodeSource.namespace,\n        type: nodeSource.nodeType,\n        source: nodeSource[nodeSource.nodeType],\n        target: nodeTarget[nodeTarget.nodeType]\n      };\n    }\n    // Invoke callback\n    return {\n      aggregate: target.data(CyNode.aggregate),\n      aggregateValue: target.data(CyNode.aggregateValue),\n      app: target.data(CyNode.app),\n      hasMissingSC: targetOrBoxChildren.every(t => t.data(CyNode.hasMissingSC)),\n      isBox: target.data(CyNode.isBox),\n      isIdle: targetOrBoxChildren.every(t => t.data(CyNode.isIdle)),\n      isInaccessible: target.data(CyNode.isInaccessible),\n      isOutside: target.data(CyNode.isOutside),\n      isServiceEntry: target.data(CyNode.isServiceEntry),\n      namespace: target.data(CyNode.namespace),\n      nodeType: target.data(CyNode.nodeType),\n      service: target.data(CyNode.service),\n      version: targetType === 'box' ? undefined : target.data(CyNode.version),\n      workload: target.data(CyNode.workload)\n    };\n  }\n\n  private setCytoscapeReactWrapperRef(cyRef: any) {\n    this.cytoscapeReactWrapperRef.current = cyRef;\n    this.cyInitialization(this.getCy()!);\n  }\n\n  private onResize = () => {\n    if (this.cy) {\n      this.cy.resize();\n      // always fit to the newly sized space\n      this.safeFit(this.cy, true);\n    }\n  };\n\n  private cyInitialization(cy: Cy.Core) {\n    if (!cy) {\n      return;\n    }\n\n    // Caches the cy instance that is currently in use.\n    // If that cy instance is the same one we are being asked to initialize, do NOT initialize it again;\n    // this would add duplicate callbacks and would screw up the graph highlighter. If, however,\n    // we are being asked to initialize a different cy instance, we assume the current one is now obsolete\n    // so we do want to initialize the new cy instance.\n    if (this.cy === cy) {\n      return;\n    }\n    this.cy = cy;\n    this.cy.boxSelectionEnabled(true);\n\n    this.contextMenuRef!.current!.connectCy(this.cy);\n\n    this.graphHighlighter = new GraphHighlighter(cy);\n    this.trafficRenderer = new TrafficRenderer(cy);\n\n    const getCytoscapeBaseEvent = (event: Cy.EventObject): CytoscapeBaseEvent | null => {\n      const target = event.target;\n      if (target === cy) {\n        return { summaryType: 'graph', summaryTarget: cy };\n      } else if (isNode(target)) {\n        if (target.data(CyNode.isBox)) {\n          return { summaryType: 'box', summaryTarget: target };\n        } else {\n          return { summaryType: 'node', summaryTarget: target };\n        }\n      } else if (isEdge(target)) {\n        return { summaryType: 'edge', summaryTarget: target };\n      } else {\n        return null;\n      }\n    };\n\n    const findRelatedNode = element => {\n      // Skip top-level node, this one has margins that we don't want to consider.\n      if (element.getAttribute(CytoscapeGraph.DataNodeId)) {\n        return null;\n      }\n      while (element && element.getAttribute) {\n        const dataNodeId = element.getAttribute(CytoscapeGraph.DataNodeId);\n        if (dataNodeId) {\n          return dataNodeId;\n        }\n        element = element.parentNode;\n      }\n      return null;\n    };\n\n    cy.on('tap', (event: Cy.EventObject) => {\n      // Check if we clicked a label, if so stop processing the event right away.\n      if (event.originalEvent) {\n        const element = document.elementFromPoint(event.originalEvent.clientX, event.originalEvent.clientY);\n        const realTargetId = findRelatedNode(element);\n        if (realTargetId) {\n          const realTarget = cy.$id(realTargetId);\n          if (realTarget) {\n            event.preventDefault();\n            realTarget.trigger('tap');\n            return;\n          }\n        }\n      }\n\n      let tapped: NodeSingular | EdgeSingular | Core | null = event.target;\n      if (CytoscapeGraph.tapTimeout) {\n        // cancel any single-tap timer in progress\n        clearTimeout(CytoscapeGraph.tapTimeout);\n        CytoscapeGraph.tapTimeout = null;\n\n        if (tapped === CytoscapeGraph.tapTarget) {\n          // if we click the same target again, perform double-tap\n          tapped = null;\n          CytoscapeGraph.tapTarget = null;\n          const cytoscapeEvent = getCytoscapeBaseEvent(event);\n          if (cytoscapeEvent) {\n            this.handleDoubleTap(cytoscapeEvent);\n          }\n        }\n      }\n      if (tapped) {\n        // start single-tap timer\n        CytoscapeGraph.tapTarget = tapped;\n        CytoscapeGraph.tapTimeout = setTimeout(() => {\n          // timer expired without a follow-up click, so perform single-tap\n          CytoscapeGraph.tapTarget = null;\n          const cytoscapeEvent = getCytoscapeBaseEvent(event);\n          if (cytoscapeEvent) {\n            this.handleTap(cytoscapeEvent);\n            this.selectTarget(event.target, true);\n          }\n        }, CytoscapeGraph.doubleTapMs);\n      }\n    });\n\n    // Note that at the time of writing (on my chrome) the order of box events:\n    // 1) boxstart\n    // 2) boxend\n    // 3) box, a separate event for each boxselected element\n    // The boxselect event never seems to fire. boxend does not seem to supply the boxselected collection (why?).\n    // So, boxend seems not useful. I don't see a way to do this other than to 'fit' each time we add an elem.\n    cy.on('boxstart', (evt: Cy.EventObject) => {\n      const cytoscapeEvent = getCytoscapeBaseEvent(evt);\n      if (cytoscapeEvent) {\n        this.userBoxSelected = cy.collection();\n      }\n    });\n\n    cy.on('box', (evt: Cy.EventObject) => {\n      const cytoscapeEvent = getCytoscapeBaseEvent(evt);\n      if (cytoscapeEvent) {\n        const elements: Cy.Collection = evt.target;\n        if (elements) {\n          elements.forEach(e => {\n            if (e.data(CyNode.nodeType) !== NodeType.BOX) {\n              this.userBoxSelected = this.userBoxSelected?.add(elements);\n            }\n          });\n          CytoscapeGraphUtils.safeFit(cy, this.userBoxSelected);\n          this.customViewport = true;\n        }\n      }\n    });\n\n    cy.on('mouseover', 'node,edge', (evt: Cy.EventObject) => {\n      const cytoscapeEvent = getCytoscapeBaseEvent(evt);\n      if (cytoscapeEvent) {\n        this.handleMouseIn(cytoscapeEvent);\n      }\n    });\n\n    cy.on('mouseout', 'node,edge', (evt: Cy.EventObject) => {\n      const cytoscapeEvent = getCytoscapeBaseEvent(evt);\n      if (cytoscapeEvent) {\n        this.handleMouseOut(cytoscapeEvent);\n      }\n    });\n\n    cy.on('viewport', (evt: Cy.EventObject) => {\n      const cytoscapeEvent = getCytoscapeBaseEvent(evt);\n      if (cytoscapeEvent) {\n        this.customViewport = true;\n      }\n    });\n\n    // 'fit' is a custom event that we emit allowing us to reset cytoscapeGraph.customViewport\n    cy.on('fit', (evt: Cy.EventObject) => {\n      const cytoscapeEvent = getCytoscapeBaseEvent(evt);\n      if (cytoscapeEvent) {\n        this.customViewport = false;\n      }\n    });\n\n    cy.on('nodehtml-create-or-update', 'node', (evt: Cy.EventObjectNode, data: any) => {\n      const { label, isNew } = data;\n      const { target } = evt;\n      // This is the DOM node of the label, if we want the cyNode it is `target`\n      const node = label.getNode();\n\n      // Assign to the label node (the DOM element) an id that matches the cy node.\n      // This is so that when we click, we can identify if the clicked label belongs to\n      // any cy node and select it\n      // Note that we don't add an actual listener to this DOM node. We use the cy click event, this proved to be more\n      // stable than adding a listener. As we only want the contents to match and not the whole node (which is bigger).\n      if (isNew) {\n        node.setAttribute('data-node-id', target.id());\n      }\n\n      // Skip parent nodes from bounding expansion calculation, their size is defined by their contents, so no point in\n      // messing with these values.\n      if (target.isParent()) {\n        return;\n      }\n\n      // The code below expands the bounds of a node, taking into consideration the labels. This is important not only\n      // for displaying the label, but to avoid nodes overlapping with other labels.\n      // We assume that a label is placed centered in the bottom part of a node.\n      // The algorithm is:\n      // - Take the old bounds-expansion\n      // - Get the bounding-box of a node (without taking into account the overlays  i.e. the one that appears on click)\n      // - Compute the required extra width as the label width minus the bounding box width\n      //   - This will yield a a positive number if we need more space, or negative if we need less space.\n      // - Compute the required height as the height of the label. Since the label is at the bottom, we only need that.\n      //   If its center was aligned with the center of the node, we would do a similar operation as with the width.\n      // - Spread the required width as extra space in the left area and space in the right area of the cy node\n      //   (half in each side)\n      // - Required height is only needed at the bottom, so we now that we always have to grow at the bottom by this value.\n\n      let oldBE = target.numericStyle('bounds-expansion');\n      if (oldBE.length === 1) {\n        oldBE = Array(4).fill(oldBE[0]);\n      }\n      // Do not include the \"click\" overlay on the bounding box calc\n      const bb = target.boundingBox({ includeOverlays: false });\n      let newBE = [...oldBE];\n      const requiredWidth = node.offsetWidth - bb.w;\n      const requiredHeight = node.offsetHeight;\n      newBE[1] += requiredWidth * 0.5;\n      newBE[3] += requiredWidth * 0.5;\n      newBE[2] = requiredHeight;\n\n      // Ensure we don't end with negative values in our bounds-expansion\n      newBE = newBE.map(val => Math.max(val, 0));\n\n      const compareBoundsExpansion = (be1: number[], be2: number[]) => {\n        if (be1.length !== be2.length) {\n          return false;\n        }\n\n        const delta = 0.00001;\n\n        for (let i = 0; i < be1.length; ++i) {\n          if (Math.abs(be1[i] - be2[i]) > delta) {\n            return false;\n          }\n        }\n        return true;\n      };\n\n      // Only trigger an update if it really changed, else just skip to avoid this function to call again\n      if (!compareBoundsExpansion(oldBE, newBE)) {\n        target.style('bounds-expansion', newBE);\n        // bounds-expansion changed. Make sure we tell our parent (if any) to update as well (so he can update the label position).\n        if (target.isChild()) {\n          // The timeout ensures that the previous value is already applied\n          setTimeout(() => {\n            if (!target.cy().destroyed()) {\n              (target.cy() as any) // because we are using an extension\n                .nodeHtmlLabel()\n                .updateNodeLabel(target.parent());\n            }\n          }, 0);\n        }\n      }\n    });\n\n    cy.on('layoutstop', (_evt: Cy.EventObject) => {\n      // Don't allow a large zoom if the graph has a few nodes (nodes would look too big).\n      this.safeFit(cy);\n      this.fixLoopOverlap(cy);\n    });\n\n    cy.ready((evt: Cy.EventObject) => {\n      if (this.props.onReady) {\n        this.props.onReady(evt.cy);\n      }\n      this.needsInitialLayout = true;\n    });\n\n    cy.on('destroy', (_evt: Cy.EventObject) => {\n      this.trafficRenderer!.stop();\n      this.trafficRenderer = undefined;\n      this.cy = undefined;\n      if (this.props.updateSummary) {\n        this.props.updateSummary({ summaryType: 'graph', summaryTarget: undefined });\n      }\n    });\n  }\n\n  private focus(cy: Cy.Core) {\n    if (!this.focusSelector) {\n      return;\n    }\n\n    // only perform the focus one time\n    const focusSelector = this.focusSelector;\n    this.focusSelector = undefined;\n\n    let selected = cy.$(focusSelector);\n\n    if (!selected) {\n      addInfo(\n        'Could not focus on requested node. The node may be idle or hidden.',\n        true,\n        undefined,\n        `${focusSelector}`\n      );\n      return;\n    }\n\n    // If there is only one, select it\n    if (selected.length === 1) {\n      this.selectTargetAndUpdateSummary(selected[0]);\n    } else {\n      // If we have many elements, try to check if a compound in this query contains everything, if so, select it.\n      const compound = selected.filter('$node > node');\n      if (compound && compound.length === 1 && selected.subtract(compound).same(compound.children())) {\n        this.selectTargetAndUpdateSummary(compound[0]);\n        selected = compound;\n      }\n    }\n\n    // Start animation\n    new FocusAnimation(cy).start(selected);\n  }\n\n  private safeFit(cy: Cy.Core, force?: boolean) {\n    if (!force && this.customViewport) {\n      return;\n    }\n    this.focus(cy);\n    CytoscapeGraphUtils.safeFit(cy);\n  }\n\n  private processGraphUpdate(cy: Cy.Core, updateLayout: boolean): Promise<void> {\n    this.trafficRenderer!.pause();\n\n    const isTheGraphSelected = cy.$(':selected').length === 0;\n    if (this.resetSelection) {\n      if (!isTheGraphSelected) {\n        this.selectTarget();\n        this.handleTap({ summaryType: 'graph', summaryTarget: cy });\n      }\n      this.resetSelection = false;\n    }\n\n    const globalScratchData: CytoscapeGlobalScratchData = {\n      activeNamespaces: this.props.graphData.fetchParams.namespaces,\n      edgeLabels: this.props.edgeLabels,\n      homeCluster: serverConfig?.clusterInfo?.name || CLUSTER_DEFAULT,\n      graphType: this.props.graphData.fetchParams.graphType,\n      trafficRates: this.props.graphData.fetchParams.trafficRates,\n      showMissingSidecars: this.props.showMissingSidecars,\n      showSecurity: this.props.showSecurity,\n      showVirtualServices: this.props.showVirtualServices\n    };\n    cy.scratch(CytoscapeGlobalScratchNamespace, globalScratchData);\n\n    cy.startBatch();\n\n    // KIALI-1291 issue was caused because some layouts (can't tell if all) do reuse the existing positions.\n    // We got some issues when changing from/to cola/cose, as the nodes started to get far away from each other.\n    // Previously we deleted the nodes prior to a layout update, this was too much and it seems that only reseting the\n    // positions to 0,0 makes the layout more predictable.\n    if (updateLayout) {\n      cy.nodes().positions({ x: 0, y: 0 });\n    }\n\n    // update the entire set of nodes and edges to keep the graph up-to-date\n    cy.json({ elements: this.props.graphData.elements });\n\n    cy.endBatch();\n\n    // Run layout outside of the batch operation for it to take effect on the new nodes,\n    // Layouts can run async so wait until it completes to finish the graph update.\n    if (updateLayout) {\n      return new Promise((resolve, _reject) => {\n        CytoscapeGraphUtils.runLayout(cy, this.props.layout).then(_response => {\n          this.finishGraphUpdate(cy, isTheGraphSelected);\n          resolve();\n        });\n      });\n    } else {\n      this.finishGraphUpdate(cy, isTheGraphSelected);\n      return Promise.resolve();\n    }\n  }\n\n  private finishGraphUpdate(cy: Cy.Core, isTheGraphSelected: boolean) {\n    // We opt-in for manual selection to be able to control when to select a node/edge\n    // https://github.com/cytoscape/cytoscape.js/issues/1145#issuecomment-153083828\n    cy.nodes().unselectify();\n    cy.edges().unselectify();\n\n    // Verify our current selection is still valid, if not, select the graph\n    if (!isTheGraphSelected && cy.$(':selected').length === 0) {\n      this.handleTap({ summaryType: 'graph', summaryTarget: cy });\n    }\n\n    if (this.props.showTrafficAnimation) {\n      this.trafficRenderer!.start(cy.edges());\n    }\n\n    // notify that the graph has been updated\n    if (this.props.setUpdateTime) {\n      this.props.setUpdateTime(Date.now());\n    }\n  }\n\n  private selectTarget = (target?: Cy.NodeSingular | Cy.EdgeSingular | Cy.Core, isTapped: boolean = false) => {\n    if (this.props.isMiniGraph && isTapped) {\n      return;\n    }\n    if (this.cy) {\n      this.cy.$(':selected').selectify().unselect().unselectify();\n      if (target && !isCore(target)) {\n        target.selectify().select().unselectify();\n      }\n    }\n  };\n\n  private selectTargetAndUpdateSummary = (target: Cy.NodeSingular | Cy.EdgeSingular) => {\n    this.selectTarget(target);\n    const event: CytoscapeClickEvent = {\n      summaryType: target.data(CyNode.isBox) ? 'box' : 'node',\n      summaryTarget: target\n    };\n    if (this.props.updateSummary) {\n      this.props.updateSummary(event);\n    }\n    this.graphHighlighter!.onClick(event);\n  };\n\n  private handleDoubleTap = (event: CytoscapeClickEvent) => {\n    if (this.props.onNodeDoubleTap && CytoscapeGraph.isCyNodeClickEvent(event)) {\n      this.props.onNodeDoubleTap(CytoscapeGraph.buildTapEventArgs(event) as GraphNodeTapEvent);\n    }\n  };\n\n  private handleTap = (event: CytoscapeClickEvent) => {\n    if (this.props.updateSummary) {\n      this.props.updateSummary(event);\n    }\n\n    if (this.props.onNodeTap && CytoscapeGraph.isCyNodeClickEvent(event)) {\n      this.props.onNodeTap(CytoscapeGraph.buildTapEventArgs(event) as GraphNodeTapEvent);\n    }\n\n    if (!this.props.isMiniGraph) {\n      this.graphHighlighter!.onClick(event);\n    } else if (this.props.onEdgeTap && CytoscapeGraph.isCyEdgeClickEvent(event)) {\n      this.props.onEdgeTap(CytoscapeGraph.buildTapEventArgs(event) as GraphEdgeTapEvent);\n    }\n  };\n\n  private handleMouseIn = (event: CytoscapeMouseInEvent) => {\n    this.graphHighlighter!.onMouseIn(event);\n  };\n\n  private handleMouseOut = (event: CytoscapeMouseOutEvent) => {\n    this.graphHighlighter!.onMouseOut(event);\n  };\n\n  private namespaceNeedsRelayout(prevElements: any, nextElements: any) {\n    const needsRelayout = this.namespaceChanged && prevElements !== nextElements;\n    if (needsRelayout) {\n      this.namespaceChanged = false;\n    }\n    return needsRelayout;\n  }\n\n  private nodeNeedsRelayout() {\n    const needsRelayout = this.nodeChanged;\n    if (needsRelayout) {\n      this.nodeChanged = false;\n    }\n    return needsRelayout;\n  }\n\n  static isCyNodeClickEvent(event: CytoscapeClickEvent): boolean {\n    const targetType = event.summaryType;\n    if (targetType !== 'node' && targetType !== 'box') {\n      return false;\n    }\n\n    return true;\n  }\n\n  static isCyEdgeClickEvent(event: CytoscapeClickEvent): boolean {\n    const targetType = event.summaryType;\n    return targetType === 'edge';\n  }\n\n  // To know if we should re-layout, we need to know if any element changed\n  // Do a quick round by comparing the number of nodes and edges, if different\n  // a change is expected.\n  // If we have the same number of elements, compare the ids, if we find one that isn't\n  // in the other, we can be sure that there are changes.\n  // Worst case is when they are the same, avoid that.\n  private elementsNeedRelayout(prevElements: any, nextElements: any) {\n    if (prevElements === nextElements) {\n      return false;\n    }\n    if (\n      !prevElements ||\n      !nextElements ||\n      !prevElements.nodes ||\n      !prevElements.edges ||\n      !nextElements.nodes ||\n      !nextElements.edges ||\n      prevElements.nodes.length !== nextElements.nodes.length ||\n      prevElements.edges.length !== nextElements.edges.length\n    ) {\n      return true;\n    }\n    // If both have the same ids, we don't need to relayout\n    return !(\n      this.nodeOrEdgeArrayHasSameIds(nextElements.nodes, prevElements.nodes) &&\n      this.nodeOrEdgeArrayHasSameIds(nextElements.edges, prevElements.edges)\n    );\n  }\n\n  private nodeOrEdgeArrayHasSameIds<T extends Cy.NodeSingular | Cy.EdgeSingular>(a: Array<T>, b: Array<T>) {\n    const aIds = a.map(e => e.id).sort();\n    return b\n      .map(e => e.id)\n      .sort()\n      .every((eId, index) => eId === aIds[index]);\n  }\n\n  private fixLoopOverlap(cy: Cy.Core) {\n    cy.$(':loop').forEach(loop => {\n      const node = loop.source();\n      const otherEdges = node.connectedEdges().subtract(loop);\n      const minDistance = 1;\n\n      // Default values in rads (taken from cytoscape docs)\n      const DEFAULT_LOOP_SWEEP = -1.5707;\n      const DEFAULT_LOOP_DIRECTION = -0.7854;\n\n      loop.style('loop-direction', DEFAULT_LOOP_DIRECTION);\n      loop.style('loop-sweep', DEFAULT_LOOP_SWEEP);\n\n      let found = false;\n      // Check if we have any other edge that overlaps with any of our loop edges\n      // this uses cytoscape forEach (https://js.cytoscape.org/#eles.forEach)\n      otherEdges.forEach(edge => {\n        const testPoint = edge.source().same(node) ? edge.sourceEndpoint() : edge.targetEndpoint();\n        if (\n          squaredDistance(testPoint, loop.sourceEndpoint()) <= minDistance ||\n          squaredDistance(testPoint, loop.targetEndpoint()) <= minDistance\n        ) {\n          found = true;\n          return false; // break the inner cytoscape forEach\n        }\n        return; // return to avoid typescript error about \"not all code paths return a value\"\n      });\n\n      if (!found) {\n        return;\n      }\n\n      // Simple case, one other edge, just move the loop-direction half the default loop-sweep value to avoid the edge\n      if (otherEdges.length === 1) {\n        const loopDirection = loop.numericStyle('loop-direction') - loop.numericStyle('loop-sweep') * 0.5;\n        loop.style('loop-direction', loopDirection);\n        return;\n      }\n\n      // Compute every angle between the top (12 oâ€™clock position)\n      // We store the angles as radians and positive numbers, thus we add PI to the negative angles.\n      const usedAngles: number[] = [];\n      otherEdges.forEach(edge => {\n        const testPoint = edge.source().same(node) ? edge.sourceEndpoint() : edge.targetEndpoint();\n        const angle = angleBetweenVectors(\n          normalize({ x: testPoint.x - node.position().x, y: testPoint.y - node.position().y }),\n          { x: 0, y: 1 }\n        );\n        usedAngles.push(angle < 0 ? angle + 2 * Math.PI : angle);\n      });\n\n      usedAngles.sort((a, b) => a - b);\n\n      // Try to fit our loop in the longest arc\n      // Iterate over the found angles and find the longest distance\n      let maxArc = {\n        start: 0,\n        end: 0,\n        value: 0\n      };\n      for (let i = 0; i < usedAngles.length; ++i) {\n        const start = i === 0 ? usedAngles[usedAngles.length - 1] : usedAngles[i - 1];\n        const end = usedAngles[i];\n        const arc = Math.abs(start - end);\n        if (arc > maxArc.value) {\n          maxArc.value = arc;\n          maxArc.start = start;\n          maxArc.end = end;\n        }\n      }\n\n      // If the max arc is 1.0 radians (the biggest gap is of about 50 deg), the node is already too busy, ignore it\n      if (maxArc.value < 1.0) {\n        return;\n      }\n\n      if (maxArc.start > maxArc.end) {\n        // To ensure the difference between end and start goes in the way we want, we add a full circle to our end\n        maxArc.end += Math.PI * 2;\n      }\n\n      if (maxArc.value <= -DEFAULT_LOOP_SWEEP) {\n        // Make it slightly smaller to be able to fit\n        // loop-sweep is related to the distance between the start and end of our loop edge\n        loop.style('loop-sweep', -maxArc.value * 0.9);\n        maxArc.start += maxArc.value * 0.05;\n        maxArc.end -= maxArc.value * 0.05;\n      }\n      // Move the loop to the center of the arc, loop-direction is related to the middle point of the loop\n      loop.style('loop-direction', maxArc.start + (maxArc.end - maxArc.start) * 0.5);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}