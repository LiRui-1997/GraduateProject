{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"layoutBase\"] = factory();else root[\"layoutBase\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 26);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function LayoutConstants() {}\n      /**\r\n       * Layout Quality: 0:draft, 1:default, 2:proof\r\n       */\n\n\n      LayoutConstants.QUALITY = 1;\n      /**\r\n       * Default parameters\r\n       */\n\n      LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n      LayoutConstants.DEFAULT_INCREMENTAL = false;\n      LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n      LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n      LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n      LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false; // -----------------------------------------------------------------------------\n      // Section: General other constants\n      // -----------------------------------------------------------------------------\n\n      /*\r\n       * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n       * assume margins on all four sides to be uniform.\r\n       */\n\n      LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n      /*\r\n       * Whether to consider labels in node dimensions or not\r\n       */\n\n      LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n      /*\r\n       * Default dimension of a non-compound node.\r\n       */\n\n      LayoutConstants.SIMPLE_NODE_SIZE = 40;\n      /*\r\n       * Default dimension of a non-compound node.\r\n       */\n\n      LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n      /*\r\n       * Empty compound node size. When a compound node is empty, its both\r\n       * dimensions should be of this value.\r\n       */\n\n      LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n      /*\r\n       * Minimum length that an edge should take during layout\r\n       */\n\n      LayoutConstants.MIN_EDGE_LENGTH = 1;\n      /*\r\n       * World boundaries that layout operates on\r\n       */\n\n      LayoutConstants.WORLD_BOUNDARY = 1000000;\n      /*\r\n       * World boundaries that random positioning can be performed with\r\n       */\n\n      LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n      /*\r\n       * Coordinates of the world center\r\n       */\n\n      LayoutConstants.WORLD_CENTER_X = 1200;\n      LayoutConstants.WORLD_CENTER_Y = 900;\n      module.exports = LayoutConstants;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphObject = __webpack_require__(2);\n\n      var IGeometry = __webpack_require__(8);\n\n      var IMath = __webpack_require__(9);\n\n      function LEdge(source, target, vEdge) {\n        LGraphObject.call(this, vEdge);\n        this.isOverlapingSourceAndTarget = false;\n        this.vGraphObject = vEdge;\n        this.bendpoints = [];\n        this.source = source;\n        this.target = target;\n      }\n\n      LEdge.prototype = Object.create(LGraphObject.prototype);\n\n      for (var prop in LGraphObject) {\n        LEdge[prop] = LGraphObject[prop];\n      }\n\n      LEdge.prototype.getSource = function () {\n        return this.source;\n      };\n\n      LEdge.prototype.getTarget = function () {\n        return this.target;\n      };\n\n      LEdge.prototype.isInterGraph = function () {\n        return this.isInterGraph;\n      };\n\n      LEdge.prototype.getLength = function () {\n        return this.length;\n      };\n\n      LEdge.prototype.isOverlapingSourceAndTarget = function () {\n        return this.isOverlapingSourceAndTarget;\n      };\n\n      LEdge.prototype.getBendpoints = function () {\n        return this.bendpoints;\n      };\n\n      LEdge.prototype.getLca = function () {\n        return this.lca;\n      };\n\n      LEdge.prototype.getSourceInLca = function () {\n        return this.sourceInLca;\n      };\n\n      LEdge.prototype.getTargetInLca = function () {\n        return this.targetInLca;\n      };\n\n      LEdge.prototype.getOtherEnd = function (node) {\n        if (this.source === node) {\n          return this.target;\n        } else if (this.target === node) {\n          return this.source;\n        } else {\n          throw \"Node is not incident with this edge\";\n        }\n      };\n\n      LEdge.prototype.getOtherEndInGraph = function (node, graph) {\n        var otherEnd = this.getOtherEnd(node);\n        var root = graph.getGraphManager().getRoot();\n\n        while (true) {\n          if (otherEnd.getOwner() == graph) {\n            return otherEnd;\n          }\n\n          if (otherEnd.getOwner() == root) {\n            break;\n          }\n\n          otherEnd = otherEnd.getOwner().getParent();\n        }\n\n        return null;\n      };\n\n      LEdge.prototype.updateLength = function () {\n        var clipPointCoordinates = new Array(4);\n        this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n        if (!this.isOverlapingSourceAndTarget) {\n          this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n          this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n          if (Math.abs(this.lengthX) < 1.0) {\n            this.lengthX = IMath.sign(this.lengthX);\n          }\n\n          if (Math.abs(this.lengthY) < 1.0) {\n            this.lengthY = IMath.sign(this.lengthY);\n          }\n\n          this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n        }\n      };\n\n      LEdge.prototype.updateLengthSimple = function () {\n        this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n        this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n        if (Math.abs(this.lengthX) < 1.0) {\n          this.lengthX = IMath.sign(this.lengthX);\n        }\n\n        if (Math.abs(this.lengthY) < 1.0) {\n          this.lengthY = IMath.sign(this.lengthY);\n        }\n\n        this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n      };\n\n      module.exports = LEdge;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function LGraphObject(vGraphObject) {\n        this.vGraphObject = vGraphObject;\n      }\n\n      module.exports = LGraphObject;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphObject = __webpack_require__(2);\n\n      var Integer = __webpack_require__(10);\n\n      var RectangleD = __webpack_require__(13);\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var RandomSeed = __webpack_require__(16);\n\n      var PointD = __webpack_require__(4);\n\n      function LNode(gm, loc, size, vNode) {\n        //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n        if (size == null && vNode == null) {\n          vNode = loc;\n        }\n\n        LGraphObject.call(this, vNode); //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n\n        if (gm.graphManager != null) gm = gm.graphManager;\n        this.estimatedSize = Integer.MIN_VALUE;\n        this.inclusionTreeDepth = Integer.MAX_VALUE;\n        this.vGraphObject = vNode;\n        this.edges = [];\n        this.graphManager = gm;\n        if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n      }\n\n      LNode.prototype = Object.create(LGraphObject.prototype);\n\n      for (var prop in LGraphObject) {\n        LNode[prop] = LGraphObject[prop];\n      }\n\n      LNode.prototype.getEdges = function () {\n        return this.edges;\n      };\n\n      LNode.prototype.getChild = function () {\n        return this.child;\n      };\n\n      LNode.prototype.getOwner = function () {\n        //  if (this.owner != null) {\n        //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n        //      throw \"assert failed\";\n        //    }\n        //  }\n        return this.owner;\n      };\n\n      LNode.prototype.getWidth = function () {\n        return this.rect.width;\n      };\n\n      LNode.prototype.setWidth = function (width) {\n        this.rect.width = width;\n      };\n\n      LNode.prototype.getHeight = function () {\n        return this.rect.height;\n      };\n\n      LNode.prototype.setHeight = function (height) {\n        this.rect.height = height;\n      };\n\n      LNode.prototype.getCenterX = function () {\n        return this.rect.x + this.rect.width / 2;\n      };\n\n      LNode.prototype.getCenterY = function () {\n        return this.rect.y + this.rect.height / 2;\n      };\n\n      LNode.prototype.getCenter = function () {\n        return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n      };\n\n      LNode.prototype.getLocation = function () {\n        return new PointD(this.rect.x, this.rect.y);\n      };\n\n      LNode.prototype.getRect = function () {\n        return this.rect;\n      };\n\n      LNode.prototype.getDiagonal = function () {\n        return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n      };\n      /**\n       * This method returns half the diagonal length of this node.\n       */\n\n\n      LNode.prototype.getHalfTheDiagonal = function () {\n        return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n      };\n\n      LNode.prototype.setRect = function (upperLeft, dimension) {\n        this.rect.x = upperLeft.x;\n        this.rect.y = upperLeft.y;\n        this.rect.width = dimension.width;\n        this.rect.height = dimension.height;\n      };\n\n      LNode.prototype.setCenter = function (cx, cy) {\n        this.rect.x = cx - this.rect.width / 2;\n        this.rect.y = cy - this.rect.height / 2;\n      };\n\n      LNode.prototype.setLocation = function (x, y) {\n        this.rect.x = x;\n        this.rect.y = y;\n      };\n\n      LNode.prototype.moveBy = function (dx, dy) {\n        this.rect.x += dx;\n        this.rect.y += dy;\n      };\n\n      LNode.prototype.getEdgeListToNode = function (to) {\n        var edgeList = [];\n        var edge;\n        var self = this;\n        self.edges.forEach(function (edge) {\n          if (edge.target == to) {\n            if (edge.source != self) throw \"Incorrect edge source!\";\n            edgeList.push(edge);\n          }\n        });\n        return edgeList;\n      };\n\n      LNode.prototype.getEdgesBetween = function (other) {\n        var edgeList = [];\n        var edge;\n        var self = this;\n        self.edges.forEach(function (edge) {\n          if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n          if (edge.target == other || edge.source == other) {\n            edgeList.push(edge);\n          }\n        });\n        return edgeList;\n      };\n\n      LNode.prototype.getNeighborsList = function () {\n        var neighbors = new Set();\n        var self = this;\n        self.edges.forEach(function (edge) {\n          if (edge.source == self) {\n            neighbors.add(edge.target);\n          } else {\n            if (edge.target != self) {\n              throw \"Incorrect incidency!\";\n            }\n\n            neighbors.add(edge.source);\n          }\n        });\n        return neighbors;\n      };\n\n      LNode.prototype.withChildren = function () {\n        var withNeighborsList = new Set();\n        var childNode;\n        var children;\n        withNeighborsList.add(this);\n\n        if (this.child != null) {\n          var nodes = this.child.getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            childNode = nodes[i];\n            children = childNode.withChildren();\n            children.forEach(function (node) {\n              withNeighborsList.add(node);\n            });\n          }\n        }\n\n        return withNeighborsList;\n      };\n\n      LNode.prototype.getNoOfChildren = function () {\n        var noOfChildren = 0;\n        var childNode;\n\n        if (this.child == null) {\n          noOfChildren = 1;\n        } else {\n          var nodes = this.child.getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            childNode = nodes[i];\n            noOfChildren += childNode.getNoOfChildren();\n          }\n        }\n\n        if (noOfChildren == 0) {\n          noOfChildren = 1;\n        }\n\n        return noOfChildren;\n      };\n\n      LNode.prototype.getEstimatedSize = function () {\n        if (this.estimatedSize == Integer.MIN_VALUE) {\n          throw \"assert failed\";\n        }\n\n        return this.estimatedSize;\n      };\n\n      LNode.prototype.calcEstimatedSize = function () {\n        if (this.child == null) {\n          return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n        } else {\n          this.estimatedSize = this.child.calcEstimatedSize();\n          this.rect.width = this.estimatedSize;\n          this.rect.height = this.estimatedSize;\n          return this.estimatedSize;\n        }\n      };\n\n      LNode.prototype.scatter = function () {\n        var randomCenterX;\n        var randomCenterY;\n        var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n        var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n        randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n        this.rect.x = randomCenterX;\n        this.rect.y = randomCenterY;\n      };\n\n      LNode.prototype.updateBounds = function () {\n        if (this.getChild() == null) {\n          throw \"assert failed\";\n        }\n\n        if (this.getChild().getNodes().length != 0) {\n          // wrap the children nodes by re-arranging the boundaries\n          var childGraph = this.getChild();\n          childGraph.updateBounds(true);\n          this.rect.x = childGraph.getLeft();\n          this.rect.y = childGraph.getTop();\n          this.setWidth(childGraph.getRight() - childGraph.getLeft());\n          this.setHeight(childGraph.getBottom() - childGraph.getTop()); // Update compound bounds considering its label properties    \n\n          if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n            var width = childGraph.getRight() - childGraph.getLeft();\n            var height = childGraph.getBottom() - childGraph.getTop();\n\n            if (this.labelWidth > width) {\n              this.rect.x -= (this.labelWidth - width) / 2;\n              this.setWidth(this.labelWidth);\n            }\n\n            if (this.labelHeight > height) {\n              if (this.labelPos == \"center\") {\n                this.rect.y -= (this.labelHeight - height) / 2;\n              } else if (this.labelPos == \"top\") {\n                this.rect.y -= this.labelHeight - height;\n              }\n\n              this.setHeight(this.labelHeight);\n            }\n          }\n        }\n      };\n\n      LNode.prototype.getInclusionTreeDepth = function () {\n        if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n          throw \"assert failed\";\n        }\n\n        return this.inclusionTreeDepth;\n      };\n\n      LNode.prototype.transform = function (trans) {\n        var left = this.rect.x;\n\n        if (left > LayoutConstants.WORLD_BOUNDARY) {\n          left = LayoutConstants.WORLD_BOUNDARY;\n        } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n          left = -LayoutConstants.WORLD_BOUNDARY;\n        }\n\n        var top = this.rect.y;\n\n        if (top > LayoutConstants.WORLD_BOUNDARY) {\n          top = LayoutConstants.WORLD_BOUNDARY;\n        } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n          top = -LayoutConstants.WORLD_BOUNDARY;\n        }\n\n        var leftTop = new PointD(left, top);\n        var vLeftTop = trans.inverseTransformPoint(leftTop);\n        this.setLocation(vLeftTop.x, vLeftTop.y);\n      };\n\n      LNode.prototype.getLeft = function () {\n        return this.rect.x;\n      };\n\n      LNode.prototype.getRight = function () {\n        return this.rect.x + this.rect.width;\n      };\n\n      LNode.prototype.getTop = function () {\n        return this.rect.y;\n      };\n\n      LNode.prototype.getBottom = function () {\n        return this.rect.y + this.rect.height;\n      };\n\n      LNode.prototype.getParent = function () {\n        if (this.owner == null) {\n          return null;\n        }\n\n        return this.owner.getParent();\n      };\n\n      module.exports = LNode;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function PointD(x, y) {\n        if (x == null && y == null) {\n          this.x = 0;\n          this.y = 0;\n        } else {\n          this.x = x;\n          this.y = y;\n        }\n      }\n\n      PointD.prototype.getX = function () {\n        return this.x;\n      };\n\n      PointD.prototype.getY = function () {\n        return this.y;\n      };\n\n      PointD.prototype.setX = function (x) {\n        this.x = x;\n      };\n\n      PointD.prototype.setY = function (y) {\n        this.y = y;\n      };\n\n      PointD.prototype.getDifference = function (pt) {\n        return new DimensionD(this.x - pt.x, this.y - pt.y);\n      };\n\n      PointD.prototype.getCopy = function () {\n        return new PointD(this.x, this.y);\n      };\n\n      PointD.prototype.translate = function (dim) {\n        this.x += dim.width;\n        this.y += dim.height;\n        return this;\n      };\n\n      module.exports = PointD;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphObject = __webpack_require__(2);\n\n      var Integer = __webpack_require__(10);\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var LGraphManager = __webpack_require__(6);\n\n      var LNode = __webpack_require__(3);\n\n      var LEdge = __webpack_require__(1);\n\n      var RectangleD = __webpack_require__(13);\n\n      var Point = __webpack_require__(12);\n\n      var LinkedList = __webpack_require__(11);\n\n      function LGraph(parent, obj2, vGraph) {\n        LGraphObject.call(this, vGraph);\n        this.estimatedSize = Integer.MIN_VALUE;\n        this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n        this.edges = [];\n        this.nodes = [];\n        this.isConnected = false;\n        this.parent = parent;\n\n        if (obj2 != null && obj2 instanceof LGraphManager) {\n          this.graphManager = obj2;\n        } else if (obj2 != null && obj2 instanceof Layout) {\n          this.graphManager = obj2.graphManager;\n        }\n      }\n\n      LGraph.prototype = Object.create(LGraphObject.prototype);\n\n      for (var prop in LGraphObject) {\n        LGraph[prop] = LGraphObject[prop];\n      }\n\n      LGraph.prototype.getNodes = function () {\n        return this.nodes;\n      };\n\n      LGraph.prototype.getEdges = function () {\n        return this.edges;\n      };\n\n      LGraph.prototype.getGraphManager = function () {\n        return this.graphManager;\n      };\n\n      LGraph.prototype.getParent = function () {\n        return this.parent;\n      };\n\n      LGraph.prototype.getLeft = function () {\n        return this.left;\n      };\n\n      LGraph.prototype.getRight = function () {\n        return this.right;\n      };\n\n      LGraph.prototype.getTop = function () {\n        return this.top;\n      };\n\n      LGraph.prototype.getBottom = function () {\n        return this.bottom;\n      };\n\n      LGraph.prototype.isConnected = function () {\n        return this.isConnected;\n      };\n\n      LGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n        if (sourceNode == null && targetNode == null) {\n          var newNode = obj1;\n\n          if (this.graphManager == null) {\n            throw \"Graph has no graph mgr!\";\n          }\n\n          if (this.getNodes().indexOf(newNode) > -1) {\n            throw \"Node already in graph!\";\n          }\n\n          newNode.owner = this;\n          this.getNodes().push(newNode);\n          return newNode;\n        } else {\n          var newEdge = obj1;\n\n          if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n            throw \"Source or target not in graph!\";\n          }\n\n          if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n            throw \"Both owners must be this graph!\";\n          }\n\n          if (sourceNode.owner != targetNode.owner) {\n            return null;\n          } // set source and target\n\n\n          newEdge.source = sourceNode;\n          newEdge.target = targetNode; // set as intra-graph edge\n\n          newEdge.isInterGraph = false; // add to graph edge list\n\n          this.getEdges().push(newEdge); // add to incidency lists\n\n          sourceNode.edges.push(newEdge);\n\n          if (targetNode != sourceNode) {\n            targetNode.edges.push(newEdge);\n          }\n\n          return newEdge;\n        }\n      };\n\n      LGraph.prototype.remove = function (obj) {\n        var node = obj;\n\n        if (obj instanceof LNode) {\n          if (node == null) {\n            throw \"Node is null!\";\n          }\n\n          if (!(node.owner != null && node.owner == this)) {\n            throw \"Owner graph is invalid!\";\n          }\n\n          if (this.graphManager == null) {\n            throw \"Owner graph manager is invalid!\";\n          } // remove incident edges first (make a copy to do it safely)\n\n\n          var edgesToBeRemoved = node.edges.slice();\n          var edge;\n          var s = edgesToBeRemoved.length;\n\n          for (var i = 0; i < s; i++) {\n            edge = edgesToBeRemoved[i];\n\n            if (edge.isInterGraph) {\n              this.graphManager.remove(edge);\n            } else {\n              edge.source.owner.remove(edge);\n            }\n          } // now the node itself\n\n\n          var index = this.nodes.indexOf(node);\n\n          if (index == -1) {\n            throw \"Node not in owner node list!\";\n          }\n\n          this.nodes.splice(index, 1);\n        } else if (obj instanceof LEdge) {\n          var edge = obj;\n\n          if (edge == null) {\n            throw \"Edge is null!\";\n          }\n\n          if (!(edge.source != null && edge.target != null)) {\n            throw \"Source and/or target is null!\";\n          }\n\n          if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n            throw \"Source and/or target owner is invalid!\";\n          }\n\n          var sourceIndex = edge.source.edges.indexOf(edge);\n          var targetIndex = edge.target.edges.indexOf(edge);\n\n          if (!(sourceIndex > -1 && targetIndex > -1)) {\n            throw \"Source and/or target doesn't know this edge!\";\n          }\n\n          edge.source.edges.splice(sourceIndex, 1);\n\n          if (edge.target != edge.source) {\n            edge.target.edges.splice(targetIndex, 1);\n          }\n\n          var index = edge.source.owner.getEdges().indexOf(edge);\n\n          if (index == -1) {\n            throw \"Not in owner's edge list!\";\n          }\n\n          edge.source.owner.getEdges().splice(index, 1);\n        }\n      };\n\n      LGraph.prototype.updateLeftTop = function () {\n        var top = Integer.MAX_VALUE;\n        var left = Integer.MAX_VALUE;\n        var nodeTop;\n        var nodeLeft;\n        var margin;\n        var nodes = this.getNodes();\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n          nodeTop = lNode.getTop();\n          nodeLeft = lNode.getLeft();\n\n          if (top > nodeTop) {\n            top = nodeTop;\n          }\n\n          if (left > nodeLeft) {\n            left = nodeLeft;\n          }\n        } // Do we have any nodes in this graph?\n\n\n        if (top == Integer.MAX_VALUE) {\n          return null;\n        }\n\n        if (nodes[0].getParent().paddingLeft != undefined) {\n          margin = nodes[0].getParent().paddingLeft;\n        } else {\n          margin = this.margin;\n        }\n\n        this.left = left - margin;\n        this.top = top - margin; // Apply the margins and return the result\n\n        return new Point(this.left, this.top);\n      };\n\n      LGraph.prototype.updateBounds = function (recursive) {\n        // calculate bounds\n        var left = Integer.MAX_VALUE;\n        var right = -Integer.MAX_VALUE;\n        var top = Integer.MAX_VALUE;\n        var bottom = -Integer.MAX_VALUE;\n        var nodeLeft;\n        var nodeRight;\n        var nodeTop;\n        var nodeBottom;\n        var margin;\n        var nodes = this.nodes;\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n\n          if (recursive && lNode.child != null) {\n            lNode.updateBounds();\n          }\n\n          nodeLeft = lNode.getLeft();\n          nodeRight = lNode.getRight();\n          nodeTop = lNode.getTop();\n          nodeBottom = lNode.getBottom();\n\n          if (left > nodeLeft) {\n            left = nodeLeft;\n          }\n\n          if (right < nodeRight) {\n            right = nodeRight;\n          }\n\n          if (top > nodeTop) {\n            top = nodeTop;\n          }\n\n          if (bottom < nodeBottom) {\n            bottom = nodeBottom;\n          }\n        }\n\n        var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n        if (left == Integer.MAX_VALUE) {\n          this.left = this.parent.getLeft();\n          this.right = this.parent.getRight();\n          this.top = this.parent.getTop();\n          this.bottom = this.parent.getBottom();\n        }\n\n        if (nodes[0].getParent().paddingLeft != undefined) {\n          margin = nodes[0].getParent().paddingLeft;\n        } else {\n          margin = this.margin;\n        }\n\n        this.left = boundingRect.x - margin;\n        this.right = boundingRect.x + boundingRect.width + margin;\n        this.top = boundingRect.y - margin;\n        this.bottom = boundingRect.y + boundingRect.height + margin;\n      };\n\n      LGraph.calculateBounds = function (nodes) {\n        var left = Integer.MAX_VALUE;\n        var right = -Integer.MAX_VALUE;\n        var top = Integer.MAX_VALUE;\n        var bottom = -Integer.MAX_VALUE;\n        var nodeLeft;\n        var nodeRight;\n        var nodeTop;\n        var nodeBottom;\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n          nodeLeft = lNode.getLeft();\n          nodeRight = lNode.getRight();\n          nodeTop = lNode.getTop();\n          nodeBottom = lNode.getBottom();\n\n          if (left > nodeLeft) {\n            left = nodeLeft;\n          }\n\n          if (right < nodeRight) {\n            right = nodeRight;\n          }\n\n          if (top > nodeTop) {\n            top = nodeTop;\n          }\n\n          if (bottom < nodeBottom) {\n            bottom = nodeBottom;\n          }\n        }\n\n        var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n        return boundingRect;\n      };\n\n      LGraph.prototype.getInclusionTreeDepth = function () {\n        if (this == this.graphManager.getRoot()) {\n          return 1;\n        } else {\n          return this.parent.getInclusionTreeDepth();\n        }\n      };\n\n      LGraph.prototype.getEstimatedSize = function () {\n        if (this.estimatedSize == Integer.MIN_VALUE) {\n          throw \"assert failed\";\n        }\n\n        return this.estimatedSize;\n      };\n\n      LGraph.prototype.calcEstimatedSize = function () {\n        var size = 0;\n        var nodes = this.nodes;\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          var lNode = nodes[i];\n          size += lNode.calcEstimatedSize();\n        }\n\n        if (size == 0) {\n          this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n        } else {\n          this.estimatedSize = size / Math.sqrt(this.nodes.length);\n        }\n\n        return this.estimatedSize;\n      };\n\n      LGraph.prototype.updateConnected = function () {\n        var self = this;\n\n        if (this.nodes.length == 0) {\n          this.isConnected = true;\n          return;\n        }\n\n        var queue = new LinkedList();\n        var visited = new Set();\n        var currentNode = this.nodes[0];\n        var neighborEdges;\n        var currentNeighbor;\n        var childrenOfNode = currentNode.withChildren();\n        childrenOfNode.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n\n        while (queue.length !== 0) {\n          currentNode = queue.shift(); // Traverse all neighbors of this node\n\n          neighborEdges = currentNode.getEdges();\n          var size = neighborEdges.length;\n\n          for (var i = 0; i < size; i++) {\n            var neighborEdge = neighborEdges[i];\n            currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this); // Add unvisited neighbors to the list to visit\n\n            if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n              var childrenOfNeighbor = currentNeighbor.withChildren();\n              childrenOfNeighbor.forEach(function (node) {\n                queue.push(node);\n                visited.add(node);\n              });\n            }\n          }\n        }\n\n        this.isConnected = false;\n\n        if (visited.size >= this.nodes.length) {\n          var noOfVisitedInThisGraph = 0;\n          visited.forEach(function (visitedNode) {\n            if (visitedNode.owner == self) {\n              noOfVisitedInThisGraph++;\n            }\n          });\n\n          if (noOfVisitedInThisGraph == this.nodes.length) {\n            this.isConnected = true;\n          }\n        }\n      };\n\n      module.exports = LGraph;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraph;\n\n      var LEdge = __webpack_require__(1);\n\n      function LGraphManager(layout) {\n        LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n\n        this.layout = layout;\n        this.graphs = [];\n        this.edges = [];\n      }\n\n      LGraphManager.prototype.addRoot = function () {\n        var ngraph = this.layout.newGraph();\n        var nnode = this.layout.newNode(null);\n        var root = this.add(ngraph, nnode);\n        this.setRootGraph(root);\n        return this.rootGraph;\n      };\n\n      LGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n        //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n        if (newEdge == null && sourceNode == null && targetNode == null) {\n          if (newGraph == null) {\n            throw \"Graph is null!\";\n          }\n\n          if (parentNode == null) {\n            throw \"Parent node is null!\";\n          }\n\n          if (this.graphs.indexOf(newGraph) > -1) {\n            throw \"Graph already in this graph mgr!\";\n          }\n\n          this.graphs.push(newGraph);\n\n          if (newGraph.parent != null) {\n            throw \"Already has a parent!\";\n          }\n\n          if (parentNode.child != null) {\n            throw \"Already has a child!\";\n          }\n\n          newGraph.parent = parentNode;\n          parentNode.child = newGraph;\n          return newGraph;\n        } else {\n          //change the order of the parameters\n          targetNode = newEdge;\n          sourceNode = parentNode;\n          newEdge = newGraph;\n          var sourceGraph = sourceNode.getOwner();\n          var targetGraph = targetNode.getOwner();\n\n          if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n            throw \"Source not in this graph mgr!\";\n          }\n\n          if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n            throw \"Target not in this graph mgr!\";\n          }\n\n          if (sourceGraph == targetGraph) {\n            newEdge.isInterGraph = false;\n            return sourceGraph.add(newEdge, sourceNode, targetNode);\n          } else {\n            newEdge.isInterGraph = true; // set source and target\n\n            newEdge.source = sourceNode;\n            newEdge.target = targetNode; // add edge to inter-graph edge list\n\n            if (this.edges.indexOf(newEdge) > -1) {\n              throw \"Edge already in inter-graph edge list!\";\n            }\n\n            this.edges.push(newEdge); // add edge to source and target incidency lists\n\n            if (!(newEdge.source != null && newEdge.target != null)) {\n              throw \"Edge source and/or target is null!\";\n            }\n\n            if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n              throw \"Edge already in source and/or target incidency list!\";\n            }\n\n            newEdge.source.edges.push(newEdge);\n            newEdge.target.edges.push(newEdge);\n            return newEdge;\n          }\n        }\n      };\n\n      LGraphManager.prototype.remove = function (lObj) {\n        if (lObj instanceof LGraph) {\n          var graph = lObj;\n\n          if (graph.getGraphManager() != this) {\n            throw \"Graph not in this graph mgr\";\n          }\n\n          if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n            throw \"Invalid parent node!\";\n          } // first the edges (make a copy to do it safely)\n\n\n          var edgesToBeRemoved = [];\n          edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n          var edge;\n          var s = edgesToBeRemoved.length;\n\n          for (var i = 0; i < s; i++) {\n            edge = edgesToBeRemoved[i];\n            graph.remove(edge);\n          } // then the nodes (make a copy to do it safely)\n\n\n          var nodesToBeRemoved = [];\n          nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n          var node;\n          s = nodesToBeRemoved.length;\n\n          for (var i = 0; i < s; i++) {\n            node = nodesToBeRemoved[i];\n            graph.remove(node);\n          } // check if graph is the root\n\n\n          if (graph == this.rootGraph) {\n            this.setRootGraph(null);\n          } // now remove the graph itself\n\n\n          var index = this.graphs.indexOf(graph);\n          this.graphs.splice(index, 1); // also reset the parent of the graph\n\n          graph.parent = null;\n        } else if (lObj instanceof LEdge) {\n          edge = lObj;\n\n          if (edge == null) {\n            throw \"Edge is null!\";\n          }\n\n          if (!edge.isInterGraph) {\n            throw \"Not an inter-graph edge!\";\n          }\n\n          if (!(edge.source != null && edge.target != null)) {\n            throw \"Source and/or target is null!\";\n          } // remove edge from source and target nodes' incidency lists\n\n\n          if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n            throw \"Source and/or target doesn't know this edge!\";\n          }\n\n          var index = edge.source.edges.indexOf(edge);\n          edge.source.edges.splice(index, 1);\n          index = edge.target.edges.indexOf(edge);\n          edge.target.edges.splice(index, 1); // remove edge from owner graph manager's inter-graph edge list\n\n          if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n            throw \"Edge owner graph or owner graph manager is null!\";\n          }\n\n          if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n            throw \"Not in owner graph manager's edge list!\";\n          }\n\n          var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n          edge.source.owner.getGraphManager().edges.splice(index, 1);\n        }\n      };\n\n      LGraphManager.prototype.updateBounds = function () {\n        this.rootGraph.updateBounds(true);\n      };\n\n      LGraphManager.prototype.getGraphs = function () {\n        return this.graphs;\n      };\n\n      LGraphManager.prototype.getAllNodes = function () {\n        if (this.allNodes == null) {\n          var nodeList = [];\n          var graphs = this.getGraphs();\n          var s = graphs.length;\n\n          for (var i = 0; i < s; i++) {\n            nodeList = nodeList.concat(graphs[i].getNodes());\n          }\n\n          this.allNodes = nodeList;\n        }\n\n        return this.allNodes;\n      };\n\n      LGraphManager.prototype.resetAllNodes = function () {\n        this.allNodes = null;\n      };\n\n      LGraphManager.prototype.resetAllEdges = function () {\n        this.allEdges = null;\n      };\n\n      LGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n        this.allNodesToApplyGravitation = null;\n      };\n\n      LGraphManager.prototype.getAllEdges = function () {\n        if (this.allEdges == null) {\n          var edgeList = [];\n          var graphs = this.getGraphs();\n          var s = graphs.length;\n\n          for (var i = 0; i < graphs.length; i++) {\n            edgeList = edgeList.concat(graphs[i].getEdges());\n          }\n\n          edgeList = edgeList.concat(this.edges);\n          this.allEdges = edgeList;\n        }\n\n        return this.allEdges;\n      };\n\n      LGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n        return this.allNodesToApplyGravitation;\n      };\n\n      LGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n        if (this.allNodesToApplyGravitation != null) {\n          throw \"assert failed\";\n        }\n\n        this.allNodesToApplyGravitation = nodeList;\n      };\n\n      LGraphManager.prototype.getRoot = function () {\n        return this.rootGraph;\n      };\n\n      LGraphManager.prototype.setRootGraph = function (graph) {\n        if (graph.getGraphManager() != this) {\n          throw \"Root not in this graph mgr!\";\n        }\n\n        this.rootGraph = graph; // root graph must have a root node associated with it for convenience\n\n        if (graph.parent == null) {\n          graph.parent = this.layout.newNode(\"Root node\");\n        }\n      };\n\n      LGraphManager.prototype.getLayout = function () {\n        return this.layout;\n      };\n\n      LGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n        if (!(firstNode != null && secondNode != null)) {\n          throw \"assert failed\";\n        }\n\n        if (firstNode == secondNode) {\n          return true;\n        } // Is second node an ancestor of the first one?\n\n\n        var ownerGraph = firstNode.getOwner();\n        var parentNode;\n\n        do {\n          parentNode = ownerGraph.getParent();\n\n          if (parentNode == null) {\n            break;\n          }\n\n          if (parentNode == secondNode) {\n            return true;\n          }\n\n          ownerGraph = parentNode.getOwner();\n\n          if (ownerGraph == null) {\n            break;\n          }\n        } while (true); // Is first node an ancestor of the second one?\n\n\n        ownerGraph = secondNode.getOwner();\n\n        do {\n          parentNode = ownerGraph.getParent();\n\n          if (parentNode == null) {\n            break;\n          }\n\n          if (parentNode == firstNode) {\n            return true;\n          }\n\n          ownerGraph = parentNode.getOwner();\n\n          if (ownerGraph == null) {\n            break;\n          }\n        } while (true);\n\n        return false;\n      };\n\n      LGraphManager.prototype.calcLowestCommonAncestors = function () {\n        var edge;\n        var sourceNode;\n        var targetNode;\n        var sourceAncestorGraph;\n        var targetAncestorGraph;\n        var edges = this.getAllEdges();\n        var s = edges.length;\n\n        for (var i = 0; i < s; i++) {\n          edge = edges[i];\n          sourceNode = edge.source;\n          targetNode = edge.target;\n          edge.lca = null;\n          edge.sourceInLca = sourceNode;\n          edge.targetInLca = targetNode;\n\n          if (sourceNode == targetNode) {\n            edge.lca = sourceNode.getOwner();\n            continue;\n          }\n\n          sourceAncestorGraph = sourceNode.getOwner();\n\n          while (edge.lca == null) {\n            edge.targetInLca = targetNode;\n            targetAncestorGraph = targetNode.getOwner();\n\n            while (edge.lca == null) {\n              if (targetAncestorGraph == sourceAncestorGraph) {\n                edge.lca = targetAncestorGraph;\n                break;\n              }\n\n              if (targetAncestorGraph == this.rootGraph) {\n                break;\n              }\n\n              if (edge.lca != null) {\n                throw \"assert failed\";\n              }\n\n              edge.targetInLca = targetAncestorGraph.getParent();\n              targetAncestorGraph = edge.targetInLca.getOwner();\n            }\n\n            if (sourceAncestorGraph == this.rootGraph) {\n              break;\n            }\n\n            if (edge.lca == null) {\n              edge.sourceInLca = sourceAncestorGraph.getParent();\n              sourceAncestorGraph = edge.sourceInLca.getOwner();\n            }\n          }\n\n          if (edge.lca == null) {\n            throw \"assert failed\";\n          }\n        }\n      };\n\n      LGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n        if (firstNode == secondNode) {\n          return firstNode.getOwner();\n        }\n\n        var firstOwnerGraph = firstNode.getOwner();\n\n        do {\n          if (firstOwnerGraph == null) {\n            break;\n          }\n\n          var secondOwnerGraph = secondNode.getOwner();\n\n          do {\n            if (secondOwnerGraph == null) {\n              break;\n            }\n\n            if (secondOwnerGraph == firstOwnerGraph) {\n              return secondOwnerGraph;\n            }\n\n            secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n          } while (true);\n\n          firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n        } while (true);\n\n        return firstOwnerGraph;\n      };\n\n      LGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n        if (graph == null && depth == null) {\n          graph = this.rootGraph;\n          depth = 1;\n        }\n\n        var node;\n        var nodes = graph.getNodes();\n        var s = nodes.length;\n\n        for (var i = 0; i < s; i++) {\n          node = nodes[i];\n          node.inclusionTreeDepth = depth;\n\n          if (node.child != null) {\n            this.calcInclusionTreeDepths(node.child, depth + 1);\n          }\n        }\n      };\n\n      LGraphManager.prototype.includesInvalidEdge = function () {\n        var edge;\n        var s = this.edges.length;\n\n        for (var i = 0; i < s; i++) {\n          edge = this.edges[i];\n\n          if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      module.exports = LGraphManager;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LayoutConstants = __webpack_require__(0);\n\n      function FDLayoutConstants() {} //FDLayoutConstants inherits static props in LayoutConstants\n\n\n      for (var prop in LayoutConstants) {\n        FDLayoutConstants[prop] = LayoutConstants[prop];\n      }\n\n      FDLayoutConstants.MAX_ITERATIONS = 2500;\n      FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n      FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\n      FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n      FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\n      FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n      FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n      FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n      FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n      FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n      FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n      FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\n      FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\n      FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\n      FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n      FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n      FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n      FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n      FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n      module.exports = FDLayoutConstants;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /**\n       * This class maintains a list of static geometry related utility methods.\n       *\n       *\n       * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n       */\n\n      var Point = __webpack_require__(12);\n\n      function IGeometry() {}\n      /**\n       * This method calculates *half* the amount in x and y directions of the two\n       * input rectangles needed to separate them keeping their respective\n       * positioning, and returns the result in the input array. An input\n       * separation buffer added to the amount in both directions. We assume that\n       * the two rectangles do intersect.\n       */\n\n\n      IGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n        if (!rectA.intersects(rectB)) {\n          throw \"assert failed\";\n        }\n\n        var directions = new Array(2);\n        this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n        overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n        overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y); // update the overlapping amounts for the following cases:\n\n        if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n          /* Case x.1:\n          *\n          * rectA\n          * \t|                       |\n          * \t|        _________      |\n          * \t|        |       |      |\n          * \t|________|_______|______|\n          * \t\t\t |       |\n          *           |       |\n          *        rectB\n          */\n          overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n        } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n          /* Case x.2:\n          *\n          * rectB\n          * \t|                       |\n          * \t|        _________      |\n          * \t|        |       |      |\n          * \t|________|_______|______|\n          * \t\t\t |       |\n          *           |       |\n          *        rectA\n          */\n          overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n        }\n\n        if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n          /* Case y.1:\n           *          ________ rectA\n           *         |\n           *         |\n           *   ______|____  rectB\n           *         |    |\n           *         |    |\n           *   ______|____|\n           *         |\n           *         |\n           *         |________\n           *\n           */\n          overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n        } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n          /* Case y.2:\n          *          ________ rectB\n          *         |\n          *         |\n          *   ______|____  rectA\n          *         |    |\n          *         |    |\n          *   ______|____|\n          *         |\n          *         |\n          *         |________\n          *\n          */\n          overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n        } // find slope of the line passes two centers\n\n\n        var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX())); // if centers are overlapped\n\n        if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n          // assume the slope is 1 (45 degree)\n          slope = 1.0;\n        }\n\n        var moveByY = slope * overlapAmount[0];\n        var moveByX = overlapAmount[1] / slope;\n\n        if (overlapAmount[0] < moveByX) {\n          moveByX = overlapAmount[0];\n        } else {\n          moveByY = overlapAmount[1];\n        } // return half the amount so that if each rectangle is moved by these\n        // amounts in opposite directions, overlap will be resolved\n\n\n        overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n        overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n      };\n      /**\n       * This method decides the separation direction of overlapping nodes\n       *\n       * if directions[0] = -1, then rectA goes left\n       * if directions[0] = 1,  then rectA goes right\n       * if directions[1] = -1, then rectA goes up\n       * if directions[1] = 1,  then rectA goes down\n       */\n\n\n      IGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n        if (rectA.getCenterX() < rectB.getCenterX()) {\n          directions[0] = -1;\n        } else {\n          directions[0] = 1;\n        }\n\n        if (rectA.getCenterY() < rectB.getCenterY()) {\n          directions[1] = -1;\n        } else {\n          directions[1] = 1;\n        }\n      };\n      /**\n       * This method calculates the intersection (clipping) points of the two\n       * input rectangles with line segment defined by the centers of these two\n       * rectangles. The clipping points are saved in the input double array and\n       * whether or not the two rectangles overlap is returned.\n       */\n\n\n      IGeometry.getIntersection2 = function (rectA, rectB, result) {\n        //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n        var p1x = rectA.getCenterX();\n        var p1y = rectA.getCenterY();\n        var p2x = rectB.getCenterX();\n        var p2y = rectB.getCenterY(); //if two rectangles intersect, then clipping points are centers\n\n        if (rectA.intersects(rectB)) {\n          result[0] = p1x;\n          result[1] = p1y;\n          result[2] = p2x;\n          result[3] = p2y;\n          return true;\n        } //variables for rectA\n\n\n        var topLeftAx = rectA.getX();\n        var topLeftAy = rectA.getY();\n        var topRightAx = rectA.getRight();\n        var bottomLeftAx = rectA.getX();\n        var bottomLeftAy = rectA.getBottom();\n        var bottomRightAx = rectA.getRight();\n        var halfWidthA = rectA.getWidthHalf();\n        var halfHeightA = rectA.getHeightHalf(); //variables for rectB\n\n        var topLeftBx = rectB.getX();\n        var topLeftBy = rectB.getY();\n        var topRightBx = rectB.getRight();\n        var bottomLeftBx = rectB.getX();\n        var bottomLeftBy = rectB.getBottom();\n        var bottomRightBx = rectB.getRight();\n        var halfWidthB = rectB.getWidthHalf();\n        var halfHeightB = rectB.getHeightHalf(); //flag whether clipping points are found\n\n        var clipPointAFound = false;\n        var clipPointBFound = false; // line is vertical\n\n        if (p1x === p2x) {\n          if (p1y > p2y) {\n            result[0] = p1x;\n            result[1] = topLeftAy;\n            result[2] = p2x;\n            result[3] = bottomLeftBy;\n            return false;\n          } else if (p1y < p2y) {\n            result[0] = p1x;\n            result[1] = bottomLeftAy;\n            result[2] = p2x;\n            result[3] = topLeftBy;\n            return false;\n          } else {//not line, return null;\n          }\n        } // line is horizontal\n        else if (p1y === p2y) {\n            if (p1x > p2x) {\n              result[0] = topLeftAx;\n              result[1] = p1y;\n              result[2] = topRightBx;\n              result[3] = p2y;\n              return false;\n            } else if (p1x < p2x) {\n              result[0] = topRightAx;\n              result[1] = p1y;\n              result[2] = topLeftBx;\n              result[3] = p2y;\n              return false;\n            } else {//not valid line, return null;\n            }\n          } else {\n            //slopes of rectA's and rectB's diagonals\n            var slopeA = rectA.height / rectA.width;\n            var slopeB = rectB.height / rectB.width; //slope of line between center of rectA and center of rectB\n\n            var slopePrime = (p2y - p1y) / (p2x - p1x);\n            var cardinalDirectionA = void 0;\n            var cardinalDirectionB = void 0;\n            var tempPointAx = void 0;\n            var tempPointAy = void 0;\n            var tempPointBx = void 0;\n            var tempPointBy = void 0; //determine whether clipping point is the corner of nodeA\n\n            if (-slopeA === slopePrime) {\n              if (p1x > p2x) {\n                result[0] = bottomLeftAx;\n                result[1] = bottomLeftAy;\n                clipPointAFound = true;\n              } else {\n                result[0] = topRightAx;\n                result[1] = topLeftAy;\n                clipPointAFound = true;\n              }\n            } else if (slopeA === slopePrime) {\n              if (p1x > p2x) {\n                result[0] = topLeftAx;\n                result[1] = topLeftAy;\n                clipPointAFound = true;\n              } else {\n                result[0] = bottomRightAx;\n                result[1] = bottomLeftAy;\n                clipPointAFound = true;\n              }\n            } //determine whether clipping point is the corner of nodeB\n\n\n            if (-slopeB === slopePrime) {\n              if (p2x > p1x) {\n                result[2] = bottomLeftBx;\n                result[3] = bottomLeftBy;\n                clipPointBFound = true;\n              } else {\n                result[2] = topRightBx;\n                result[3] = topLeftBy;\n                clipPointBFound = true;\n              }\n            } else if (slopeB === slopePrime) {\n              if (p2x > p1x) {\n                result[2] = topLeftBx;\n                result[3] = topLeftBy;\n                clipPointBFound = true;\n              } else {\n                result[2] = bottomRightBx;\n                result[3] = bottomLeftBy;\n                clipPointBFound = true;\n              }\n            } //if both clipping points are corners\n\n\n            if (clipPointAFound && clipPointBFound) {\n              return false;\n            } //determine Cardinal Direction of rectangles\n\n\n            if (p1x > p2x) {\n              if (p1y > p2y) {\n                cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n                cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n              } else {\n                cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n                cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n              }\n            } else {\n              if (p1y > p2y) {\n                cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n                cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n              } else {\n                cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n                cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n              }\n            } //calculate clipping Point if it is not found before\n\n\n            if (!clipPointAFound) {\n              switch (cardinalDirectionA) {\n                case 1:\n                  tempPointAy = topLeftAy;\n                  tempPointAx = p1x + -halfHeightA / slopePrime;\n                  result[0] = tempPointAx;\n                  result[1] = tempPointAy;\n                  break;\n\n                case 2:\n                  tempPointAx = bottomRightAx;\n                  tempPointAy = p1y + halfWidthA * slopePrime;\n                  result[0] = tempPointAx;\n                  result[1] = tempPointAy;\n                  break;\n\n                case 3:\n                  tempPointAy = bottomLeftAy;\n                  tempPointAx = p1x + halfHeightA / slopePrime;\n                  result[0] = tempPointAx;\n                  result[1] = tempPointAy;\n                  break;\n\n                case 4:\n                  tempPointAx = bottomLeftAx;\n                  tempPointAy = p1y + -halfWidthA * slopePrime;\n                  result[0] = tempPointAx;\n                  result[1] = tempPointAy;\n                  break;\n              }\n            }\n\n            if (!clipPointBFound) {\n              switch (cardinalDirectionB) {\n                case 1:\n                  tempPointBy = topLeftBy;\n                  tempPointBx = p2x + -halfHeightB / slopePrime;\n                  result[2] = tempPointBx;\n                  result[3] = tempPointBy;\n                  break;\n\n                case 2:\n                  tempPointBx = bottomRightBx;\n                  tempPointBy = p2y + halfWidthB * slopePrime;\n                  result[2] = tempPointBx;\n                  result[3] = tempPointBy;\n                  break;\n\n                case 3:\n                  tempPointBy = bottomLeftBy;\n                  tempPointBx = p2x + halfHeightB / slopePrime;\n                  result[2] = tempPointBx;\n                  result[3] = tempPointBy;\n                  break;\n\n                case 4:\n                  tempPointBx = bottomLeftBx;\n                  tempPointBy = p2y + -halfWidthB * slopePrime;\n                  result[2] = tempPointBx;\n                  result[3] = tempPointBy;\n                  break;\n              }\n            }\n          }\n\n        return false;\n      };\n      /**\n       * This method returns in which cardinal direction does input point stays\n       * 1: North\n       * 2: East\n       * 3: South\n       * 4: West\n       */\n\n\n      IGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n        if (slope > slopePrime) {\n          return line;\n        } else {\n          return 1 + line % 4;\n        }\n      };\n      /**\n       * This method calculates the intersection of the two lines defined by\n       * point pairs (s1,s2) and (f1,f2).\n       */\n\n\n      IGeometry.getIntersection = function (s1, s2, f1, f2) {\n        if (f2 == null) {\n          return this.getIntersection2(s1, s2, f1);\n        }\n\n        var x1 = s1.x;\n        var y1 = s1.y;\n        var x2 = s2.x;\n        var y2 = s2.y;\n        var x3 = f1.x;\n        var y3 = f1.y;\n        var x4 = f2.x;\n        var y4 = f2.y;\n        var x = void 0,\n            y = void 0; // intersection point\n\n        var a1 = void 0,\n            a2 = void 0,\n            b1 = void 0,\n            b2 = void 0,\n            c1 = void 0,\n            c2 = void 0; // coefficients of line eqns.\n\n        var denom = void 0;\n        a1 = y2 - y1;\n        b1 = x1 - x2;\n        c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n        a2 = y4 - y3;\n        b2 = x3 - x4;\n        c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n        denom = a1 * b2 - a2 * b1;\n\n        if (denom === 0) {\n          return null;\n        }\n\n        x = (b1 * c2 - b2 * c1) / denom;\n        y = (a2 * c1 - a1 * c2) / denom;\n        return new Point(x, y);\n      };\n      /**\n       * This method finds and returns the angle of the vector from the + x-axis\n       * in clockwise direction (compatible w/ Java coordinate system!).\n       */\n\n\n      IGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n        var C_angle = void 0;\n\n        if (Cx !== Nx) {\n          C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n          if (Nx < Cx) {\n            C_angle += Math.PI;\n          } else if (Ny < Cy) {\n            C_angle += this.TWO_PI;\n          }\n        } else if (Ny < Cy) {\n          C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n        } else {\n          C_angle = this.HALF_PI; // 90 degrees\n        }\n\n        return C_angle;\n      };\n      /**\n       * This method checks whether the given two line segments (one with point\n       * p1 and p2, the other with point p3 and p4) intersect at a point other\n       * than these points.\n       */\n\n\n      IGeometry.doIntersect = function (p1, p2, p3, p4) {\n        var a = p1.x;\n        var b = p1.y;\n        var c = p2.x;\n        var d = p2.y;\n        var p = p3.x;\n        var q = p3.y;\n        var r = p4.x;\n        var s = p4.y;\n        var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n        if (det === 0) {\n          return false;\n        } else {\n          var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n          var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n          return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: Class Constants\n      // -----------------------------------------------------------------------------\n\n      /**\n       * Some useful pre-calculated constants\n       */\n\n\n      IGeometry.HALF_PI = 0.5 * Math.PI;\n      IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n      IGeometry.TWO_PI = 2.0 * Math.PI;\n      IGeometry.THREE_PI = 3.0 * Math.PI;\n      module.exports = IGeometry;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function IMath() {}\n      /**\n       * This method returns the sign of the input value.\n       */\n\n\n      IMath.sign = function (value) {\n        if (value > 0) {\n          return 1;\n        } else if (value < 0) {\n          return -1;\n        } else {\n          return 0;\n        }\n      };\n\n      IMath.floor = function (value) {\n        return value < 0 ? Math.ceil(value) : Math.floor(value);\n      };\n\n      IMath.ceil = function (value) {\n        return value < 0 ? Math.floor(value) : Math.ceil(value);\n      };\n\n      module.exports = IMath;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function Integer() {}\n\n      Integer.MAX_VALUE = 2147483647;\n      Integer.MIN_VALUE = -2147483648;\n      module.exports = Integer;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var nodeFrom = function nodeFrom(value) {\n        return {\n          value: value,\n          next: null,\n          prev: null\n        };\n      };\n\n      var add = function add(prev, node, next, list) {\n        if (prev !== null) {\n          prev.next = node;\n        } else {\n          list.head = node;\n        }\n\n        if (next !== null) {\n          next.prev = node;\n        } else {\n          list.tail = node;\n        }\n\n        node.prev = prev;\n        node.next = next;\n        list.length++;\n        return node;\n      };\n\n      var _remove = function _remove(node, list) {\n        var prev = node.prev,\n            next = node.next;\n\n        if (prev !== null) {\n          prev.next = next;\n        } else {\n          list.head = next;\n        }\n\n        if (next !== null) {\n          next.prev = prev;\n        } else {\n          list.tail = prev;\n        }\n\n        node.prev = node.next = null;\n        list.length--;\n        return node;\n      };\n\n      var LinkedList = function () {\n        function LinkedList(vals) {\n          var _this = this;\n\n          _classCallCheck(this, LinkedList);\n\n          this.length = 0;\n          this.head = null;\n          this.tail = null;\n\n          if (vals != null) {\n            vals.forEach(function (v) {\n              return _this.push(v);\n            });\n          }\n        }\n\n        _createClass(LinkedList, [{\n          key: \"size\",\n          value: function size() {\n            return this.length;\n          }\n        }, {\n          key: \"insertBefore\",\n          value: function insertBefore(val, otherNode) {\n            return add(otherNode.prev, nodeFrom(val), otherNode, this);\n          }\n        }, {\n          key: \"insertAfter\",\n          value: function insertAfter(val, otherNode) {\n            return add(otherNode, nodeFrom(val), otherNode.next, this);\n          }\n        }, {\n          key: \"insertNodeBefore\",\n          value: function insertNodeBefore(newNode, otherNode) {\n            return add(otherNode.prev, newNode, otherNode, this);\n          }\n        }, {\n          key: \"insertNodeAfter\",\n          value: function insertNodeAfter(newNode, otherNode) {\n            return add(otherNode, newNode, otherNode.next, this);\n          }\n        }, {\n          key: \"push\",\n          value: function push(val) {\n            return add(this.tail, nodeFrom(val), null, this);\n          }\n        }, {\n          key: \"unshift\",\n          value: function unshift(val) {\n            return add(null, nodeFrom(val), this.head, this);\n          }\n        }, {\n          key: \"remove\",\n          value: function remove(node) {\n            return _remove(node, this);\n          }\n        }, {\n          key: \"pop\",\n          value: function pop() {\n            return _remove(this.tail, this).value;\n          }\n        }, {\n          key: \"popNode\",\n          value: function popNode() {\n            return _remove(this.tail, this);\n          }\n        }, {\n          key: \"shift\",\n          value: function shift() {\n            return _remove(this.head, this).value;\n          }\n        }, {\n          key: \"shiftNode\",\n          value: function shiftNode() {\n            return _remove(this.head, this);\n          }\n        }, {\n          key: \"get_object_at\",\n          value: function get_object_at(index) {\n            if (index <= this.length()) {\n              var i = 1;\n              var current = this.head;\n\n              while (i < index) {\n                current = current.next;\n                i++;\n              }\n\n              return current.value;\n            }\n          }\n        }, {\n          key: \"set_object_at\",\n          value: function set_object_at(index, value) {\n            if (index <= this.length()) {\n              var i = 1;\n              var current = this.head;\n\n              while (i < index) {\n                current = current.next;\n                i++;\n              }\n\n              current.value = value;\n            }\n          }\n        }]);\n\n        return LinkedList;\n      }();\n\n      module.exports = LinkedList;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /*\r\n       *This class is the javascript implementation of the Point.java class in jdk\r\n       */\n\n      function Point(x, y, p) {\n        this.x = null;\n        this.y = null;\n\n        if (x == null && y == null && p == null) {\n          this.x = 0;\n          this.y = 0;\n        } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n          this.x = x;\n          this.y = y;\n        } else if (x.constructor.name == 'Point' && y == null && p == null) {\n          p = x;\n          this.x = p.x;\n          this.y = p.y;\n        }\n      }\n\n      Point.prototype.getX = function () {\n        return this.x;\n      };\n\n      Point.prototype.getY = function () {\n        return this.y;\n      };\n\n      Point.prototype.getLocation = function () {\n        return new Point(this.x, this.y);\n      };\n\n      Point.prototype.setLocation = function (x, y, p) {\n        if (x.constructor.name == 'Point' && y == null && p == null) {\n          p = x;\n          this.setLocation(p.x, p.y);\n        } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n          //if both parameters are integer just move (x,y) location\n          if (parseInt(x) == x && parseInt(y) == y) {\n            this.move(x, y);\n          } else {\n            this.x = Math.floor(x + 0.5);\n            this.y = Math.floor(y + 0.5);\n          }\n        }\n      };\n\n      Point.prototype.move = function (x, y) {\n        this.x = x;\n        this.y = y;\n      };\n\n      Point.prototype.translate = function (dx, dy) {\n        this.x += dx;\n        this.y += dy;\n      };\n\n      Point.prototype.equals = function (obj) {\n        if (obj.constructor.name == \"Point\") {\n          var pt = obj;\n          return this.x == pt.x && this.y == pt.y;\n        }\n\n        return this == obj;\n      };\n\n      Point.prototype.toString = function () {\n        return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n      };\n\n      module.exports = Point;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function RectangleD(x, y, width, height) {\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n\n        if (x != null && y != null && width != null && height != null) {\n          this.x = x;\n          this.y = y;\n          this.width = width;\n          this.height = height;\n        }\n      }\n\n      RectangleD.prototype.getX = function () {\n        return this.x;\n      };\n\n      RectangleD.prototype.setX = function (x) {\n        this.x = x;\n      };\n\n      RectangleD.prototype.getY = function () {\n        return this.y;\n      };\n\n      RectangleD.prototype.setY = function (y) {\n        this.y = y;\n      };\n\n      RectangleD.prototype.getWidth = function () {\n        return this.width;\n      };\n\n      RectangleD.prototype.setWidth = function (width) {\n        this.width = width;\n      };\n\n      RectangleD.prototype.getHeight = function () {\n        return this.height;\n      };\n\n      RectangleD.prototype.setHeight = function (height) {\n        this.height = height;\n      };\n\n      RectangleD.prototype.getRight = function () {\n        return this.x + this.width;\n      };\n\n      RectangleD.prototype.getBottom = function () {\n        return this.y + this.height;\n      };\n\n      RectangleD.prototype.intersects = function (a) {\n        if (this.getRight() < a.x) {\n          return false;\n        }\n\n        if (this.getBottom() < a.y) {\n          return false;\n        }\n\n        if (a.getRight() < this.x) {\n          return false;\n        }\n\n        if (a.getBottom() < this.y) {\n          return false;\n        }\n\n        return true;\n      };\n\n      RectangleD.prototype.getCenterX = function () {\n        return this.x + this.width / 2;\n      };\n\n      RectangleD.prototype.getMinX = function () {\n        return this.getX();\n      };\n\n      RectangleD.prototype.getMaxX = function () {\n        return this.getX() + this.width;\n      };\n\n      RectangleD.prototype.getCenterY = function () {\n        return this.y + this.height / 2;\n      };\n\n      RectangleD.prototype.getMinY = function () {\n        return this.getY();\n      };\n\n      RectangleD.prototype.getMaxY = function () {\n        return this.getY() + this.height;\n      };\n\n      RectangleD.prototype.getWidthHalf = function () {\n        return this.width / 2;\n      };\n\n      RectangleD.prototype.getHeightHalf = function () {\n        return this.height / 2;\n      };\n\n      module.exports = RectangleD;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      function UniqueIDGeneretor() {}\n\n      UniqueIDGeneretor.lastID = 0;\n\n      UniqueIDGeneretor.createID = function (obj) {\n        if (UniqueIDGeneretor.isPrimitive(obj)) {\n          return obj;\n        }\n\n        if (obj.uniqueID != null) {\n          return obj.uniqueID;\n        }\n\n        obj.uniqueID = UniqueIDGeneretor.getString();\n        UniqueIDGeneretor.lastID++;\n        return obj.uniqueID;\n      };\n\n      UniqueIDGeneretor.getString = function (id) {\n        if (id == null) id = UniqueIDGeneretor.lastID;\n        return \"Object#\" + id + \"\";\n      };\n\n      UniqueIDGeneretor.isPrimitive = function (arg) {\n        var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n        return arg == null || type != \"object\" && type != \"function\";\n      };\n\n      module.exports = UniqueIDGeneretor;\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      }\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var LGraphManager = __webpack_require__(6);\n\n      var LNode = __webpack_require__(3);\n\n      var LEdge = __webpack_require__(1);\n\n      var LGraph = __webpack_require__(5);\n\n      var PointD = __webpack_require__(4);\n\n      var Transform = __webpack_require__(17);\n\n      var Emitter = __webpack_require__(27);\n\n      function Layout(isRemoteUse) {\n        Emitter.call(this); //Layout Quality: 0:draft, 1:default, 2:proof\n\n        this.layoutQuality = LayoutConstants.QUALITY; //Whether layout should create bendpoints as needed or not\n\n        this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED; //Whether layout should be incremental or not\n\n        this.incremental = LayoutConstants.DEFAULT_INCREMENTAL; //Whether we animate from before to after layout node positions\n\n        this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT; //Whether we animate the layout process or not\n\n        this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT; //Number iterations that should be done between two successive animations\n\n        this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n        /**\r\n         * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n         * they are, both spring and repulsion forces between two leaf nodes can be\r\n         * calculated without the expensive clipping point calculations, resulting\r\n         * in major speed-up.\r\n         */\n\n        this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n        /**\r\n         * This is used for creation of bendpoints by using dummy nodes and edges.\r\n         * Maps an LEdge to its dummy bendpoint path.\r\n         */\n\n        this.edgeToDummyNodes = new Map();\n        this.graphManager = new LGraphManager(this);\n        this.isLayoutFinished = false;\n        this.isSubLayout = false;\n        this.isRemoteUse = false;\n\n        if (isRemoteUse != null) {\n          this.isRemoteUse = isRemoteUse;\n        }\n      }\n\n      Layout.RANDOM_SEED = 1;\n      Layout.prototype = Object.create(Emitter.prototype);\n\n      Layout.prototype.getGraphManager = function () {\n        return this.graphManager;\n      };\n\n      Layout.prototype.getAllNodes = function () {\n        return this.graphManager.getAllNodes();\n      };\n\n      Layout.prototype.getAllEdges = function () {\n        return this.graphManager.getAllEdges();\n      };\n\n      Layout.prototype.getAllNodesToApplyGravitation = function () {\n        return this.graphManager.getAllNodesToApplyGravitation();\n      };\n\n      Layout.prototype.newGraphManager = function () {\n        var gm = new LGraphManager(this);\n        this.graphManager = gm;\n        return gm;\n      };\n\n      Layout.prototype.newGraph = function (vGraph) {\n        return new LGraph(null, this.graphManager, vGraph);\n      };\n\n      Layout.prototype.newNode = function (vNode) {\n        return new LNode(this.graphManager, vNode);\n      };\n\n      Layout.prototype.newEdge = function (vEdge) {\n        return new LEdge(null, null, vEdge);\n      };\n\n      Layout.prototype.checkLayoutSuccess = function () {\n        return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n      };\n\n      Layout.prototype.runLayout = function () {\n        this.isLayoutFinished = false;\n\n        if (this.tilingPreLayout) {\n          this.tilingPreLayout();\n        }\n\n        this.initParameters();\n        var isLayoutSuccessfull;\n\n        if (this.checkLayoutSuccess()) {\n          isLayoutSuccessfull = false;\n        } else {\n          isLayoutSuccessfull = this.layout();\n        }\n\n        if (LayoutConstants.ANIMATE === 'during') {\n          // If this is a 'during' layout animation. Layout is not finished yet. \n          // We need to perform these in index.js when layout is really finished.\n          return false;\n        }\n\n        if (isLayoutSuccessfull) {\n          if (!this.isSubLayout) {\n            this.doPostLayout();\n          }\n        }\n\n        if (this.tilingPostLayout) {\n          this.tilingPostLayout();\n        }\n\n        this.isLayoutFinished = true;\n        return isLayoutSuccessfull;\n      };\n      /**\r\n       * This method performs the operations required after layout.\r\n       */\n\n\n      Layout.prototype.doPostLayout = function () {\n        //assert !isSubLayout : \"Should not be called on sub-layout!\";\n        // Propagate geometric changes to v-level objects\n        if (!this.incremental) {\n          this.transform();\n        }\n\n        this.update();\n      };\n      /**\r\n       * This method updates the geometry of the target graph according to\r\n       * calculated layout.\r\n       */\n\n\n      Layout.prototype.update2 = function () {\n        // update bend points\n        if (this.createBendsAsNeeded) {\n          this.createBendpointsFromDummyNodes(); // reset all edges, since the topology has changed\n\n          this.graphManager.resetAllEdges();\n        } // perform edge, node and root updates if layout is not called\n        // remotely\n\n\n        if (!this.isRemoteUse) {\n          // update all edges\n          var edge;\n          var allEdges = this.graphManager.getAllEdges();\n\n          for (var i = 0; i < allEdges.length; i++) {\n            edge = allEdges[i]; //      this.update(edge);\n          } // recursively update nodes\n\n\n          var node;\n          var nodes = this.graphManager.getRoot().getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i]; //      this.update(node);\n          } // update root graph\n\n\n          this.update(this.graphManager.getRoot());\n        }\n      };\n\n      Layout.prototype.update = function (obj) {\n        if (obj == null) {\n          this.update2();\n        } else if (obj instanceof LNode) {\n          var node = obj;\n\n          if (node.getChild() != null) {\n            // since node is compound, recursively update child nodes\n            var nodes = node.getChild().getNodes();\n\n            for (var i = 0; i < nodes.length; i++) {\n              update(nodes[i]);\n            }\n          } // if the l-level node is associated with a v-level graph object,\n          // then it is assumed that the v-level node implements the\n          // interface Updatable.\n\n\n          if (node.vGraphObject != null) {\n            // cast to Updatable without any type check\n            var vNode = node.vGraphObject; // call the update method of the interface\n\n            vNode.update(node);\n          }\n        } else if (obj instanceof LEdge) {\n          var edge = obj; // if the l-level edge is associated with a v-level graph object,\n          // then it is assumed that the v-level edge implements the\n          // interface Updatable.\n\n          if (edge.vGraphObject != null) {\n            // cast to Updatable without any type check\n            var vEdge = edge.vGraphObject; // call the update method of the interface\n\n            vEdge.update(edge);\n          }\n        } else if (obj instanceof LGraph) {\n          var graph = obj; // if the l-level graph is associated with a v-level graph object,\n          // then it is assumed that the v-level object implements the\n          // interface Updatable.\n\n          if (graph.vGraphObject != null) {\n            // cast to Updatable without any type check\n            var vGraph = graph.vGraphObject; // call the update method of the interface\n\n            vGraph.update(graph);\n          }\n        }\n      };\n      /**\r\n       * This method is used to set all layout parameters to default values\r\n       * determined at compile time.\r\n       */\n\n\n      Layout.prototype.initParameters = function () {\n        if (!this.isSubLayout) {\n          this.layoutQuality = LayoutConstants.QUALITY;\n          this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n          this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n          this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n          this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n          this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n          this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n        }\n\n        if (this.animationDuringLayout) {\n          this.animationOnLayout = false;\n        }\n      };\n\n      Layout.prototype.transform = function (newLeftTop) {\n        if (newLeftTop == undefined) {\n          this.transform(new PointD(0, 0));\n        } else {\n          // create a transformation object (from Eclipse to layout). When an\n          // inverse transform is applied, we get upper-left coordinate of the\n          // drawing or the root graph at given input coordinate (some margins\n          // already included in calculation of left-top).\n          var trans = new Transform();\n          var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n          if (leftTop != null) {\n            trans.setWorldOrgX(newLeftTop.x);\n            trans.setWorldOrgY(newLeftTop.y);\n            trans.setDeviceOrgX(leftTop.x);\n            trans.setDeviceOrgY(leftTop.y);\n            var nodes = this.getAllNodes();\n            var node;\n\n            for (var i = 0; i < nodes.length; i++) {\n              node = nodes[i];\n              node.transform(trans);\n            }\n          }\n        }\n      };\n\n      Layout.prototype.positionNodesRandomly = function (graph) {\n        if (graph == undefined) {\n          //assert !this.incremental;\n          this.positionNodesRandomly(this.getGraphManager().getRoot());\n          this.getGraphManager().getRoot().updateBounds(true);\n        } else {\n          var lNode;\n          var childGraph;\n          var nodes = graph.getNodes();\n\n          for (var i = 0; i < nodes.length; i++) {\n            lNode = nodes[i];\n            childGraph = lNode.getChild();\n\n            if (childGraph == null) {\n              lNode.scatter();\n            } else if (childGraph.getNodes().length == 0) {\n              lNode.scatter();\n            } else {\n              this.positionNodesRandomly(childGraph);\n              lNode.updateBounds();\n            }\n          }\n        }\n      };\n      /**\r\n       * This method returns a list of trees where each tree is represented as a\r\n       * list of l-nodes. The method returns a list of size 0 when:\r\n       * - The graph is not flat or\r\n       * - One of the component(s) of the graph is not a tree.\r\n       */\n\n\n      Layout.prototype.getFlatForest = function () {\n        var flatForest = [];\n        var isForest = true; // Quick reference for all nodes in the graph manager associated with\n        // this layout. The list should not be changed.\n\n        var allNodes = this.graphManager.getRoot().getNodes(); // First be sure that the graph is flat\n\n        var isFlat = true;\n\n        for (var i = 0; i < allNodes.length; i++) {\n          if (allNodes[i].getChild() != null) {\n            isFlat = false;\n          }\n        } // Return empty forest if the graph is not flat.\n\n\n        if (!isFlat) {\n          return flatForest;\n        } // Run BFS for each component of the graph.\n\n\n        var visited = new Set();\n        var toBeVisited = [];\n        var parents = new Map();\n        var unProcessedNodes = [];\n        unProcessedNodes = unProcessedNodes.concat(allNodes); // Each iteration of this loop finds a component of the graph and\n        // decides whether it is a tree or not. If it is a tree, adds it to the\n        // forest and continued with the next component.\n\n        while (unProcessedNodes.length > 0 && isForest) {\n          toBeVisited.push(unProcessedNodes[0]); // Start the BFS. Each iteration of this loop visits a node in a\n          // BFS manner.\n\n          while (toBeVisited.length > 0 && isForest) {\n            //pool operation\n            var currentNode = toBeVisited[0];\n            toBeVisited.splice(0, 1);\n            visited.add(currentNode); // Traverse all neighbors of this node\n\n            var neighborEdges = currentNode.getEdges();\n\n            for (var i = 0; i < neighborEdges.length; i++) {\n              var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode); // If BFS is not growing from this neighbor.\n\n              if (parents.get(currentNode) != currentNeighbor) {\n                // We haven't previously visited this neighbor.\n                if (!visited.has(currentNeighbor)) {\n                  toBeVisited.push(currentNeighbor);\n                  parents.set(currentNeighbor, currentNode);\n                } // Since we have previously visited this neighbor and\n                // this neighbor is not parent of currentNode, given\n                // graph contains a component that is not tree, hence\n                // it is not a forest.\n                else {\n                    isForest = false;\n                    break;\n                  }\n              }\n            }\n          } // The graph contains a component that is not a tree. Empty\n          // previously found trees. The method will end.\n\n\n          if (!isForest) {\n            flatForest = [];\n          } // Save currently visited nodes as a tree in our forest. Reset\n          // visited and parents lists. Continue with the next component of\n          // the graph, if any.\n          else {\n              var temp = [].concat(_toConsumableArray(visited));\n              flatForest.push(temp); //flatForest = flatForest.concat(temp);\n              //unProcessedNodes.removeAll(visited);\n\n              for (var i = 0; i < temp.length; i++) {\n                var value = temp[i];\n                var index = unProcessedNodes.indexOf(value);\n\n                if (index > -1) {\n                  unProcessedNodes.splice(index, 1);\n                }\n              }\n\n              visited = new Set();\n              parents = new Map();\n            }\n        }\n\n        return flatForest;\n      };\n      /**\r\n       * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n       * for the given edge (one per bendpoint). The existing l-level structure\r\n       * is updated accordingly.\r\n       */\n\n\n      Layout.prototype.createDummyNodesForBendpoints = function (edge) {\n        var dummyNodes = [];\n        var prev = edge.source;\n        var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n        for (var i = 0; i < edge.bendpoints.length; i++) {\n          // create new dummy node\n          var dummyNode = this.newNode(null);\n          dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n          graph.add(dummyNode); // create new dummy edge between prev and dummy node\n\n          var dummyEdge = this.newEdge(null);\n          this.graphManager.add(dummyEdge, prev, dummyNode);\n          dummyNodes.add(dummyNode);\n          prev = dummyNode;\n        }\n\n        var dummyEdge = this.newEdge(null);\n        this.graphManager.add(dummyEdge, prev, edge.target);\n        this.edgeToDummyNodes.set(edge, dummyNodes); // remove real edge from graph manager if it is inter-graph\n\n        if (edge.isInterGraph()) {\n          this.graphManager.remove(edge);\n        } // else, remove the edge from the current graph\n        else {\n            graph.remove(edge);\n          }\n\n        return dummyNodes;\n      };\n      /**\r\n       * This method creates bendpoints for edges from the dummy nodes\r\n       * at l-level.\r\n       */\n\n\n      Layout.prototype.createBendpointsFromDummyNodes = function () {\n        var edges = [];\n        edges = edges.concat(this.graphManager.getAllEdges());\n        edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n        for (var k = 0; k < edges.length; k++) {\n          var lEdge = edges[k];\n\n          if (lEdge.bendpoints.length > 0) {\n            var path = this.edgeToDummyNodes.get(lEdge);\n\n            for (var i = 0; i < path.length; i++) {\n              var dummyNode = path[i];\n              var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY()); // update bendpoint's location according to dummy node\n\n              var ebp = lEdge.bendpoints.get(i);\n              ebp.x = p.x;\n              ebp.y = p.y; // remove the dummy node, dummy edges incident with this\n              // dummy node is also removed (within the remove method)\n\n              dummyNode.getOwner().remove(dummyNode);\n            } // add the real edge to graph\n\n\n            this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n          }\n        }\n      };\n\n      Layout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n        if (minDiv != undefined && maxMul != undefined) {\n          var value = defaultValue;\n\n          if (sliderValue <= 50) {\n            var minValue = defaultValue / minDiv;\n            value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n          } else {\n            var maxValue = defaultValue * maxMul;\n            value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n          }\n\n          return value;\n        } else {\n          var a, b;\n\n          if (sliderValue <= 50) {\n            a = 9.0 * defaultValue / 500.0;\n            b = defaultValue / 10.0;\n          } else {\n            a = 9.0 * defaultValue / 50.0;\n            b = -8 * defaultValue;\n          }\n\n          return a * sliderValue + b;\n        }\n      };\n      /**\r\n       * This method finds and returns the center of the given nodes, assuming\r\n       * that the given nodes form a tree in themselves.\r\n       */\n\n\n      Layout.findCenterOfTree = function (nodes) {\n        var list = [];\n        list = list.concat(nodes);\n        var removedNodes = [];\n        var remainingDegrees = new Map();\n        var foundCenter = false;\n        var centerNode = null;\n\n        if (list.length == 1 || list.length == 2) {\n          foundCenter = true;\n          centerNode = list[0];\n        }\n\n        for (var i = 0; i < list.length; i++) {\n          var node = list[i];\n          var degree = node.getNeighborsList().size;\n          remainingDegrees.set(node, node.getNeighborsList().size);\n\n          if (degree == 1) {\n            removedNodes.push(node);\n          }\n        }\n\n        var tempList = [];\n        tempList = tempList.concat(removedNodes);\n\n        while (!foundCenter) {\n          var tempList2 = [];\n          tempList2 = tempList2.concat(tempList);\n          tempList = [];\n\n          for (var i = 0; i < list.length; i++) {\n            var node = list[i];\n            var index = list.indexOf(node);\n\n            if (index >= 0) {\n              list.splice(index, 1);\n            }\n\n            var neighbours = node.getNeighborsList();\n            neighbours.forEach(function (neighbour) {\n              if (removedNodes.indexOf(neighbour) < 0) {\n                var otherDegree = remainingDegrees.get(neighbour);\n                var newDegree = otherDegree - 1;\n\n                if (newDegree == 1) {\n                  tempList.push(neighbour);\n                }\n\n                remainingDegrees.set(neighbour, newDegree);\n              }\n            });\n          }\n\n          removedNodes = removedNodes.concat(tempList);\n\n          if (list.length == 1 || list.length == 2) {\n            foundCenter = true;\n            centerNode = list[0];\n          }\n        }\n\n        return centerNode;\n      };\n      /**\r\n       * During the coarsening process, this layout may be referenced by two graph managers\r\n       * this setter function grants access to change the currently being used graph manager\r\n       */\n\n\n      Layout.prototype.setGraphManager = function (gm) {\n        this.graphManager = gm;\n      };\n\n      module.exports = Layout;\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function RandomSeed() {} // adapted from: https://stackoverflow.com/a/19303725\n\n\n      RandomSeed.seed = 1;\n      RandomSeed.x = 0;\n\n      RandomSeed.nextDouble = function () {\n        RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n        return RandomSeed.x - Math.floor(RandomSeed.x);\n      };\n\n      module.exports = RandomSeed;\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var PointD = __webpack_require__(4);\n\n      function Transform(x, y) {\n        this.lworldOrgX = 0.0;\n        this.lworldOrgY = 0.0;\n        this.ldeviceOrgX = 0.0;\n        this.ldeviceOrgY = 0.0;\n        this.lworldExtX = 1.0;\n        this.lworldExtY = 1.0;\n        this.ldeviceExtX = 1.0;\n        this.ldeviceExtY = 1.0;\n      }\n\n      Transform.prototype.getWorldOrgX = function () {\n        return this.lworldOrgX;\n      };\n\n      Transform.prototype.setWorldOrgX = function (wox) {\n        this.lworldOrgX = wox;\n      };\n\n      Transform.prototype.getWorldOrgY = function () {\n        return this.lworldOrgY;\n      };\n\n      Transform.prototype.setWorldOrgY = function (woy) {\n        this.lworldOrgY = woy;\n      };\n\n      Transform.prototype.getWorldExtX = function () {\n        return this.lworldExtX;\n      };\n\n      Transform.prototype.setWorldExtX = function (wex) {\n        this.lworldExtX = wex;\n      };\n\n      Transform.prototype.getWorldExtY = function () {\n        return this.lworldExtY;\n      };\n\n      Transform.prototype.setWorldExtY = function (wey) {\n        this.lworldExtY = wey;\n      };\n      /* Device related */\n\n\n      Transform.prototype.getDeviceOrgX = function () {\n        return this.ldeviceOrgX;\n      };\n\n      Transform.prototype.setDeviceOrgX = function (dox) {\n        this.ldeviceOrgX = dox;\n      };\n\n      Transform.prototype.getDeviceOrgY = function () {\n        return this.ldeviceOrgY;\n      };\n\n      Transform.prototype.setDeviceOrgY = function (doy) {\n        this.ldeviceOrgY = doy;\n      };\n\n      Transform.prototype.getDeviceExtX = function () {\n        return this.ldeviceExtX;\n      };\n\n      Transform.prototype.setDeviceExtX = function (dex) {\n        this.ldeviceExtX = dex;\n      };\n\n      Transform.prototype.getDeviceExtY = function () {\n        return this.ldeviceExtY;\n      };\n\n      Transform.prototype.setDeviceExtY = function (dey) {\n        this.ldeviceExtY = dey;\n      };\n\n      Transform.prototype.transformX = function (x) {\n        var xDevice = 0.0;\n        var worldExtX = this.lworldExtX;\n\n        if (worldExtX != 0.0) {\n          xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n        }\n\n        return xDevice;\n      };\n\n      Transform.prototype.transformY = function (y) {\n        var yDevice = 0.0;\n        var worldExtY = this.lworldExtY;\n\n        if (worldExtY != 0.0) {\n          yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n        }\n\n        return yDevice;\n      };\n\n      Transform.prototype.inverseTransformX = function (x) {\n        var xWorld = 0.0;\n        var deviceExtX = this.ldeviceExtX;\n\n        if (deviceExtX != 0.0) {\n          xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n        }\n\n        return xWorld;\n      };\n\n      Transform.prototype.inverseTransformY = function (y) {\n        var yWorld = 0.0;\n        var deviceExtY = this.ldeviceExtY;\n\n        if (deviceExtY != 0.0) {\n          yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n        }\n\n        return yWorld;\n      };\n\n      Transform.prototype.inverseTransformPoint = function (inPoint) {\n        var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n        return outPoint;\n      };\n\n      module.exports = Transform;\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _toConsumableArray(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        } else {\n          return Array.from(arr);\n        }\n      }\n\n      var Layout = __webpack_require__(15);\n\n      var FDLayoutConstants = __webpack_require__(7);\n\n      var LayoutConstants = __webpack_require__(0);\n\n      var IGeometry = __webpack_require__(8);\n\n      var IMath = __webpack_require__(9);\n\n      function FDLayout() {\n        Layout.call(this);\n        this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n        this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n        this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n        this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n        this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n        this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n        this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n        this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n        this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n        this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n        this.totalDisplacement = 0.0;\n        this.oldTotalDisplacement = 0.0;\n        this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n      }\n\n      FDLayout.prototype = Object.create(Layout.prototype);\n\n      for (var prop in Layout) {\n        FDLayout[prop] = Layout[prop];\n      }\n\n      FDLayout.prototype.initParameters = function () {\n        Layout.prototype.initParameters.call(this, arguments);\n        this.totalIterations = 0;\n        this.notAnimatedIterations = 0;\n        this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n        this.grid = [];\n      };\n\n      FDLayout.prototype.calcIdealEdgeLengths = function () {\n        var edge;\n        var lcaDepth;\n        var source;\n        var target;\n        var sizeOfSourceInLca;\n        var sizeOfTargetInLca;\n        var allEdges = this.getGraphManager().getAllEdges();\n\n        for (var i = 0; i < allEdges.length; i++) {\n          edge = allEdges[i];\n          edge.idealLength = this.idealEdgeLength;\n\n          if (edge.isInterGraph) {\n            source = edge.getSource();\n            target = edge.getTarget();\n            sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n            sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n            if (this.useSmartIdealEdgeLengthCalculation) {\n              edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n            }\n\n            lcaDepth = edge.getLca().getInclusionTreeDepth();\n            edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n          }\n        }\n      };\n\n      FDLayout.prototype.initSpringEmbedder = function () {\n        var s = this.getAllNodes().length;\n\n        if (this.incremental) {\n          if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n            this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n          }\n\n          this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n        } else {\n          if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n            this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n          } else {\n            this.coolingFactor = 1.0;\n          }\n\n          this.initialCoolingFactor = this.coolingFactor;\n          this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n        }\n\n        this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n        this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n        this.repulsionRange = this.calcRepulsionRange();\n      };\n\n      FDLayout.prototype.calcSpringForces = function () {\n        var lEdges = this.getAllEdges();\n        var edge;\n\n        for (var i = 0; i < lEdges.length; i++) {\n          edge = lEdges[i];\n          this.calcSpringForce(edge, edge.idealLength);\n        }\n      };\n\n      FDLayout.prototype.calcRepulsionForces = function () {\n        var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var i, j;\n        var nodeA, nodeB;\n        var lNodes = this.getAllNodes();\n        var processedNodeSet;\n\n        if (this.useFRGridVariant) {\n          if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n            this.updateGrid();\n          }\n\n          processedNodeSet = new Set(); // calculate repulsion forces between each nodes and its surrounding\n\n          for (i = 0; i < lNodes.length; i++) {\n            nodeA = lNodes[i];\n            this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n            processedNodeSet.add(nodeA);\n          }\n        } else {\n          for (i = 0; i < lNodes.length; i++) {\n            nodeA = lNodes[i];\n\n            for (j = i + 1; j < lNodes.length; j++) {\n              nodeB = lNodes[j]; // If both nodes are not members of the same graph, skip.\n\n              if (nodeA.getOwner() != nodeB.getOwner()) {\n                continue;\n              }\n\n              this.calcRepulsionForce(nodeA, nodeB);\n            }\n          }\n        }\n      };\n\n      FDLayout.prototype.calcGravitationalForces = function () {\n        var node;\n        var lNodes = this.getAllNodesToApplyGravitation();\n\n        for (var i = 0; i < lNodes.length; i++) {\n          node = lNodes[i];\n          this.calcGravitationalForce(node);\n        }\n      };\n\n      FDLayout.prototype.moveNodes = function () {\n        var lNodes = this.getAllNodes();\n        var node;\n\n        for (var i = 0; i < lNodes.length; i++) {\n          node = lNodes[i];\n          node.move();\n        }\n      };\n\n      FDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n        var sourceNode = edge.getSource();\n        var targetNode = edge.getTarget();\n        var length;\n        var springForce;\n        var springForceX;\n        var springForceY; // Update edge length\n\n        if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n          edge.updateLengthSimple();\n        } else {\n          edge.updateLength();\n\n          if (edge.isOverlapingSourceAndTarget) {\n            return;\n          }\n        }\n\n        length = edge.getLength();\n        if (length == 0) return; // Calculate spring forces\n\n        springForce = this.springConstant * (length - idealLength); // Project force onto x and y axes\n\n        springForceX = springForce * (edge.lengthX / length);\n        springForceY = springForce * (edge.lengthY / length); // Apply forces on the end nodes\n\n        sourceNode.springForceX += springForceX;\n        sourceNode.springForceY += springForceY;\n        targetNode.springForceX -= springForceX;\n        targetNode.springForceY -= springForceY;\n      };\n\n      FDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n        var rectA = nodeA.getRect();\n        var rectB = nodeB.getRect();\n        var overlapAmount = new Array(2);\n        var clipPoints = new Array(4);\n        var distanceX;\n        var distanceY;\n        var distanceSquared;\n        var distance;\n        var repulsionForce;\n        var repulsionForceX;\n        var repulsionForceY;\n\n        if (rectA.intersects(rectB)) // two nodes overlap\n          {\n            // calculate separation amount in x and y directions\n            IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n            repulsionForceX = 2 * overlapAmount[0];\n            repulsionForceY = 2 * overlapAmount[1];\n            var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren); // Apply forces on the two nodes\n\n            nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n            nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n            nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n            nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n          } else // no overlap\n          {\n            // calculate distance\n            if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n              {\n                distanceX = rectB.getCenterX() - rectA.getCenterX();\n                distanceY = rectB.getCenterY() - rectA.getCenterY();\n              } else // use clipping points\n              {\n                IGeometry.getIntersection(rectA, rectB, clipPoints);\n                distanceX = clipPoints[2] - clipPoints[0];\n                distanceY = clipPoints[3] - clipPoints[1];\n              } // No repulsion range. FR grid variant should take care of this.\n\n\n            if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n              distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n            }\n\n            if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n              distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n            }\n\n            distanceSquared = distanceX * distanceX + distanceY * distanceY;\n            distance = Math.sqrt(distanceSquared);\n            repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared; // Project force onto x and y axes\n\n            repulsionForceX = repulsionForce * distanceX / distance;\n            repulsionForceY = repulsionForce * distanceY / distance; // Apply forces on the two nodes    \n\n            nodeA.repulsionForceX -= repulsionForceX;\n            nodeA.repulsionForceY -= repulsionForceY;\n            nodeB.repulsionForceX += repulsionForceX;\n            nodeB.repulsionForceY += repulsionForceY;\n          }\n      };\n\n      FDLayout.prototype.calcGravitationalForce = function (node) {\n        var ownerGraph;\n        var ownerCenterX;\n        var ownerCenterY;\n        var distanceX;\n        var distanceY;\n        var absDistanceX;\n        var absDistanceY;\n        var estimatedSize;\n        ownerGraph = node.getOwner();\n        ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n        ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n        distanceX = node.getCenterX() - ownerCenterX;\n        distanceY = node.getCenterY() - ownerCenterY;\n        absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n        absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n        if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n          {\n            estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n            if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n              node.gravitationForceX = -this.gravityConstant * distanceX;\n              node.gravitationForceY = -this.gravityConstant * distanceY;\n            }\n          } else // inside a compound\n          {\n            estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n            if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n              node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n              node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n            }\n          }\n      };\n\n      FDLayout.prototype.isConverged = function () {\n        var converged;\n        var oscilating = false;\n\n        if (this.totalIterations > this.maxIterations / 3) {\n          oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n        }\n\n        converged = this.totalDisplacement < this.totalDisplacementThreshold;\n        this.oldTotalDisplacement = this.totalDisplacement;\n        return converged || oscilating;\n      };\n\n      FDLayout.prototype.animate = function () {\n        if (this.animationDuringLayout && !this.isSubLayout) {\n          if (this.notAnimatedIterations == this.animationPeriod) {\n            this.update();\n            this.notAnimatedIterations = 0;\n          } else {\n            this.notAnimatedIterations++;\n          }\n        }\n      }; //This method calculates the number of children (weight) for all nodes\n\n\n      FDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n        var node;\n        var allNodes = this.graphManager.getAllNodes();\n\n        for (var i = 0; i < allNodes.length; i++) {\n          node = allNodes[i];\n          node.noOfChildren = node.getNoOfChildren();\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: FR-Grid Variant Repulsion Force Calculation\n      // -----------------------------------------------------------------------------\n\n\n      FDLayout.prototype.calcGrid = function (graph) {\n        var sizeX = 0;\n        var sizeY = 0;\n        sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n        sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n        var grid = new Array(sizeX);\n\n        for (var i = 0; i < sizeX; i++) {\n          grid[i] = new Array(sizeY);\n        }\n\n        for (var i = 0; i < sizeX; i++) {\n          for (var j = 0; j < sizeY; j++) {\n            grid[i][j] = new Array();\n          }\n        }\n\n        return grid;\n      };\n\n      FDLayout.prototype.addNodeToGrid = function (v, left, top) {\n        var startX = 0;\n        var finishX = 0;\n        var startY = 0;\n        var finishY = 0;\n        startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n        finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n        startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n        finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n        for (var i = startX; i <= finishX; i++) {\n          for (var j = startY; j <= finishY; j++) {\n            this.grid[i][j].push(v);\n            v.setGridCoordinates(startX, finishX, startY, finishY);\n          }\n        }\n      };\n\n      FDLayout.prototype.updateGrid = function () {\n        var i;\n        var nodeA;\n        var lNodes = this.getAllNodes();\n        this.grid = this.calcGrid(this.graphManager.getRoot()); // put all nodes to proper grid cells\n\n        for (i = 0; i < lNodes.length; i++) {\n          nodeA = lNodes[i];\n          this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n        }\n      };\n\n      FDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n        if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n          var surrounding = new Set();\n          nodeA.surrounding = new Array();\n          var nodeB;\n          var grid = this.grid;\n\n          for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n            for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n              if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                for (var k = 0; k < grid[i][j].length; k++) {\n                  nodeB = grid[i][j][k]; // If both nodes are not members of the same graph, \n                  // or both nodes are the same, skip.\n\n                  if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                    continue;\n                  } // check if the repulsion force between\n                  // nodeA and nodeB has already been calculated\n\n\n                  if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                    var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                    var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2); // if the distance between nodeA and nodeB \n                    // is less then calculation range\n\n                    if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                      //then add nodeB to surrounding of nodeA\n                      surrounding.add(nodeB);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n        }\n\n        for (i = 0; i < nodeA.surrounding.length; i++) {\n          this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n        }\n      };\n\n      FDLayout.prototype.calcRepulsionRange = function () {\n        return 0.0;\n      };\n\n      module.exports = FDLayout;\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LEdge = __webpack_require__(1);\n\n      var FDLayoutConstants = __webpack_require__(7);\n\n      function FDLayoutEdge(source, target, vEdge) {\n        LEdge.call(this, source, target, vEdge);\n        this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n      }\n\n      FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\n      for (var prop in LEdge) {\n        FDLayoutEdge[prop] = LEdge[prop];\n      }\n\n      module.exports = FDLayoutEdge;\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LNode = __webpack_require__(3);\n\n      function FDLayoutNode(gm, loc, size, vNode) {\n        // alternative constructor is handled inside LNode\n        LNode.call(this, gm, loc, size, vNode); //Spring, repulsion and gravitational forces acting on this node\n\n        this.springForceX = 0;\n        this.springForceY = 0;\n        this.repulsionForceX = 0;\n        this.repulsionForceY = 0;\n        this.gravitationForceX = 0;\n        this.gravitationForceY = 0; //Amount by which this node is to be moved in this iteration\n\n        this.displacementX = 0;\n        this.displacementY = 0; //Start and finish grid coordinates that this node is fallen into\n\n        this.startX = 0;\n        this.finishX = 0;\n        this.startY = 0;\n        this.finishY = 0; //Geometric neighbors of this node\n\n        this.surrounding = [];\n      }\n\n      FDLayoutNode.prototype = Object.create(LNode.prototype);\n\n      for (var prop in LNode) {\n        FDLayoutNode[prop] = LNode[prop];\n      }\n\n      FDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n        this.startX = _startX;\n        this.finishX = _finishX;\n        this.startY = _startY;\n        this.finishY = _finishY;\n      };\n\n      module.exports = FDLayoutNode;\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function DimensionD(width, height) {\n        this.width = 0;\n        this.height = 0;\n\n        if (width !== null && height !== null) {\n          this.height = height;\n          this.width = width;\n        }\n      }\n\n      DimensionD.prototype.getWidth = function () {\n        return this.width;\n      };\n\n      DimensionD.prototype.setWidth = function (width) {\n        this.width = width;\n      };\n\n      DimensionD.prototype.getHeight = function () {\n        return this.height;\n      };\n\n      DimensionD.prototype.setHeight = function (height) {\n        this.height = height;\n      };\n\n      module.exports = DimensionD;\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var UniqueIDGeneretor = __webpack_require__(14);\n\n      function HashMap() {\n        this.map = {};\n        this.keys = [];\n      }\n\n      HashMap.prototype.put = function (key, value) {\n        var theId = UniqueIDGeneretor.createID(key);\n\n        if (!this.contains(theId)) {\n          this.map[theId] = value;\n          this.keys.push(key);\n        }\n      };\n\n      HashMap.prototype.contains = function (key) {\n        var theId = UniqueIDGeneretor.createID(key);\n        return this.map[key] != null;\n      };\n\n      HashMap.prototype.get = function (key) {\n        var theId = UniqueIDGeneretor.createID(key);\n        return this.map[theId];\n      };\n\n      HashMap.prototype.keySet = function () {\n        return this.keys;\n      };\n\n      module.exports = HashMap;\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var UniqueIDGeneretor = __webpack_require__(14);\n\n      function HashSet() {\n        this.set = {};\n      }\n\n      ;\n\n      HashSet.prototype.add = function (obj) {\n        var theId = UniqueIDGeneretor.createID(obj);\n        if (!this.contains(theId)) this.set[theId] = obj;\n      };\n\n      HashSet.prototype.remove = function (obj) {\n        delete this.set[UniqueIDGeneretor.createID(obj)];\n      };\n\n      HashSet.prototype.clear = function () {\n        this.set = {};\n      };\n\n      HashSet.prototype.contains = function (obj) {\n        return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n      };\n\n      HashSet.prototype.isEmpty = function () {\n        return this.size() === 0;\n      };\n\n      HashSet.prototype.size = function () {\n        return Object.keys(this.set).length;\n      }; //concats this.set to the given list\n\n\n      HashSet.prototype.addAllTo = function (list) {\n        var keys = Object.keys(this.set);\n        var length = keys.length;\n\n        for (var i = 0; i < length; i++) {\n          list.push(this.set[keys[i]]);\n        }\n      };\n\n      HashSet.prototype.size = function () {\n        return Object.keys(this.set).length;\n      };\n\n      HashSet.prototype.addAll = function (list) {\n        var s = list.length;\n\n        for (var i = 0; i < s; i++) {\n          var v = list[i];\n          this.add(v);\n        }\n      };\n\n      module.exports = HashSet;\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * A classic Quicksort algorithm with Hoare's partition\n       * - Works also on LinkedList objects\n       *\n       * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n       */\n\n\n      var LinkedList = __webpack_require__(11);\n\n      var Quicksort = function () {\n        function Quicksort(A, compareFunction) {\n          _classCallCheck(this, Quicksort);\n\n          if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n          var length = void 0;\n          if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n          this._quicksort(A, 0, length - 1);\n        }\n\n        _createClass(Quicksort, [{\n          key: '_quicksort',\n          value: function _quicksort(A, p, r) {\n            if (p < r) {\n              var q = this._partition(A, p, r);\n\n              this._quicksort(A, p, q);\n\n              this._quicksort(A, q + 1, r);\n            }\n          }\n        }, {\n          key: '_partition',\n          value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n\n            var i = p;\n            var j = r;\n\n            while (true) {\n              while (this.compareFunction(x, this._get(A, j))) {\n                j--;\n              }\n\n              while (this.compareFunction(this._get(A, i), x)) {\n                i++;\n              }\n\n              if (i < j) {\n                this._swap(A, i, j);\n\n                i++;\n                j--;\n              } else return j;\n            }\n          }\n        }, {\n          key: '_get',\n          value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n          }\n        }, {\n          key: '_set',\n          value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n          }\n        }, {\n          key: '_swap',\n          value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n\n            this._set(A, i, this._get(A, j));\n\n            this._set(A, j, temp);\n          }\n        }, {\n          key: '_defaultCompareFunction',\n          value: function _defaultCompareFunction(a, b) {\n            return b > a;\n          }\n        }]);\n\n        return Quicksort;\n      }();\n\n      module.exports = Quicksort;\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n       *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n       *\n       *   Aside from the inputs, you can assign the scores for,\n       *   - Match: The two characters at the current index are same.\n       *   - Mismatch: The two characters at the current index are different.\n       *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n       */\n\n\n      var NeedlemanWunsch = function () {\n        function NeedlemanWunsch(sequence1, sequence2) {\n          var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n          var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n          var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n          _classCallCheck(this, NeedlemanWunsch);\n\n          this.sequence1 = sequence1;\n          this.sequence2 = sequence2;\n          this.match_score = match_score;\n          this.mismatch_penalty = mismatch_penalty;\n          this.gap_penalty = gap_penalty; // Just the remove redundancy\n\n          this.iMax = sequence1.length + 1;\n          this.jMax = sequence2.length + 1; // Grid matrix of scores\n\n          this.grid = new Array(this.iMax);\n\n          for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n              this.grid[i][j] = 0;\n            }\n          } // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n\n\n          this.tracebackGrid = new Array(this.iMax);\n\n          for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n              this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n          } // The aligned sequences (return multiple possibilities)\n\n\n          this.alignments = []; // Final alignment score\n\n          this.score = -1; // Calculate scores and tracebacks\n\n          this.computeGrids();\n        }\n\n        _createClass(NeedlemanWunsch, [{\n          key: \"getScore\",\n          value: function getScore() {\n            return this.score;\n          }\n        }, {\n          key: \"getAlignments\",\n          value: function getAlignments() {\n            return this.alignments;\n          } // Main dynamic programming procedure\n\n        }, {\n          key: \"computeGrids\",\n          value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n              this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n              this.tracebackGrid[0][j] = [false, false, true];\n            } // Fill in the first column\n\n\n            for (var i = 1; i < this.iMax; i++) {\n              this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n              this.tracebackGrid[i][0] = [false, true, false];\n            } // Fill the rest of the grid\n\n\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n              for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                var diag = void 0;\n                if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                var left = this.grid[_i2][_j2 - 1] + this.gap_penalty; // If there exists multiple max values, capture them for multiple paths\n\n                var maxOf = [diag, up, left];\n                var indices = this.arrayAllMaxIndexes(maxOf); // Update Grids\n\n                this.grid[_i2][_j2] = maxOf[indices[0]];\n                this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n              }\n            } // Update alignment score\n\n\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n          } // Gets all possible valid sequence combinations\n\n        }, {\n          key: \"alignmentTraceback\",\n          value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n            inProcessAlignments.push({\n              pos: [this.sequence1.length, this.sequence2.length],\n              seq1: \"\",\n              seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n              var current = inProcessAlignments[0];\n              var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n              if (directions[0]) {\n                inProcessAlignments.push({\n                  pos: [current.pos[0] - 1, current.pos[1] - 1],\n                  seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                  seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                });\n              }\n\n              if (directions[1]) {\n                inProcessAlignments.push({\n                  pos: [current.pos[0] - 1, current.pos[1]],\n                  seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                  seq2: '-' + current.seq2\n                });\n              }\n\n              if (directions[2]) {\n                inProcessAlignments.push({\n                  pos: [current.pos[0], current.pos[1] - 1],\n                  seq1: '-' + current.seq1,\n                  seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                });\n              }\n\n              if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                sequence1: current.seq1,\n                sequence2: current.seq2\n              });\n              inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n          } // Helper Functions\n\n        }, {\n          key: \"getAllIndexes\",\n          value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n              indexes.push(i);\n            }\n\n            return indexes;\n          }\n        }, {\n          key: \"arrayAllMaxIndexes\",\n          value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n          }\n        }]);\n\n        return NeedlemanWunsch;\n      }();\n\n      module.exports = NeedlemanWunsch;\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var layoutBase = function layoutBase() {\n        return;\n      };\n\n      layoutBase.FDLayout = __webpack_require__(18);\n      layoutBase.FDLayoutConstants = __webpack_require__(7);\n      layoutBase.FDLayoutEdge = __webpack_require__(19);\n      layoutBase.FDLayoutNode = __webpack_require__(20);\n      layoutBase.DimensionD = __webpack_require__(21);\n      layoutBase.HashMap = __webpack_require__(22);\n      layoutBase.HashSet = __webpack_require__(23);\n      layoutBase.IGeometry = __webpack_require__(8);\n      layoutBase.IMath = __webpack_require__(9);\n      layoutBase.Integer = __webpack_require__(10);\n      layoutBase.Point = __webpack_require__(12);\n      layoutBase.PointD = __webpack_require__(4);\n      layoutBase.RandomSeed = __webpack_require__(16);\n      layoutBase.RectangleD = __webpack_require__(13);\n      layoutBase.Transform = __webpack_require__(17);\n      layoutBase.UniqueIDGeneretor = __webpack_require__(14);\n      layoutBase.Quicksort = __webpack_require__(24);\n      layoutBase.LinkedList = __webpack_require__(11);\n      layoutBase.LGraphObject = __webpack_require__(2);\n      layoutBase.LGraph = __webpack_require__(5);\n      layoutBase.LEdge = __webpack_require__(1);\n      layoutBase.LGraphManager = __webpack_require__(6);\n      layoutBase.LNode = __webpack_require__(3);\n      layoutBase.Layout = __webpack_require__(15);\n      layoutBase.LayoutConstants = __webpack_require__(0);\n      layoutBase.NeedlemanWunsch = __webpack_require__(25);\n      module.exports = layoutBase;\n      /***/\n    },\n    /* 27 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function Emitter() {\n        this.listeners = [];\n      }\n\n      var p = Emitter.prototype;\n\n      p.addListener = function (event, callback) {\n        this.listeners.push({\n          event: event,\n          callback: callback\n        });\n      };\n\n      p.removeListener = function (event, callback) {\n        for (var i = this.listeners.length; i >= 0; i--) {\n          var l = this.listeners[i];\n\n          if (l.event === event && l.callback === callback) {\n            this.listeners.splice(i, 1);\n          }\n        }\n      };\n\n      p.emit = function (event, data) {\n        for (var i = 0; i < this.listeners.length; i++) {\n          var l = this.listeners[i];\n\n          if (event === l.event) {\n            l.callback(data);\n          }\n        }\n      };\n\n      module.exports = Emitter;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":{"version":3,"sources":["/root/kiali-ui/node_modules/layout-base/layout-base.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","LayoutConstants","QUALITY","DEFAULT_CREATE_BENDS_AS_NEEDED","DEFAULT_INCREMENTAL","DEFAULT_ANIMATION_ON_LAYOUT","DEFAULT_ANIMATION_DURING_LAYOUT","DEFAULT_ANIMATION_PERIOD","DEFAULT_UNIFORM_LEAF_NODE_SIZES","DEFAULT_GRAPH_MARGIN","NODE_DIMENSIONS_INCLUDE_LABELS","SIMPLE_NODE_SIZE","SIMPLE_NODE_HALF_SIZE","EMPTY_COMPOUND_NODE_SIZE","MIN_EDGE_LENGTH","WORLD_BOUNDARY","INITIAL_WORLD_BOUNDARY","WORLD_CENTER_X","WORLD_CENTER_Y","LGraphObject","IGeometry","IMath","LEdge","source","target","vEdge","isOverlapingSourceAndTarget","vGraphObject","bendpoints","create","prop","getSource","getTarget","isInterGraph","getLength","length","getBendpoints","getLca","lca","getSourceInLca","sourceInLca","getTargetInLca","targetInLca","getOtherEnd","node","getOtherEndInGraph","graph","otherEnd","getGraphManager","getRoot","getOwner","getParent","updateLength","clipPointCoordinates","Array","getIntersection","getRect","lengthX","lengthY","Math","abs","sign","sqrt","updateLengthSimple","getCenterX","getCenterY","Integer","RectangleD","RandomSeed","PointD","LNode","gm","loc","size","vNode","graphManager","estimatedSize","MIN_VALUE","inclusionTreeDepth","MAX_VALUE","edges","rect","x","y","width","height","getEdges","getChild","child","owner","getWidth","setWidth","getHeight","setHeight","getCenter","getLocation","getDiagonal","getHalfTheDiagonal","setRect","upperLeft","dimension","setCenter","cx","cy","setLocation","moveBy","dx","dy","getEdgeListToNode","to","edgeList","edge","self","forEach","push","getEdgesBetween","other","getNeighborsList","neighbors","Set","add","withChildren","withNeighborsList","childNode","children","nodes","getNodes","getNoOfChildren","noOfChildren","getEstimatedSize","calcEstimatedSize","scatter","randomCenterX","randomCenterY","minX","maxX","nextDouble","minY","maxY","updateBounds","childGraph","getLeft","getTop","getRight","getBottom","labelWidth","labelHeight","labelPos","getInclusionTreeDepth","transform","trans","left","top","leftTop","vLeftTop","inverseTransformPoint","getX","getY","setX","setY","getDifference","pt","DimensionD","getCopy","translate","dim","LGraphManager","Point","LinkedList","LGraph","parent","obj2","vGraph","margin","isConnected","Layout","right","bottom","obj1","sourceNode","targetNode","newNode","indexOf","newEdge","remove","obj","edgesToBeRemoved","slice","index","splice","sourceIndex","targetIndex","updateLeftTop","nodeTop","nodeLeft","lNode","paddingLeft","undefined","recursive","nodeRight","nodeBottom","boundingRect","calculateBounds","updateConnected","queue","visited","currentNode","neighborEdges","currentNeighbor","childrenOfNode","shift","neighborEdge","has","childrenOfNeighbor","noOfVisitedInThisGraph","visitedNode","layout","graphs","addRoot","ngraph","newGraph","nnode","setRootGraph","rootGraph","parentNode","sourceGraph","targetGraph","lObj","concat","nodesToBeRemoved","getGraphs","getAllNodes","allNodes","nodeList","resetAllNodes","resetAllEdges","allEdges","resetAllNodesToApplyGravitation","allNodesToApplyGravitation","getAllEdges","getAllNodesToApplyGravitation","setAllNodesToApplyGravitation","getLayout","isOneAncestorOfOther","firstNode","secondNode","ownerGraph","calcLowestCommonAncestors","sourceAncestorGraph","targetAncestorGraph","calcLowestCommonAncestor","firstOwnerGraph","secondOwnerGraph","calcInclusionTreeDepths","depth","includesInvalidEdge","FDLayoutConstants","MAX_ITERATIONS","DEFAULT_EDGE_LENGTH","DEFAULT_SPRING_STRENGTH","DEFAULT_REPULSION_STRENGTH","DEFAULT_GRAVITY_STRENGTH","DEFAULT_COMPOUND_GRAVITY_STRENGTH","DEFAULT_GRAVITY_RANGE_FACTOR","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION","DEFAULT_COOLING_FACTOR_INCREMENTAL","COOLING_ADAPTATION_FACTOR","ADAPTATION_LOWER_NODE_LIMIT","ADAPTATION_UPPER_NODE_LIMIT","MAX_NODE_DISPLACEMENT_INCREMENTAL","MAX_NODE_DISPLACEMENT","MIN_REPULSION_DIST","CONVERGENCE_CHECK_PERIOD","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","GRID_CALCULATION_CHECK_PERIOD","calcSeparationAmount","rectA","rectB","overlapAmount","separationBuffer","intersects","directions","decideDirectionsForOverlappingNodes","min","max","slope","moveByY","moveByX","getIntersection2","result","p1x","p1y","p2x","p2y","topLeftAx","topLeftAy","topRightAx","bottomLeftAx","bottomLeftAy","bottomRightAx","halfWidthA","getWidthHalf","halfHeightA","getHeightHalf","topLeftBx","topLeftBy","topRightBx","bottomLeftBx","bottomLeftBy","bottomRightBx","halfWidthB","halfHeightB","clipPointAFound","clipPointBFound","slopeA","slopeB","slopePrime","cardinalDirectionA","cardinalDirectionB","tempPointAx","tempPointAy","tempPointBx","tempPointBy","getCardinalDirection","line","s1","s2","f1","f2","x1","y1","x2","y2","x3","y3","x4","y4","a1","a2","b1","b2","c1","c2","denom","angleOfVector","Cx","Cy","Nx","Ny","C_angle","atan","PI","TWO_PI","ONE_AND_HALF_PI","HALF_PI","doIntersect","p1","p2","p3","p4","a","b","q","r","det","lambda","gamma","THREE_PI","floor","ceil","_createClass","defineProperties","props","descriptor","writable","key","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","nodeFrom","next","prev","list","head","tail","_remove","vals","_this","v","insertBefore","val","otherNode","insertAfter","insertNodeBefore","insertNodeAfter","unshift","pop","popNode","shiftNode","get_object_at","current","set_object_at","constructor","parseInt","move","equals","toString","getMinX","getMaxX","getMinY","getMaxY","_typeof","Symbol","iterator","UniqueIDGeneretor","lastID","createID","isPrimitive","uniqueID","getString","id","arg","type","_toConsumableArray","arr","isArray","arr2","from","Transform","Emitter","isRemoteUse","layoutQuality","createBendsAsNeeded","incremental","animationOnLayout","animationDuringLayout","animationPeriod","uniformLeafNodeSizes","edgeToDummyNodes","Map","isLayoutFinished","isSubLayout","RANDOM_SEED","newGraphManager","checkLayoutSuccess","runLayout","tilingPreLayout","initParameters","isLayoutSuccessfull","ANIMATE","doPostLayout","tilingPostLayout","update","update2","createBendpointsFromDummyNodes","newLeftTop","setWorldOrgX","setWorldOrgY","setDeviceOrgX","setDeviceOrgY","positionNodesRandomly","getFlatForest","flatForest","isForest","isFlat","toBeVisited","parents","unProcessedNodes","set","temp","createDummyNodesForBendpoints","dummyNodes","dummyNode","Dimension","dummyEdge","keys","k","lEdge","path","ebp","sliderValue","defaultValue","minDiv","maxMul","minValue","maxValue","findCenterOfTree","removedNodes","remainingDegrees","foundCenter","centerNode","degree","tempList","tempList2","neighbours","neighbour","otherDegree","newDegree","setGraphManager","seed","sin","lworldOrgX","lworldOrgY","ldeviceOrgX","ldeviceOrgY","lworldExtX","lworldExtY","ldeviceExtX","ldeviceExtY","getWorldOrgX","wox","getWorldOrgY","woy","getWorldExtX","setWorldExtX","wex","getWorldExtY","setWorldExtY","wey","getDeviceOrgX","dox","getDeviceOrgY","doy","getDeviceExtX","setDeviceExtX","dex","getDeviceExtY","setDeviceExtY","dey","transformX","xDevice","worldExtX","transformY","yDevice","worldExtY","inverseTransformX","xWorld","deviceExtX","inverseTransformY","yWorld","deviceExtY","inPoint","outPoint","FDLayout","useSmartIdealEdgeLengthCalculation","idealEdgeLength","springConstant","repulsionConstant","gravityConstant","compoundGravityConstant","gravityRangeFactor","compoundGravityRangeFactor","displacementThresholdPerNode","coolingFactor","initialCoolingFactor","totalDisplacement","oldTotalDisplacement","maxIterations","arguments","totalIterations","notAnimatedIterations","useFRGridVariant","grid","calcIdealEdgeLengths","lcaDepth","sizeOfSourceInLca","sizeOfTargetInLca","idealLength","initSpringEmbedder","maxNodeDisplacement","totalDisplacementThreshold","repulsionRange","calcRepulsionRange","calcSpringForces","lEdges","calcSpringForce","calcRepulsionForces","gridUpdateAllowed","forceToNodeSurroundingUpdate","j","nodeA","nodeB","lNodes","processedNodeSet","updateGrid","calculateRepulsionForceOfANode","calcRepulsionForce","calcGravitationalForces","calcGravitationalForce","moveNodes","springForce","springForceX","springForceY","clipPoints","distanceX","distanceY","distanceSquared","distance","repulsionForce","repulsionForceX","repulsionForceY","childrenConstant","ownerCenterX","ownerCenterY","absDistanceX","absDistanceY","gravitationForceX","gravitationForceY","isConverged","converged","oscilating","animate","calcNoOfChildrenForAllNodes","calcGrid","sizeX","sizeY","addNodeToGrid","startX","finishX","startY","finishY","setGridCoordinates","surrounding","FDLayoutEdge","FDLayoutNode","displacementX","displacementY","_startX","_finishX","_startY","_finishY","HashMap","map","put","theId","contains","keySet","HashSet","clear","isEmpty","addAllTo","addAll","Quicksort","A","compareFunction","_defaultCompareFunction","_quicksort","_partition","_get","_swap","_set","NeedlemanWunsch","sequence1","sequence2","match_score","mismatch_penalty","gap_penalty","iMax","jMax","tracebackGrid","_i","_j","alignments","score","computeGrids","getScore","getAlignments","_i2","_j2","diag","up","maxOf","indices","arrayAllMaxIndexes","includes","alignmentTraceback","inProcessAlignments","pos","seq1","seq2","getAllIndexes","indexes","array","apply","layoutBase","listeners","addListener","event","callback","removeListener","emit","data"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layoutBase\"] = factory();\n\telse\n\t\troot[\"layoutBase\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar RectangleD = __webpack_require__(13);\nvar LayoutConstants = __webpack_require__(0);\nvar RandomSeed = __webpack_require__(16);\nvar PointD = __webpack_require__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar RectangleD = __webpack_require__(13);\nvar Point = __webpack_require__(12);\nvar LinkedList = __webpack_require__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __webpack_require__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __webpack_require__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar LGraph = __webpack_require__(5);\nvar PointD = __webpack_require__(4);\nvar Transform = __webpack_require__(17);\nvar Emitter = __webpack_require__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PointD = __webpack_require__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __webpack_require__(15);\nvar FDLayoutConstants = __webpack_require__(7);\nvar LayoutConstants = __webpack_require__(0);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LEdge = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LNode = __webpack_require__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __webpack_require__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __webpack_require__(18);\nlayoutBase.FDLayoutConstants = __webpack_require__(7);\nlayoutBase.FDLayoutEdge = __webpack_require__(19);\nlayoutBase.FDLayoutNode = __webpack_require__(20);\nlayoutBase.DimensionD = __webpack_require__(21);\nlayoutBase.HashMap = __webpack_require__(22);\nlayoutBase.HashSet = __webpack_require__(23);\nlayoutBase.IGeometry = __webpack_require__(8);\nlayoutBase.IMath = __webpack_require__(9);\nlayoutBase.Integer = __webpack_require__(10);\nlayoutBase.Point = __webpack_require__(12);\nlayoutBase.PointD = __webpack_require__(4);\nlayoutBase.RandomSeed = __webpack_require__(16);\nlayoutBase.RectangleD = __webpack_require__(13);\nlayoutBase.Transform = __webpack_require__(17);\nlayoutBase.UniqueIDGeneretor = __webpack_require__(14);\nlayoutBase.Quicksort = __webpack_require__(24);\nlayoutBase.LinkedList = __webpack_require__(11);\nlayoutBase.LGraphObject = __webpack_require__(2);\nlayoutBase.LGraph = __webpack_require__(5);\nlayoutBase.LEdge = __webpack_require__(1);\nlayoutBase.LGraphManager = __webpack_require__(6);\nlayoutBase.LNode = __webpack_require__(3);\nlayoutBase.Layout = __webpack_require__(15);\nlayoutBase.LayoutConstants = __webpack_require__(0);\nlayoutBase.NeedlemanWunsch = __webpack_require__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});"]},"metadata":{},"sourceType":"script"}