{"ast":null,"code":"import _objectSpread from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _isEqual from 'lodash/isEqual';\nimport { extractSpanInfo, getWorkloadFromSpan } from './TracingHelper';\n\nvar TreeNode = /*#__PURE__*/function () {\n  function TreeNode(value) {\n    var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, TreeNode);\n\n    this.value = void 0;\n    this.children = void 0;\n    this.value = value;\n    this.children = children;\n  }\n\n  _createClass(TreeNode, [{\n    key: \"depth\",\n    get: function get() {\n      return this.children.reduce(function (depth, child) {\n        return Math.max(child.depth + 1, depth);\n      }, 1);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      var i = 0;\n      this.walk(function () {\n        return i++;\n      });\n      return i;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      this.children.push(child instanceof TreeNode ? child : new TreeNode(child));\n      return this;\n    }\n  }, {\n    key: \"find\",\n    value: function find(search) {\n      var searchFn = TreeNode.iterFunction(TreeNode.searchFunction(search));\n\n      if (searchFn(this)) {\n        return this;\n      }\n\n      for (var i = 0; i < this.children.length; i++) {\n        var result = this.children[i].find(search);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath(search) {\n      var searchFn = TreeNode.iterFunction(TreeNode.searchFunction(search));\n\n      var findPath = function findPath(currentNode, currentPath) {\n        // skip if we already found the result\n        var attempt = currentPath.concat([currentNode]); // base case: return the array when there is a match\n\n        if (searchFn(currentNode)) {\n          return attempt;\n        }\n\n        for (var i = 0; i < currentNode.children.length; i++) {\n          var child = currentNode.children[i];\n          var match = findPath(child, attempt);\n\n          if (match) {\n            return match;\n          }\n        }\n\n        return null;\n      };\n\n      return findPath(this, []);\n    }\n  }, {\n    key: \"walk\",\n    value: function walk(fn) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var nodeStack = [];\n      var actualDepth = depth;\n      nodeStack.push({\n        node: this,\n        depth: actualDepth\n      });\n\n      while (nodeStack.length) {\n        var _nodeStack$pop = nodeStack.pop(),\n            node = _nodeStack$pop.node,\n            nodeDepth = _nodeStack$pop.depth;\n\n        fn(node.value, node, nodeDepth);\n        actualDepth = nodeDepth + 1;\n        var i = node.children.length - 1;\n\n        while (i >= 0) {\n          nodeStack.push({\n            node: node.children[i],\n            depth: actualDepth\n          });\n          i--;\n        }\n      }\n    }\n  }], [{\n    key: \"iterFunction\",\n    value: function iterFunction(fn) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return function (node) {\n        return fn(node.value, node, depth);\n      };\n    }\n  }, {\n    key: \"searchFunction\",\n    value: function searchFunction(search) {\n      if (typeof search === 'function') {\n        return search;\n      }\n\n      return function (value, node) {\n        return search instanceof TreeNode ? node === search : value === search;\n      };\n    }\n  }]);\n\n  return TreeNode;\n}();\n\nfunction deduplicateTags(spanTags) {\n  var warningsHash = new Map();\n  var tags = spanTags.reduce(function (uniqueTags, tag) {\n    if (!uniqueTags.some(function (t) {\n      return t.key === tag.key && t.value === tag.value;\n    })) {\n      uniqueTags.push(tag);\n    } else {\n      warningsHash.set(\"\".concat(tag.key, \":\").concat(tag.value), \"Duplicate tag \\\"\".concat(tag.key, \":\").concat(tag.value, \"\\\"\"));\n    }\n\n    return uniqueTags;\n  }, []);\n  var warnings = Array.from(warningsHash.values());\n  return {\n    tags: tags,\n    warnings: warnings\n  };\n}\n\nexport var TREE_ROOT_ID = '__root__';\nexport var spansSort = function spansSort(a, b) {\n  return +(a.startTime > b.startTime) || +(a.startTime === b.startTime) - 1;\n};\nexport function getTraceSpanIdsAsTree(trace) {\n  var nodesById = new Map(trace.spans.map(function (span) {\n    return [span.spanID, new TreeNode(span.spanID)];\n  }));\n  var spansById = new Map(trace.spans.map(function (span) {\n    return [span.spanID, span];\n  }));\n  var root = new TreeNode(TREE_ROOT_ID);\n  trace.spans.forEach(function (span) {\n    var node = nodesById.get(span.spanID);\n\n    if (Array.isArray(span.references) && span.references.length) {\n      var _span$references$ = span.references[0],\n          refType = _span$references$.refType,\n          parentID = _span$references$.spanID;\n\n      if (refType === 'CHILD_OF' || refType === 'FOLLOWS_FROM') {\n        var parent = nodesById.get(parentID) || root;\n        parent.children.push(node);\n      } else {\n        throw new Error(\"Unrecognized ref type: \".concat(refType));\n      }\n    } else {\n      root.children.push(node);\n    }\n  });\n\n  var comparator = function comparator(a, b) {\n    return spansSort(spansById.get(a.value), spansById.get(b.value));\n  };\n\n  trace.spans.forEach(function (span) {\n    var node = nodesById.get(span.spanID);\n\n    if (node.children.length > 1) {\n      node.children.sort(comparator);\n    }\n  });\n  root.children.sort(comparator);\n  return root;\n}\n/**\n * NOTE: Mutates `data` - Transform the HTTP response data into the form the app\n * generally requires.\n */\n\nexport default function transformTraceData(data) {\n  var traceID = data.traceID;\n\n  if (!traceID) {\n    return null;\n  }\n\n  traceID = traceID.toLowerCase();\n  var traceEndTime = 0;\n  var traceStartTime = Number.MAX_SAFE_INTEGER;\n  var spanIdCounts = new Map();\n  var spanMap = new Map(); // filter out spans with empty start times\n  // eslint-disable-next-line no-param-reassign\n\n  data.spans = data.spans.filter(function (span) {\n    return Boolean(span.startTime);\n  });\n  var max = data.spans.length;\n\n  for (var i = 0; i < max; i++) {\n    var span = data.spans[i];\n    var startTime = span.startTime,\n        duration = span.duration,\n        processID = span.processID; //\n\n    var spanID = span.spanID; // check for start / end time for the trace\n\n    if (startTime < traceStartTime) {\n      traceStartTime = startTime;\n    }\n\n    if (startTime + duration > traceEndTime) {\n      traceEndTime = startTime + duration;\n    } // make sure span IDs are unique\n\n\n    var idCount = spanIdCounts.get(spanID);\n\n    if (idCount != null) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Dupe spanID, \".concat(idCount + 1, \" x \").concat(spanID), span, spanMap.get(spanID));\n\n      if (_isEqual(span, spanMap.get(spanID))) {\n        // eslint-disable-next-line no-console\n        console.warn('\\t two spans with same ID have `isEqual(...) === true`');\n      }\n\n      spanIdCounts.set(spanID, idCount + 1);\n      spanID = \"\".concat(spanID, \"_\").concat(idCount);\n      span.spanID = spanID;\n    } else {\n      spanIdCounts.set(spanID, 1);\n    }\n\n    span.process = data.processes[processID];\n    spanMap.set(spanID, transformSpanData(span));\n  } // tree is necessary to sort the spans, so children follow parents, and\n  // siblings are sorted by start time\n\n\n  var tree = getTraceSpanIdsAsTree(data);\n  var spans = [];\n  var svcCounts = {};\n  var traceName = '';\n  tree.walk(function (spanID, node) {\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (spanID === '__root__') {\n      return;\n    }\n\n    var span = spanMap.get(spanID);\n\n    if (!span) {\n      return;\n    }\n\n    var serviceName = span.process.serviceName;\n    svcCounts[serviceName] = (svcCounts[serviceName] || 0) + 1;\n\n    if (!span.references || !span.references.length) {\n      traceName = span.operationName;\n    }\n\n    span.relativeStartTime = span.startTime - traceStartTime;\n    span.depth = depth - 1;\n    span.hasChildren = node.children.length > 0;\n    span.references.forEach(function (ref) {\n      var refSpan = spanMap.get(ref.spanID);\n\n      if (refSpan) {\n        // eslint-disable-next-line no-param-reassign\n        ref.span = refSpan;\n      }\n    });\n    spans.push(span);\n  });\n  var services = Object.keys(svcCounts).map(function (name) {\n    return {\n      name: name,\n      numberOfSpans: svcCounts[name]\n    };\n  });\n  return {\n    services: services,\n    spans: spans,\n    traceID: traceID,\n    traceName: traceName,\n    // can't use spread operator for intersection types\n    // repl: https://goo.gl/4Z23MJ\n    // issue: https://github.com/facebook/flow/issues/1511\n    processes: data.processes,\n    duration: traceEndTime - traceStartTime,\n    startTime: traceStartTime,\n    endTime: traceEndTime\n  };\n} // Extracts some information from a span to make it suitable for table-display\n\nexport var transformSpanData = function transformSpanData(span) {\n  span.warnings = span.warnings || [];\n  span.tags = span.tags || [];\n  span.references = span.references || [];\n  var tagsInfo = deduplicateTags(span.tags);\n  span.tags = tagsInfo.tags;\n  span.warnings = span.warnings.concat(tagsInfo.warnings);\n\n  var _extractSpanInfo = extractSpanInfo(span),\n      type = _extractSpanInfo.type,\n      info = _extractSpanInfo.info;\n\n  var workloadNs = getWorkloadFromSpan(span);\n  var split = span.process.serviceName.split('.');\n  var app = split[0];\n  var namespace = workloadNs ? workloadNs.namespace : split.length > 1 ? split[1] : undefined;\n\n  if (!namespace) {\n    console.warn('Could not determine span namespace');\n  }\n\n  var linkToApp = namespace ? '/namespaces/' + namespace + '/applications/' + app : undefined;\n  var linkToWorkload = workloadNs ? '/namespaces/' + workloadNs.namespace + '/workloads/' + workloadNs.workload : undefined;\n  return _objectSpread(_objectSpread({}, span), {}, {\n    type: type,\n    info: info,\n    component: info.component || 'unknown',\n    namespace: namespace || 'unknown',\n    app: app,\n    linkToApp: linkToApp,\n    workload: workloadNs === null || workloadNs === void 0 ? void 0 : workloadNs.workload,\n    pod: workloadNs === null || workloadNs === void 0 ? void 0 : workloadNs.pod,\n    linkToWorkload: linkToWorkload\n  });\n};","map":{"version":3,"sources":["/root/GraduateProject/src/utils/tracing/TraceTransform.ts"],"names":["_isEqual","extractSpanInfo","getWorkloadFromSpan","TreeNode","value","children","reduce","depth","child","Math","max","i","walk","push","search","searchFn","iterFunction","searchFunction","length","result","find","findPath","currentNode","currentPath","attempt","concat","match","fn","nodeStack","actualDepth","node","pop","nodeDepth","deduplicateTags","spanTags","warningsHash","Map","tags","uniqueTags","tag","some","t","key","set","warnings","Array","from","values","TREE_ROOT_ID","spansSort","a","b","startTime","getTraceSpanIdsAsTree","trace","nodesById","spans","map","span","spanID","spansById","root","forEach","get","isArray","references","refType","parentID","parent","Error","comparator","sort","transformTraceData","data","traceID","toLowerCase","traceEndTime","traceStartTime","Number","MAX_SAFE_INTEGER","spanIdCounts","spanMap","filter","Boolean","duration","processID","idCount","console","warn","process","processes","transformSpanData","tree","svcCounts","traceName","serviceName","operationName","relativeStartTime","hasChildren","ref","refSpan","services","Object","keys","name","numberOfSpans","endTime","tagsInfo","type","info","workloadNs","split","app","namespace","undefined","linkToApp","linkToWorkload","workload","component","pod"],"mappings":"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","sourcesContent":["import _isEqual from 'lodash/isEqual';\nimport { KeyValuePair, Span, SpanData, JaegerTrace, TraceData, RichSpanData } from 'types/JaegerInfo';\nimport { extractSpanInfo, getWorkloadFromSpan } from './TracingHelper';\n\nclass TreeNode {\n  value: string;\n  children: any[];\n\n  static iterFunction(fn, depth = 0) {\n    return node => fn(node.value, node, depth);\n  }\n\n  static searchFunction(search) {\n    if (typeof search === 'function') {\n      return search;\n    }\n\n    return (value, node) => (search instanceof TreeNode ? node === search : value === search);\n  }\n\n  constructor(value, children = []) {\n    this.value = value;\n    this.children = children;\n  }\n\n  get depth() {\n    return this.children.reduce((depth, child) => Math.max(child.depth + 1, depth), 1);\n  }\n\n  get size() {\n    let i = 0;\n    this.walk(() => i++);\n    return i;\n  }\n\n  addChild(child) {\n    this.children.push(child instanceof TreeNode ? child : new TreeNode(child));\n    return this;\n  }\n\n  find(search) {\n    const searchFn = TreeNode.iterFunction(TreeNode.searchFunction(search));\n    if (searchFn(this)) {\n      return this;\n    }\n    for (let i = 0; i < this.children.length; i++) {\n      const result = this.children[i].find(search);\n      if (result) {\n        return result;\n      }\n    }\n    return null;\n  }\n\n  getPath(search) {\n    const searchFn = TreeNode.iterFunction(TreeNode.searchFunction(search));\n\n    const findPath = (currentNode, currentPath) => {\n      // skip if we already found the result\n      const attempt = currentPath.concat([currentNode]);\n      // base case: return the array when there is a match\n      if (searchFn(currentNode)) {\n        return attempt;\n      }\n      for (let i = 0; i < currentNode.children.length; i++) {\n        const child = currentNode.children[i];\n        const match = findPath(child, attempt);\n        if (match) {\n          return match;\n        }\n      }\n      return null;\n    };\n\n    return findPath(this, []);\n  }\n\n  walk(fn, depth = 0) {\n    const nodeStack: any[] = [];\n    let actualDepth = depth;\n    nodeStack.push({ node: this, depth: actualDepth });\n    while (nodeStack.length) {\n      const { node, depth: nodeDepth } = nodeStack.pop();\n      fn(node.value, node, nodeDepth);\n      actualDepth = nodeDepth + 1;\n      let i = node.children.length - 1;\n      while (i >= 0) {\n        nodeStack.push({ node: node.children[i], depth: actualDepth });\n        i--;\n      }\n    }\n  }\n}\n\nfunction deduplicateTags(spanTags: Array<KeyValuePair>) {\n  const warningsHash: Map<string, string> = new Map<string, string>();\n  const tags: Array<KeyValuePair> = spanTags.reduce<Array<KeyValuePair>>((uniqueTags, tag) => {\n    if (!uniqueTags.some(t => t.key === tag.key && t.value === tag.value)) {\n      uniqueTags.push(tag);\n    } else {\n      warningsHash.set(`${tag.key}:${tag.value}`, `Duplicate tag \"${tag.key}:${tag.value}\"`);\n    }\n    return uniqueTags;\n  }, []);\n  const warnings = Array.from(warningsHash.values());\n  return { tags, warnings };\n}\n\nexport const TREE_ROOT_ID = '__root__';\n\nexport const spansSort = (a: SpanData, b: SpanData) =>\n  +(a.startTime > b.startTime) || +(a.startTime === b.startTime) - 1;\n\nexport function getTraceSpanIdsAsTree(trace: TraceData<SpanData>) {\n  const nodesById = new Map(trace.spans.map(span => [span.spanID, new TreeNode(span.spanID)]));\n  const spansById = new Map(trace.spans.map(span => [span.spanID, span]));\n  const root = new TreeNode(TREE_ROOT_ID);\n  trace.spans.forEach(span => {\n    const node = nodesById.get(span.spanID);\n    if (Array.isArray(span.references) && span.references.length) {\n      const { refType, spanID: parentID } = span.references[0];\n      if (refType === 'CHILD_OF' || refType === 'FOLLOWS_FROM') {\n        const parent = nodesById.get(parentID) || root;\n        parent.children.push(node);\n      } else {\n        throw new Error(`Unrecognized ref type: ${refType}`);\n      }\n    } else {\n      root.children.push(node);\n    }\n  });\n  const comparator = (a, b) => spansSort(spansById.get(a.value)!, spansById.get(b.value)!);\n  trace.spans.forEach(span => {\n    const node: any = nodesById.get(span.spanID);\n    if (node.children.length > 1) {\n      node.children.sort(comparator);\n    }\n  });\n  root.children.sort(comparator);\n  return root;\n}\n\n/**\n * NOTE: Mutates `data` - Transform the HTTP response data into the form the app\n * generally requires.\n */\nexport default function transformTraceData(data: TraceData<SpanData>): JaegerTrace | null {\n  let { traceID } = data;\n  if (!traceID) {\n    return null;\n  }\n  traceID = traceID.toLowerCase();\n\n  let traceEndTime = 0;\n  let traceStartTime = Number.MAX_SAFE_INTEGER;\n  const spanIdCounts = new Map();\n  const spanMap = new Map<string, RichSpanData>();\n  // filter out spans with empty start times\n  // eslint-disable-next-line no-param-reassign\n  data.spans = data.spans.filter(span => Boolean(span.startTime));\n\n  const max = data.spans.length;\n  for (let i = 0; i < max; i++) {\n    const span: Span = data.spans[i] as Span;\n    const { startTime, duration, processID } = span;\n    //\n    let spanID = span.spanID;\n    // check for start / end time for the trace\n    if (startTime < traceStartTime) {\n      traceStartTime = startTime;\n    }\n    if (startTime + duration > traceEndTime) {\n      traceEndTime = startTime + duration;\n    }\n    // make sure span IDs are unique\n    const idCount = spanIdCounts.get(spanID);\n    if (idCount != null) {\n      // eslint-disable-next-line no-console\n      console.warn(`Dupe spanID, ${idCount + 1} x ${spanID}`, span, spanMap.get(spanID));\n      if (_isEqual(span, spanMap.get(spanID))) {\n        // eslint-disable-next-line no-console\n        console.warn('\\t two spans with same ID have `isEqual(...) === true`');\n      }\n      spanIdCounts.set(spanID, idCount + 1);\n      spanID = `${spanID}_${idCount}`;\n      span.spanID = spanID;\n    } else {\n      spanIdCounts.set(spanID, 1);\n    }\n    span.process = data.processes[processID];\n    spanMap.set(spanID, transformSpanData(span));\n  }\n  // tree is necessary to sort the spans, so children follow parents, and\n  // siblings are sorted by start time\n  const tree = getTraceSpanIdsAsTree(data);\n  const spans: RichSpanData[] = [];\n  const svcCounts: Record<string, number> = {};\n  let traceName = '';\n\n  tree.walk((spanID: string, node: TreeNode, depth: number = 0) => {\n    if (spanID === '__root__') {\n      return;\n    }\n    const span = spanMap.get(spanID);\n    if (!span) {\n      return;\n    }\n    const { serviceName } = span.process;\n    svcCounts[serviceName] = (svcCounts[serviceName] || 0) + 1;\n    if (!span.references || !span.references.length) {\n      traceName = span.operationName;\n    }\n    span.relativeStartTime = span.startTime - traceStartTime;\n    span.depth = depth - 1;\n    span.hasChildren = node.children.length > 0;\n    span.references.forEach(ref => {\n      const refSpan = spanMap.get(ref.spanID) as Span;\n      if (refSpan) {\n        // eslint-disable-next-line no-param-reassign\n        ref.span = refSpan;\n      }\n    });\n    spans.push(span);\n  });\n  const services = Object.keys(svcCounts).map(name => ({ name, numberOfSpans: svcCounts[name] }));\n  return {\n    services,\n    spans,\n    traceID,\n    traceName,\n    // can't use spread operator for intersection types\n    // repl: https://goo.gl/4Z23MJ\n    // issue: https://github.com/facebook/flow/issues/1511\n    processes: data.processes,\n    duration: traceEndTime - traceStartTime,\n    startTime: traceStartTime,\n    endTime: traceEndTime\n  };\n}\n\n// Extracts some information from a span to make it suitable for table-display\nexport const transformSpanData = (span: Span): RichSpanData => {\n  span.warnings = span.warnings || [];\n  span.tags = span.tags || [];\n  span.references = span.references || [];\n  const tagsInfo = deduplicateTags(span.tags);\n  span.tags = tagsInfo.tags;\n  span.warnings = span.warnings.concat(tagsInfo.warnings);\n  const { type, info } = extractSpanInfo(span);\n  const workloadNs = getWorkloadFromSpan(span);\n  const split = span.process.serviceName.split('.');\n  const app = split[0];\n  const namespace = workloadNs ? workloadNs.namespace : split.length > 1 ? split[1] : undefined;\n  if (!namespace) {\n    console.warn('Could not determine span namespace');\n  }\n  const linkToApp = namespace ? '/namespaces/' + namespace + '/applications/' + app : undefined;\n  const linkToWorkload = workloadNs\n    ? '/namespaces/' + workloadNs.namespace + '/workloads/' + workloadNs.workload\n    : undefined;\n  return {\n    ...span,\n    type: type,\n    info: info,\n    component: info.component || 'unknown',\n    namespace: namespace || 'unknown',\n    app: app,\n    linkToApp: linkToApp,\n    workload: workloadNs?.workload,\n    pod: workloadNs?.pod,\n    linkToWorkload: linkToWorkload\n  };\n};\n"]},"metadata":{},"sourceType":"module"}