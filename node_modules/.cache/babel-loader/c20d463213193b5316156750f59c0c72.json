{"ast":null,"code":"import _objectSpread from\"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{getType}from'typesafe-actions';import{MessageCenterActions}from'../actions/MessageCenterActions';import{updateState}from'../utils/Reducer';import{LoginActions}from'../actions/LoginActions';import _ from'lodash';export var INITIAL_MESSAGE_CENTER_STATE={nextId:0,groups:[{id:'systemErrors',title:'Open issues',messages:[],showActions:false,hideIfEmpty:true},{id:'default',title:'Notifications',messages:[],showActions:true,hideIfEmpty:false}],hidden:true,expanded:false,expandedGroupId:'default'};var createMessage=function createMessage(id,content,detail,type,count,showNotification,created,showDetail,firstTriggered){return{id:id,content:content,detail:detail,type:type,count:count,show_notification:showNotification,seen:false,created:created,showDetail:showDetail,firstTriggered:firstTriggered};};// Updates several messages with the same payload, useful for marking messages\n// returns the updated state\nvar updateMessage=function updateMessage(state,messageIds,updater){var groups=state.groups.map(function(group){group=_objectSpread(_objectSpread({},group),{},{messages:group.messages.map(function(message){if(messageIds.includes(message.id)){message=updater(message);}return message;})});return group;});return updateState(state,{groups:groups});};var Messages=function Messages(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:INITIAL_MESSAGE_CENTER_STATE;var action=arguments.length>1?arguments[1]:undefined;switch(action.type){case getType(MessageCenterActions.addMessage):{var _action$payload=action.payload,content=_action$payload.content,detail=_action$payload.detail,groupId=_action$payload.groupId,messageType=_action$payload.messageType,showNotification=_action$payload.showNotification;var groups=state.groups.map(function(group){if(group.id===groupId){var existingMessage=group.messages.find(function(message){// Note, we don't include detail when determining same-ness, just the main content.  This is to avoid\n// trivial detail differences (like a timestamp).  If changing this approach apply the same change below\n// for message removal.\nreturn message.content===content;});var newMessage;if(existingMessage){// it is in the list already\nvar firstTriggered=existingMessage.firstTriggered?existingMessage.firstTriggered:existingMessage.created;newMessage=createMessage(state.nextId,existingMessage.content,existingMessage.detail,messageType,existingMessage.count+1,existingMessage.show_notification,new Date(),existingMessage.showDetail,firstTriggered);// remove the old message from the list\nvar filteredArray=_.remove(group.messages,function(message){return message.content!==content;});group=_objectSpread(_objectSpread({},group),{},{messages:filteredArray.concat(newMessage)});}else{newMessage=createMessage(state.nextId,content,detail,messageType,1,showNotification,new Date(),false,undefined);group=_objectSpread(_objectSpread({},group),{},{messages:group.messages.concat(newMessage)});}return group;}return group;});return updateState(state,{groups:groups,nextId:state.nextId+1});}case getType(MessageCenterActions.removeMessage):{var messageId=action.payload.messageId;var _groups=state.groups.map(function(group){group=_objectSpread(_objectSpread({},group),{},{messages:group.messages.filter(function(message){return!messageId.includes(message.id);})});return group;});return updateState(state,{groups:_groups});}case getType(MessageCenterActions.toggleMessageDetail):{return updateMessage(state,action.payload.messageId,function(message){return _objectSpread(_objectSpread({},message),{},{showDetail:!message.showDetail});});}case getType(MessageCenterActions.markAsRead):{return updateMessage(state,action.payload.messageId,function(message){return _objectSpread(_objectSpread({},message),{},{seen:true,show_notification:false});});}case getType(MessageCenterActions.hideNotification):{return updateMessage(state,action.payload.messageId,function(message){return _objectSpread(_objectSpread({},message),{},{show_notification:false});});}case getType(MessageCenterActions.showMessageCenter):if(state.hidden){return updateState(state,{hidden:false});}return state;case getType(MessageCenterActions.hideMessageCenter):if(!state.hidden){return updateState(state,{hidden:true});}return state;case getType(MessageCenterActions.toggleExpandedMessageCenter):return updateState(state,{expanded:!state.expanded});case getType(MessageCenterActions.toggleGroup):{var _groupId=action.payload.groupId;if(state.expandedGroupId===_groupId){return updateState(state,{expandedGroupId:undefined});}return updateState(state,{expandedGroupId:_groupId});}case getType(MessageCenterActions.expandGroup):{var _groupId2=action.payload.groupId;return updateState(state,{expandedGroupId:_groupId2});}case getType(LoginActions.loginRequest):{// Let's clear the message center quen user is loggin-in. This ensures\n// that messages from a past session won't persist because may be obsolete.\nreturn INITIAL_MESSAGE_CENTER_STATE;}default:return state;}};export default Messages;","map":null,"metadata":{},"sourceType":"module"}