{"ast":null,"code":"import _slicedToArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { ascendingThresholdCheck, RATIO_NA, HEALTHY, NA } from '../Health';\nimport { aggregate, checkExpr, getRateHealthConfig, transformEdgeResponses } from './utils';\nimport { RateHealth } from '../HealthAnnotation'; // Graph Edge\n\n/*\n Return the status for the edge from source to target\n*/\n\nexport var getEdgeHealth = function getEdgeHealth(edge, source, target) {\n  // We need to check the configuration for item A outbound requests and configuration of B for inbound requests\n  var annotationSource = source.hasHealthConfig ? new RateHealth(source.hasHealthConfig) : undefined;\n  var configSource = annotationSource && annotationSource.toleranceConfig ? annotationSource.toleranceConfig : getRateHealthConfig(source.namespace, source[source.nodeType], source.nodeType).tolerance;\n  var annotationTarget = target.hasHealthConfig ? new RateHealth(target.hasHealthConfig) : undefined;\n  var configTarget = annotationTarget && annotationTarget.toleranceConfig ? annotationTarget.toleranceConfig : getRateHealthConfig(target.namespace, target[target.nodeType], target.nodeType).tolerance; // If there is not tolerances with this configuration we'll use defaults\n\n  var tolerancesSource = configSource.filter(function (tol) {\n    return checkExpr(tol.direction, 'outbound');\n  });\n  var tolerancesTarget = configTarget.filter(function (tol) {\n    return checkExpr(tol.direction, 'inbound');\n  }); // Calculate aggregate\n\n  var outboundEdge = aggregate(transformEdgeResponses(edge.responses, edge.protocol), tolerancesSource, true);\n  var inboundEdge = aggregate(transformEdgeResponses(edge.responses, edge.protocol), tolerancesTarget, true); // Calculate status\n\n  var outboundEdgeStatus = calculateStatusGraph(outboundEdge, edge.responses);\n  var inboundEdgeStatus = calculateStatusGraph(inboundEdge, edge.responses); // Keep status with more priority\n\n  return outboundEdgeStatus.status.status.priority > inboundEdgeStatus.status.status.priority ? outboundEdgeStatus.status : inboundEdgeStatus.status;\n};\n/*\n  Calculate the RequestToleranceGraph for a requests and a configuration\n  Return the calculation in the object RequestToleranceGraph\n*/\n\nexport var generateRateForGraphTolerance = function generateRateForGraphTolerance(tol, requests) {\n  // If we have a tolerance configuration then calculate\n  if (tol.tolerance) {\n    // For each requests type {<protocol:string> : { <code: string>: <rate: number> } }\n    for (var _i = 0, _Object$entries = Object.entries(requests); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          protocol = _Object$entries$_i[0],\n          req = _Object$entries$_i[1];\n\n      // Check if protocol configuration match the protocol request\n      if (checkExpr(tol.tolerance.protocol, protocol)) {\n        // Loop by the status code and rate for each code\n        for (var _i2 = 0, _Object$entries2 = Object.entries(req); _i2 < _Object$entries2.length; _i2++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n              code = _Object$entries2$_i[0],\n              value = _Object$entries2$_i[1];\n\n          // If code match the regular expression in the configuration then sum the rate\n          if (checkExpr(tol.tolerance.code, code)) {\n            tol.requests[protocol] = tol.requests[protocol] ? tol.requests[protocol] + value : value;\n          }\n        }\n      }\n    }\n  }\n};\n/*\nCalculate the status of the edge with more priority given the results in requestsTolerances: RequestToleranceGraph[]\n\nReturn an object with the status calculated, the protocol and the tolerance configuration that kiali applied\n */\n\nexport var calculateStatusGraph = function calculateStatusGraph(requestsTolerances, traffic) {\n  // By default the health is NA\n  var result = {\n    status: {\n      value: RATIO_NA,\n      status: NA\n    },\n    protocol: '',\n    toleranceConfig: undefined\n  }; // For each calculate errorRate by tolerance configuration\n\n  for (var _i3 = 0, _Object$values = Object.values(requestsTolerances); _i3 < _Object$values.length; _i3++) {\n    var reqTol = _Object$values[_i3];\n\n    for (var _i4 = 0, _Object$entries3 = Object.entries(reqTol.requests); _i4 < _Object$entries3.length; _i4++) {\n      var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2),\n          protocol = _Object$entries3$_i[0],\n          rate = _Object$entries3$_i[1];\n\n      var tolerance = reqTol.tolerance && checkExpr(reqTol.tolerance.protocol, protocol) ? reqTol.tolerance : undefined; // Create threshold for the tolerance\n\n      var thresholds = {\n        degraded: tolerance.degraded,\n        failure: tolerance.failure,\n        unit: '%'\n      }; // Calculate the status\n\n      var errRatio = rate / getTotalRequest(traffic);\n      var auxStatus = ascendingThresholdCheck(100 * errRatio, thresholds); // Check if the status has more priority than the previous one\n\n      if (auxStatus.status.priority > result.status.status.priority) {\n        result.status = auxStatus;\n        result.protocol = protocol;\n        result.toleranceConfig = reqTol.tolerance;\n      }\n    }\n  }\n\n  if (result.status.status === NA && Object.keys(traffic).length > 0) {\n    result.status.status = HEALTHY;\n    result.status.value = 0;\n  }\n\n  return result;\n};\nexport var getTotalRequest = function getTotalRequest(traffic) {\n  var reqRate = 0;\n  Object.values(traffic).forEach(function (item) {\n    Object.values(item.flags).forEach(function (v) {\n      return reqRate += Number(v);\n    });\n  });\n  return reqRate;\n};","map":{"version":3,"sources":["/root/kiali-ui/src/types/ErrorRate/GraphEdgeStatus.ts"],"names":["ascendingThresholdCheck","RATIO_NA","HEALTHY","NA","aggregate","checkExpr","getRateHealthConfig","transformEdgeResponses","RateHealth","getEdgeHealth","edge","source","target","annotationSource","hasHealthConfig","undefined","configSource","toleranceConfig","namespace","nodeType","tolerance","annotationTarget","configTarget","tolerancesSource","filter","tol","direction","tolerancesTarget","outboundEdge","responses","protocol","inboundEdge","outboundEdgeStatus","calculateStatusGraph","inboundEdgeStatus","status","priority","generateRateForGraphTolerance","requests","Object","entries","req","code","value","requestsTolerances","traffic","result","values","reqTol","rate","thresholds","degraded","failure","unit","errRatio","getTotalRequest","auxStatus","keys","length","reqRate","forEach","item","flags","v","Number"],"mappings":"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","sourcesContent":["import { ToleranceConfig } from '../ServerConfig';\nimport { ascendingThresholdCheck, ThresholdStatus, RATIO_NA, HEALTHY, NA, RequestType } from '../Health';\nimport { DecoratedGraphEdgeData, DecoratedGraphNodeData, Responses } from '../Graph';\nimport { aggregate, checkExpr, getRateHealthConfig, transformEdgeResponses } from './utils';\nimport { RequestTolerance } from './types';\nimport { RateHealth } from '../HealthAnnotation';\n// Graph Edge\n/*\n Return the status for the edge from source to target\n*/\nexport const getEdgeHealth = (\n  edge: DecoratedGraphEdgeData,\n  source: DecoratedGraphNodeData,\n  target: DecoratedGraphNodeData\n): ThresholdStatus => {\n  // We need to check the configuration for item A outbound requests and configuration of B for inbound requests\n  const annotationSource = source.hasHealthConfig ? new RateHealth(source.hasHealthConfig) : undefined;\n  const configSource =\n    annotationSource && annotationSource.toleranceConfig\n      ? annotationSource.toleranceConfig\n      : getRateHealthConfig(source.namespace, source[source.nodeType], source.nodeType).tolerance;\n  const annotationTarget = target.hasHealthConfig ? new RateHealth(target.hasHealthConfig) : undefined;\n  const configTarget =\n    annotationTarget && annotationTarget.toleranceConfig\n      ? annotationTarget.toleranceConfig\n      : getRateHealthConfig(target.namespace, target[target.nodeType], target.nodeType).tolerance;\n\n  // If there is not tolerances with this configuration we'll use defaults\n  const tolerancesSource = configSource.filter(tol => checkExpr(tol.direction, 'outbound'));\n  const tolerancesTarget = configTarget.filter(tol => checkExpr(tol.direction, 'inbound'));\n\n  // Calculate aggregate\n  const outboundEdge = aggregate(transformEdgeResponses(edge.responses, edge.protocol), tolerancesSource, true);\n  const inboundEdge = aggregate(transformEdgeResponses(edge.responses, edge.protocol), tolerancesTarget, true);\n\n  // Calculate status\n  const outboundEdgeStatus = calculateStatusGraph(outboundEdge, edge.responses);\n  const inboundEdgeStatus = calculateStatusGraph(inboundEdge, edge.responses);\n\n  // Keep status with more priority\n  return outboundEdgeStatus.status.status.priority > inboundEdgeStatus.status.status.priority\n    ? outboundEdgeStatus.status\n    : inboundEdgeStatus.status;\n};\n\n/*\n  Calculate the RequestToleranceGraph for a requests and a configuration\n  Return the calculation in the object RequestToleranceGraph\n*/\n\nexport const generateRateForGraphTolerance = (tol: RequestTolerance, requests: RequestType) => {\n  // If we have a tolerance configuration then calculate\n  if (tol.tolerance) {\n    // For each requests type {<protocol:string> : { <code: string>: <rate: number> } }\n    for (let [protocol, req] of Object.entries(requests)) {\n      // Check if protocol configuration match the protocol request\n      if (checkExpr(tol!.tolerance!.protocol, protocol)) {\n        // Loop by the status code and rate for each code\n        for (let [code, value] of Object.entries(req)) {\n          // If code match the regular expression in the configuration then sum the rate\n          if (checkExpr(tol!.tolerance!.code, code)) {\n            tol.requests[protocol] = tol.requests[protocol] ? (tol.requests[protocol] as number) + value : value;\n          }\n        }\n      }\n    }\n  }\n};\n/*\nCalculate the status of the edge with more priority given the results in requestsTolerances: RequestToleranceGraph[]\n\nReturn an object with the status calculated, the protocol and the tolerance configuration that kiali applied\n */\nexport const calculateStatusGraph = (\n  requestsTolerances: RequestTolerance[],\n  traffic: Responses\n): { status: ThresholdStatus; protocol: string; toleranceConfig?: ToleranceConfig } => {\n  // By default the health is NA\n  let result: { status: ThresholdStatus; protocol: string; toleranceConfig?: ToleranceConfig } = {\n    status: {\n      value: RATIO_NA,\n      status: NA\n    },\n    protocol: '',\n    toleranceConfig: undefined\n  };\n  // For each calculate errorRate by tolerance configuration\n  for (let reqTol of Object.values(requestsTolerances)) {\n    for (let [protocol, rate] of Object.entries(reqTol.requests)) {\n      const tolerance =\n        reqTol.tolerance && checkExpr(reqTol!.tolerance!.protocol, protocol) ? reqTol.tolerance : undefined;\n      // Create threshold for the tolerance\n      let thresholds = {\n        degraded: tolerance!.degraded,\n        failure: tolerance!.failure,\n        unit: '%'\n      };\n      // Calculate the status\n      const errRatio = (rate as number) / getTotalRequest(traffic);\n      const auxStatus = ascendingThresholdCheck(100 * errRatio, thresholds);\n      // Check if the status has more priority than the previous one\n      if (auxStatus.status.priority > result.status.status.priority) {\n        result.status = auxStatus;\n        result.protocol = protocol;\n        result.toleranceConfig = reqTol.tolerance;\n      }\n    }\n  }\n  if (result.status.status === NA && Object.keys(traffic).length > 0) {\n    result.status.status = HEALTHY;\n    result.status.value = 0;\n  }\n  return result;\n};\n\nexport const getTotalRequest = (traffic: Responses): number => {\n  var reqRate = 0;\n  Object.values(traffic).forEach(item => {\n    Object.values(item.flags).forEach(v => (reqRate += Number(v)));\n  });\n  return reqRate;\n};\n"]},"metadata":{},"sourceType":"module"}