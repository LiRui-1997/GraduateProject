{"ast":null,"code":"import _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { clamp } from 'utils/MathUtils'; // Some information about the mathematical problem here:\n// We try to project a set of RATE values from an upper-unbounded interval ]0, +Inf[ to a set of TIMER DELAY values in\n//    a bounded interval [40ms, 5000ms] (arbitrary bounds).\n// TIMER DELAY is the delay for dots generation in the animation. The lower it is, the more dots there are.\n//\n// The constraints are:\n// - We'd like the relation to be inversely proportional: if RATE 1 is twice as big as RATE 2, DELAY 1 must be half of DELAY 2.\n// - The animations should be quite representative of volumetry both _relatively_ and _absolutely_: _relatively_ is the\n//    previous constraint (edges compared to each other); but _absolutely_ is another thing: regardless edges compared to\n//    each other, we should have a notion of low and high traffic.\n//\n// To better understand the issue, we can imagine two rates R1 = 0.001 rps and R2 = 0.1 rps. R2 should have 100 times more\n//    dots than R1. So it's likely to be \"crowded\", and looks like a high volumetry if we only consider the relative\n//    relationships. But thinking in absolute, 0.1 rps is small, it shouldn't be crowded.\n\nvar initialThreshold = 50;\nexport var AnimationTimerConfig = /*#__PURE__*/function () {\n  // baseDelay: for a rate of 1 rps/bps, there will be one dot every `baseDelay` seconds.\n  function AnimationTimerConfig(baseDelay) {\n    _classCallCheck(this, AnimationTimerConfig);\n\n    this.baseDelay = baseDelay;\n    this.threshold = void 0;\n    this.scaleFactor = void 0;\n    this.threshold = initialThreshold;\n    this.scaleFactor = 1;\n  }\n\n  _createClass(AnimationTimerConfig, [{\n    key: \"resetCalibration\",\n    value: function resetCalibration() {\n      this.threshold = initialThreshold;\n      this.scaleFactor = 1;\n    }\n  }, {\n    key: \"calibrate\",\n    value: function calibrate(rate) {\n      // We make this.threshold grow with max rate\n      // The scale factor for this graph is updated with the changed threshold.\n      if (rate > this.threshold) {\n        this.threshold = 2 * rate;\n        this.scaleFactor = this.computeScaleFactor();\n      }\n    }\n  }, {\n    key: \"computeDelay\",\n    value: function computeDelay(rate) {\n      if (isNaN(rate) || rate === 0) {\n        return undefined;\n      } // TIMER DELAY is inversely proportional to RATE. Scale factor is used to keep as much as possible TIMER DELAY in bounds\n\n\n      var d = 1000 * this.baseDelay * this.scaleFactor / rate; // In case it's out of bounds, clamp to bounds. Only case where proportionality is broken. Should only happen for very low values.\n\n      return clamp(d, 40, 5000);\n    }\n  }, {\n    key: \"computeScaleFactor\",\n    value: function computeScaleFactor() {\n      // Scale factor is how much values are upscaled compared to the initial threshold that is used with low rates\n      // Some arbitrary thresholds are used to amplify high volumetry\n      if (this.threshold > 100000) {\n        return Math.pow(this.threshold / initialThreshold, 0.9);\n      }\n\n      if (this.threshold > 1000) {\n        return Math.pow(this.threshold / initialThreshold, 0.95);\n      }\n\n      return this.threshold / initialThreshold;\n    }\n  }]);\n\n  return AnimationTimerConfig;\n}(); // HTTP config: 1 RPS => 1 dot every second\n\nexport var timerConfig = new AnimationTimerConfig(1); // TCP config: 20 bps => 1 dot every second\n\nexport var tcpTimerConfig = new AnimationTimerConfig(20);","map":{"version":3,"sources":["/root/GraduateProject/src/components/CytoscapeGraph/TrafficAnimation/AnimationTimerConfig.ts"],"names":["clamp","initialThreshold","AnimationTimerConfig","baseDelay","threshold","scaleFactor","rate","computeScaleFactor","isNaN","undefined","d","Math","pow","timerConfig","tcpTimerConfig"],"mappings":";;AAAA,SAASA,KAAT,QAAsB,iBAAtB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,gBAAgB,GAAG,EAAzB;AAEA,WAAaC,oBAAb;AAIE;AACA,gCAAoBC,SAApB,EAAuC;AAAA;;AAAA,SAAnBA,SAAmB,GAAnBA,SAAmB;AAAA,SAJ/BC,SAI+B;AAAA,SAH/BC,WAG+B;AACrC,SAAKD,SAAL,GAAiBH,gBAAjB;AACA,SAAKI,WAAL,GAAmB,CAAnB;AACD;;AARH;AAAA;AAAA,WAUE,4BAAmB;AACjB,WAAKD,SAAL,GAAiBH,gBAAjB;AACA,WAAKI,WAAL,GAAmB,CAAnB;AACD;AAbH;AAAA;AAAA,WAeE,mBAAUC,IAAV,EAAwB;AACtB;AACA;AACA,UAAIA,IAAI,GAAG,KAAKF,SAAhB,EAA2B;AACzB,aAAKA,SAAL,GAAiB,IAAIE,IAArB;AACA,aAAKD,WAAL,GAAmB,KAAKE,kBAAL,EAAnB;AACD;AACF;AAtBH;AAAA;AAAA,WAwBE,sBAAaD,IAAb,EAA2B;AACzB,UAAIE,KAAK,CAACF,IAAD,CAAL,IAAeA,IAAI,KAAK,CAA5B,EAA+B;AAC7B,eAAOG,SAAP;AACD,OAHwB,CAIzB;;;AACA,UAAMC,CAAC,GAAI,OAAO,KAAKP,SAAZ,GAAwB,KAAKE,WAA9B,GAA6CC,IAAvD,CALyB,CAMzB;;AACA,aAAON,KAAK,CAACU,CAAD,EAAI,EAAJ,EAAQ,IAAR,CAAZ;AACD;AAhCH;AAAA;AAAA,WAkCE,8BAA6B;AAC3B;AACA;AACA,UAAI,KAAKN,SAAL,GAAiB,MAArB,EAA6B;AAC3B,eAAOO,IAAI,CAACC,GAAL,CAAS,KAAKR,SAAL,GAAiBH,gBAA1B,EAA4C,GAA5C,CAAP;AACD;;AACD,UAAI,KAAKG,SAAL,GAAiB,IAArB,EAA2B;AACzB,eAAOO,IAAI,CAACC,GAAL,CAAS,KAAKR,SAAL,GAAiBH,gBAA1B,EAA4C,IAA5C,CAAP;AACD;;AACD,aAAO,KAAKG,SAAL,GAAiBH,gBAAxB;AACD;AA5CH;;AAAA;AAAA,I,CA+CA;;AACA,OAAO,IAAMY,WAAW,GAAG,IAAIX,oBAAJ,CAAyB,CAAzB,CAApB,C,CACP;;AACA,OAAO,IAAMY,cAAc,GAAG,IAAIZ,oBAAJ,CAAyB,EAAzB,CAAvB","sourcesContent":["import { clamp } from 'utils/MathUtils';\n\n// Some information about the mathematical problem here:\n// We try to project a set of RATE values from an upper-unbounded interval ]0, +Inf[ to a set of TIMER DELAY values in\n//    a bounded interval [40ms, 5000ms] (arbitrary bounds).\n// TIMER DELAY is the delay for dots generation in the animation. The lower it is, the more dots there are.\n//\n// The constraints are:\n// - We'd like the relation to be inversely proportional: if RATE 1 is twice as big as RATE 2, DELAY 1 must be half of DELAY 2.\n// - The animations should be quite representative of volumetry both _relatively_ and _absolutely_: _relatively_ is the\n//    previous constraint (edges compared to each other); but _absolutely_ is another thing: regardless edges compared to\n//    each other, we should have a notion of low and high traffic.\n//\n// To better understand the issue, we can imagine two rates R1 = 0.001 rps and R2 = 0.1 rps. R2 should have 100 times more\n//    dots than R1. So it's likely to be \"crowded\", and looks like a high volumetry if we only consider the relative\n//    relationships. But thinking in absolute, 0.1 rps is small, it shouldn't be crowded.\n\nconst initialThreshold = 50;\n\nexport class AnimationTimerConfig {\n  private threshold: number;\n  private scaleFactor: number;\n\n  // baseDelay: for a rate of 1 rps/bps, there will be one dot every `baseDelay` seconds.\n  constructor(private baseDelay: number) {\n    this.threshold = initialThreshold;\n    this.scaleFactor = 1;\n  }\n\n  resetCalibration() {\n    this.threshold = initialThreshold;\n    this.scaleFactor = 1;\n  }\n\n  calibrate(rate: number) {\n    // We make this.threshold grow with max rate\n    // The scale factor for this graph is updated with the changed threshold.\n    if (rate > this.threshold) {\n      this.threshold = 2 * rate;\n      this.scaleFactor = this.computeScaleFactor();\n    }\n  }\n\n  computeDelay(rate: number) {\n    if (isNaN(rate) || rate === 0) {\n      return undefined;\n    }\n    // TIMER DELAY is inversely proportional to RATE. Scale factor is used to keep as much as possible TIMER DELAY in bounds\n    const d = (1000 * this.baseDelay * this.scaleFactor) / rate;\n    // In case it's out of bounds, clamp to bounds. Only case where proportionality is broken. Should only happen for very low values.\n    return clamp(d, 40, 5000);\n  }\n\n  private computeScaleFactor() {\n    // Scale factor is how much values are upscaled compared to the initial threshold that is used with low rates\n    // Some arbitrary thresholds are used to amplify high volumetry\n    if (this.threshold > 100000) {\n      return Math.pow(this.threshold / initialThreshold, 0.9);\n    }\n    if (this.threshold > 1000) {\n      return Math.pow(this.threshold / initialThreshold, 0.95);\n    }\n    return this.threshold / initialThreshold;\n  }\n}\n\n// HTTP config: 1 RPS => 1 dot every second\nexport const timerConfig = new AnimationTimerConfig(1);\n// TCP config: 20 bps => 1 dot every second\nexport const tcpTimerConfig = new AnimationTimerConfig(20);\n"]},"metadata":{},"sourceType":"module"}