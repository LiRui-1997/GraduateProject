{"ast":null,"code":"!function (n, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t(n.TypesafeActions = {});\n}(this, function (n) {\n  \"use strict\";\n\n  function t(n, t) {\n    return void 0 === t && (t = 1), null == n;\n  }\n\n  function e(n) {\n    throw void 0 === n && (n = 1), new Error(\"Argument \" + n + \" is empty.\");\n  }\n\n  function r(n) {\n    throw void 0 === n && (n = 1), new Error(\"Argument \" + n + ' is invalid, it should be an action-creator instance from \"typesafe-actions\"');\n  }\n\n  function o(n) {\n    return \"string\" != typeof n && \"symbol\" != typeof n;\n  }\n\n  function i(n) {\n    throw void 0 === n && (n = 1), new Error(\"Argument \" + n + \" is invalid, it should be an action type of type: string | symbol\");\n  }\n\n  function u(n, t) {\n    if (null == n) throw new Error(\"Argument contains array with empty element at index \" + t);\n    if (\"string\" != typeof n && \"symbol\" != typeof n) throw new Error(\"Argument contains array with invalid element at index \" + t + \", it should be of type: string | symbol\");\n  }\n\n  function c(n, t) {\n    if (null == n) throw new Error(\"Argument contains array with empty element at index \" + t);\n    if (null == n.getType) throw new Error(\"Argument contains array with invalid element at index \" + t + ', it should be an action-creator instance from \"typesafe-actions\"');\n  }\n\n  function f(n, i, u, c) {\n    return t(n) && e(1), o(n) && r(1), {\n      type: n,\n      payload: i,\n      meta: u,\n      error: c\n    };\n  }\n\n  function a(n, r) {\n    t(n) && e(1), o(n) && i(1);\n    var u = null != r ? r(n) : function () {\n      return {\n        type: n\n      };\n    };\n    return Object.assign(u, {\n      getType: function getType() {\n        return n;\n      },\n      toString: function toString() {\n        return n;\n      }\n    });\n  }\n\n  n.action = f, n.createAction = function (n, t) {\n    var e = null == t ? function () {\n      return f(n);\n    } : t(f.bind(null, n));\n    return Object.assign(e, {\n      getType: function getType() {\n        return n;\n      },\n      toString: function toString() {\n        return n;\n      }\n    });\n  }, n.createStandardAction = function (n) {\n    return t(n) && e(1), o(n) && i(1), Object.assign(function () {\n      return a(n, function (n) {\n        return function (t, e) {\n          return {\n            type: n,\n            payload: t,\n            meta: e\n          };\n        };\n      });\n    }, {\n      map: function map(t) {\n        return a(n, function (n) {\n          return function (e, r) {\n            return Object.assign(t(e, r), {\n              type: n\n            });\n          };\n        });\n      }\n    });\n  }, n.createCustomAction = a, n.createAsyncAction = function (n, t, e) {\n    return [n, t, e].forEach(u), Object.assign(function () {\n      return {\n        request: a(n, function (n) {\n          return function (t) {\n            return {\n              type: n,\n              payload: t\n            };\n          };\n        }),\n        success: a(t, function (n) {\n          return function (t) {\n            return {\n              type: n,\n              payload: t\n            };\n          };\n        }),\n        failure: a(e, function (n) {\n          return function (t) {\n            return {\n              type: n,\n              payload: t\n            };\n          };\n        })\n      };\n    }, {});\n  }, n.getType = function (n) {\n    var o;\n    return t(n) && e(1), \"function\" == typeof (o = n) && \"getType\" in o || r(1), n.getType();\n  }, n.isOfType = function (n, r) {\n    t(n) && e(1);\n    var o = Array.isArray(n) ? n : [n];\n    o.forEach(u);\n\n    var i = function i(n) {\n      return o.includes(n.type);\n    };\n\n    return void 0 === r ? i : i(r);\n  }, n.isActionOf = function (n, r) {\n    t(n) && e(1);\n    var o = Array.isArray(n) ? n : [n];\n    o.forEach(c);\n\n    var i = function i(n) {\n      return o.some(function (t) {\n        return n.type === t.getType();\n      });\n    };\n\n    return void 0 === r ? i : i(r);\n  }, n.createActionDeprecated = function (n, t) {\n    var e;\n\n    if (null != t) {\n      if (\"function\" != typeof t) throw new Error(\"second argument is not a function\");\n      e = t;\n    } else e = function e() {\n      return {\n        type: n\n      };\n    };\n\n    if (null == n) throw new Error(\"first argument is missing\");\n    if (\"string\" != typeof n && \"symbol\" != typeof n) throw new Error(\"first argument should be type of: string | symbol\");\n    return e;\n  }, Object.defineProperty(n, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"sources":["../src/utils/validation.ts","../src/action.ts","../src/create-custom-action.ts","../src/create-action.ts","../src/create-standard-action.ts","../src/create-async-action.ts","../src/get-type.ts","../src/is-of-type.ts","../src/is-action-of.ts","../src/create-action-deprecated.ts"],"names":["checkIsEmpty","arg","argPosition","throwIsEmpty","Error","throwInvalidActionCreator","checkInvalidActionType","throwInvalidActionType","checkInvalidActionTypeInArray","idx","checkInvalidActionCreatorInArray","getType","action","type","payload","meta","error","createCustomAction","createHandler","actionCreator","Object","assign","toString","bind","_type","fn","map","requestType","successType","failureType","forEach","request","success","failure","actionTypeOrTypes","actionTypes","Array","isArray","assertFn","_action","includes","undefined","actionCreatorOrCreators","actionCreators","some","actionType","creatorFunction"],"mappings":"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","sourcesContent":["import { ActionCreator, TypeMeta, StringType } from '../type-helpers';\n\nexport function checkIsEmpty(arg: unknown, argPosition: number = 1) {\n  return arg == null;\n}\n\nexport function throwIsEmpty(argPosition: number = 1): never {\n  throw new Error(`Argument ${argPosition} is empty.`);\n}\n\nexport function checkInvalidActionCreator(arg: ActionCreator<StringType>) {\n  return typeof arg !== 'function' || !('getType' in arg);\n}\n\nexport function throwInvalidActionCreator(argPosition: number = 1): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action-creator instance from \"typesafe-actions\"`\n  );\n}\n\nexport function checkInvalidActionType(arg: StringType) {\n  return typeof arg !== 'string' && typeof arg !== 'symbol';\n}\n\nexport function throwInvalidActionType(argPosition: number = 1): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action type of type: string | symbol`\n  );\n}\n\nexport function checkInvalidActionTypeInArray(\n  arg: StringType,\n  idx: number\n): void | never {\n  if (arg == null) {\n    throw new Error(\n      `Argument contains array with empty element at index ${idx}`\n    );\n  } else if (typeof arg !== 'string' && typeof arg !== 'symbol') {\n    throw new Error(\n      `Argument contains array with invalid element at index ${idx}, it should be of type: string | symbol`\n    );\n  }\n}\n\nexport function checkInvalidActionCreatorInArray(\n  arg: ActionCreator<StringType> & TypeMeta<StringType>,\n  idx: number\n): void | never {\n  if (arg == null) {\n    throw new Error(\n      `Argument contains array with empty element at index ${idx}`\n    );\n  } else if (arg.getType == null) {\n    throw new Error(\n      // tslint:disable-next-line:max-line-length\n      `Argument contains array with invalid element at index ${idx}, it should be an action-creator instance from \"typesafe-actions\"`\n    );\n  }\n}\n","import { StringType } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionCreator,\n} from './utils/validation';\n\nexport function action<T extends StringType, E>(\n  type: T,\n  payload: undefined,\n  meta: undefined,\n  error: E\n): { type: T; error: E };\n\nexport function action<T extends StringType, M, E>(\n  type: T,\n  payload: undefined,\n  meta: M,\n  error: E\n): { type: T; meta: M; error: E };\n\nexport function action<T extends StringType, P, E>(\n  type: T,\n  payload: P,\n  meta: undefined,\n  error: E\n): { type: T; payload: P; error: E };\n\nexport function action<T extends StringType, P, M, E>(\n  type: T,\n  payload: P,\n  meta: M,\n  error: E\n): { type: T; payload: P; meta: M; error: E };\n\nexport function action<T extends StringType, M>(\n  type: T,\n  payload: undefined,\n  meta: M\n): { type: T; meta: M };\n\nexport function action<T extends StringType, P, M>(\n  type: T,\n  payload: P,\n  meta: M\n): { type: T; payload: P; meta: M };\n\nexport function action<T extends StringType, P>(\n  type: T,\n  payload: P\n): { type: T; payload: P };\n\nexport function action<T extends StringType>(type: T): { type: T };\n\n/**\n * @description flux standard action factory\n * @example\n * ```\n * const add = (amount: number, meta?: MetaShape) => action('INCREMENT', amount, meta);\n * ```\n */\nexport function action<\n  T extends StringType,\n  P = undefined,\n  M = undefined,\n  E = undefined\n>(type: T, payload?: P, meta?: M, error?: E) {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionCreator(1);\n  }\n\n  return { type, payload, meta, error } as any;\n}\n","import { ActionCreator, StringType } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from './utils/validation';\n\n/**\n * @description create custom action-creator using constructor function with injected type argument\n */\nexport function createCustomAction<\n  T extends StringType,\n  AC extends ActionCreator<T> = () => { type: T }\n>(type: T, createHandler?: (type: T) => AC): AC {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  const actionCreator: AC =\n    createHandler != null ? createHandler(type) : ((() => ({ type })) as AC);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import { StringType, ActionCreator } from './type-helpers';\nimport { action } from './action';\n\nexport type PayloadMetaAction<T extends StringType, P, M> = P extends undefined\n  ? M extends undefined\n    ? { type: T }\n    : { type: T; meta: M }\n  : M extends undefined\n  ? { type: T; payload: P }\n  : { type: T; payload: P; meta: M };\n\n/**\n * @description typesafe action-creator factory\n */\nexport function createAction<\n  T extends StringType,\n  AC extends ActionCreator<T> = () => { type: T }\n>(\n  type: T,\n  createHandler?: (\n    actionCallback: <P = undefined, M = undefined>(\n      payload?: P,\n      meta?: M\n    ) => PayloadMetaAction<T, P, M>\n  ) => AC\n): AC {\n  // validation is already done in action function\n\n  const actionCreator: AC =\n    createHandler == null\n      ? ((() => action(type)) as AC)\n      : createHandler(action.bind(null, type) as Parameters<\n          typeof createHandler\n        >[0]);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import {\n  StringType,\n  ActionBuilderConstructor,\n  ActionBuilderMap,\n} from './type-helpers';\nimport { createCustomAction } from './create-custom-action';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from './utils/validation';\n\nexport interface ActionBuilder<T extends StringType> {\n  <P = undefined, M = undefined>(): ActionBuilderConstructor<T, P, M>;\n  map<R, P = undefined, M = undefined>(\n    fn: (payload: P, meta: M) => R\n  ): ActionBuilderMap<T, R, P, M>;\n}\n\n/**\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createStandardAction<T extends StringType>(\n  type: T\n): ActionBuilder<T> {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  function constructor<P, M = undefined>(): ActionBuilderConstructor<T, P, M> {\n    return createCustomAction(type, _type => (payload: P, meta: M) => ({\n      type: _type,\n      payload,\n      meta,\n    })) as ActionBuilderConstructor<T, P, M>;\n  }\n\n  function map<R, P, M>(\n    fn: (payload: P, meta: M) => R\n  ): ActionBuilderMap<T, R, P, M> {\n    return createCustomAction(type, _type => (payload: P, meta: M) =>\n      Object.assign(fn(payload, meta), { type: _type })\n    ) as ActionBuilderMap<T, R, P, M>;\n  }\n\n  return Object.assign(constructor, { map });\n}\n","import {\n  StringType,\n  ActionBuilderConstructor,\n  // ActionBuilderMap,\n} from './type-helpers';\nimport { createCustomAction } from './create-custom-action';\nimport { checkInvalidActionTypeInArray } from './utils/validation';\n\nexport interface AsyncActionBuilder<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType\n> {\n  // tslint:disable-next-line:callable-types\n  <P1, P2, P3>(): AsyncActionBuilderConstructor<T1, T2, T3, P1, P2, P3>;\n  // withMappers<A1 = undefined, P1 = undefined, A2 = undefined, P2 = undefined, A3 = undefined, P3 = undefined>(\n  //   requestMapper: (a?: A1) => P1,\n  //   successMapper: (a?: A2) => P2,\n  //   failureMapper: (a?: A3) => P3\n  // ): AsyncActionBuilderWithMappers<T1, T2, T3, A1, P1, A2, P2, A3, P3>;\n}\n\nexport type AsyncActionBuilderConstructor<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType,\n  P1,\n  P2,\n  P3\n> = {\n  request: ActionBuilderConstructor<T1, P1>;\n  success: ActionBuilderConstructor<T2, P2>;\n  failure: ActionBuilderConstructor<T3, P3>;\n};\n\n/**\n * implementation\n */\nexport function createAsyncAction<\n  T1 extends StringType,\n  T2 extends StringType,\n  T3 extends StringType\n>(\n  requestType: T1,\n  successType: T2,\n  failureType: T3\n): AsyncActionBuilder<T1, T2, T3> {\n  [requestType, successType, failureType].forEach(\n    checkInvalidActionTypeInArray\n  );\n\n  function constructor<P1, P2, P3>(): AsyncActionBuilderConstructor<\n    T1,\n    T2,\n    T3,\n    P1,\n    P2,\n    P3\n  > {\n    return {\n      request: createCustomAction(requestType, type => (payload?: P1) => ({\n        type,\n        payload,\n      })) as ActionBuilderConstructor<T1, P1>,\n      success: createCustomAction(successType, type => (payload?: P2) => ({\n        type,\n        payload,\n      })) as ActionBuilderConstructor<T2, P2>,\n      failure: createCustomAction(failureType, type => (payload?: P3) => ({\n        type,\n        payload,\n      })) as ActionBuilderConstructor<T3, P3>,\n    };\n  }\n\n  return Object.assign(constructor, {});\n}\n\n// export type AsyncActionBuilderWithMappers<\n//   T1 extends StringType,\n//   T2 extends StringType,\n//   T3 extends StringType,\n//   A1 = undefined,\n//   P1 = undefined,\n//   A2 = undefined,\n//   P2 = undefined,\n//   A3 = undefined,\n//   P3 = undefined\n//   > = {\n//     request: ActionBuilderMap<T1, A1, P1>;\n//     success: ActionBuilderMap<T2, A2, P2>;\n//     failure: ActionBuilderMap<T3, A3, P3>;\n//   };\n\n// function withMappers<A1, P1, A2, P2, A3, P3>(\n//   requestMapper: (a?: A1) => P1,\n//   successMapper: (a?: A2) => P2,\n//   failureMapper: (a?: A3) => P3\n// ): AsyncActionBuilderWithMappers<T1, T2, T3, A1, P1, A2, P2, A3, P3> {\n//   return {\n//     request: createCustomAction(requestType, type => (payload?: A1) => ({\n//       type,\n//       payload: requestMapper != null ? requestMapper(payload) : undefined,\n//     })) as MapBuilder<T1, A1, P1>,\n//     success: createCustomAction(successType, type => (payload?: A2) => ({\n//       type,\n//       payload: successMapper != null ? successMapper(payload) : undefined,\n//     })) as MapBuilder<T2, A2, P2>,\n//     failure: createCustomAction(failureType, type => (payload?: A3) => ({\n//       type,\n//       payload: failureMapper != null ? failureMapper(payload) : undefined,\n//     })) as MapBuilder<T3, A3, P3>,\n//   };\n// }\n","import { StringType, ActionCreator, TypeMeta } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionCreator,\n  throwInvalidActionCreator,\n} from './utils/validation';\n\n/**\n * @description get the \"type literal\" of a given action-creator\n */\nexport function getType<T extends StringType>(\n  actionCreator: ActionCreator<T> & TypeMeta<T>\n): T {\n  if (checkIsEmpty(actionCreator)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionCreator(actionCreator)) {\n    throwInvalidActionCreator(1);\n  }\n\n  return actionCreator.getType!();\n}\n","import {\n  checkInvalidActionTypeInArray,\n  checkIsEmpty,\n  throwIsEmpty,\n} from './utils/validation';\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends string, A extends { type: string }>(\n  type: T | T[],\n  action: A\n): action is A extends { type: T } ? A : never;\n\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends string>(\n  type: T | T[]\n): <A extends { type: string }>(\n  action: A\n) => action is A extends { type: T } ? A : never;\n\n/**\n * implementation\n */\nexport function isOfType<T extends string, A extends { type: T }>(\n  actionTypeOrTypes: T | T[],\n  action?: A\n) {\n  if (checkIsEmpty(actionTypeOrTypes)) {\n    throwIsEmpty(1);\n  }\n\n  const actionTypes = Array.isArray(actionTypeOrTypes)\n    ? actionTypeOrTypes\n    : [actionTypeOrTypes];\n\n  actionTypes.forEach(checkInvalidActionTypeInArray);\n\n  const assertFn = (_action: A) => actionTypes.includes(_action.type);\n\n  // 1 arg case => return curried version\n  if (action === undefined) {\n    return assertFn;\n  }\n  // 2 args case => invoke assertFn and return the result\n  return assertFn(action);\n}\n","import { TypeMeta } from './type-helpers';\nimport {\n  checkInvalidActionCreatorInArray,\n  checkIsEmpty,\n  throwIsEmpty,\n} from './utils/validation';\n\nexport type ActionCreator<T extends { type: string }> = ((\n  ...args: any[]\n) => T) &\n  TypeMeta<T['type']>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreator: AC | AC[],\n  action: { type: string }\n): action is ReturnType<AC>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreator: AC | AC[]\n): (action: { type: string }) => action is ReturnType<AC>;\n\n/**\n * implementation\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreatorOrCreators: AC | AC[],\n  action?: { type: string }\n) {\n  if (checkIsEmpty(actionCreatorOrCreators)) {\n    throwIsEmpty(1);\n  }\n\n  const actionCreators = Array.isArray(actionCreatorOrCreators)\n    ? actionCreatorOrCreators\n    : [actionCreatorOrCreators];\n\n  actionCreators.forEach(checkInvalidActionCreatorInArray);\n\n  const assertFn = (_action: { type: string }) =>\n    actionCreators.some(\n      actionCreator => _action.type === actionCreator.getType!()\n    );\n\n  // 1 arg case => return curried version\n  if (action === undefined) {\n    return assertFn;\n  }\n  // 2 args case => invoke assertFn and return the result\n  return assertFn(action);\n}\n","/**\n * DEPRECATED\n */\n\nimport { StringType } from './type-helpers';\n\ninterface FSA<T extends StringType, P = {}, M = {}, E = boolean> {\n  type: T;\n  payload?: P;\n  meta?: M;\n  error?: E;\n}\n\n/**\n * @deprecated\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createActionDeprecated<\n  T extends StringType,\n  AC extends (...args: any[]) => FSA<T>\n>(actionType: T, creatorFunction: AC): AC;\n\n/**\n * @deprecated\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createActionDeprecated<\n  T extends StringType,\n  AC extends () => { type: T }\n>(actionType: T): AC;\n\n/**\n *  implementation\n */\nexport function createActionDeprecated<\n  T extends StringType,\n  AC extends (...args: any[]) => FSA<T>\n>(actionType: T, creatorFunction?: AC): AC {\n  let actionCreator: AC;\n\n  if (creatorFunction != null) {\n    if (typeof creatorFunction !== 'function') {\n      throw new Error('second argument is not a function');\n    }\n\n    actionCreator = creatorFunction as AC;\n  } else {\n    actionCreator = (() => ({ type: actionType })) as AC;\n  }\n\n  if (actionType != null) {\n    if (typeof actionType !== 'string' && typeof actionType !== 'symbol') {\n      throw new Error('first argument should be type of: string | symbol');\n    }\n  } else {\n    throw new Error('first argument is missing');\n  }\n\n  return actionCreator;\n}\n"]},"metadata":{},"sourceType":"script"}