{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"webcola\"));else if (typeof define === 'function' && define.amd) define([\"webcola\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeCola\"] = factory(require(\"webcola\"));else root[\"cytoscapeCola\"] = factory(root[\"webcola\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_5__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 3);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var assign = __webpack_require__(1);\n\n      var defaults = __webpack_require__(2);\n\n      var cola = __webpack_require__(5) || (typeof window !== 'undefined' ? window.cola : null);\n\n      var raf = __webpack_require__(4);\n\n      var isString = function isString(o) {\n        return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof('');\n      };\n\n      var isNumber = function isNumber(o) {\n        return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof(0);\n      };\n\n      var isObject = function isObject(o) {\n        return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof({});\n      };\n\n      var isFunction = function isFunction(o) {\n        return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof(function () {});\n      };\n\n      var nop = function nop() {};\n\n      var getOptVal = function getOptVal(val, ele) {\n        if (isFunction(val)) {\n          var fn = val;\n          return fn.apply(ele, [ele]);\n        } else {\n          return val;\n        }\n      }; // constructor\n      // options : object containing layout options\n\n\n      function ColaLayout(options) {\n        this.options = assign({}, defaults, options);\n      } // runs the layout\n\n\n      ColaLayout.prototype.run = function () {\n        var layout = this;\n        var options = this.options;\n        layout.manuallyStopped = false;\n        var cy = options.cy; // cy is automatically populated for us in the constructor\n\n        var eles = options.eles;\n        var nodes = eles.nodes();\n        var edges = eles.edges();\n        var ready = false;\n\n        var isParent = function isParent(ele) {\n          return ele.isParent();\n        };\n\n        var parentNodes = nodes.filter(isParent);\n        var nonparentNodes = nodes.subtract(parentNodes);\n        var bb = options.boundingBox || {\n          x1: 0,\n          y1: 0,\n          w: cy.width(),\n          h: cy.height()\n        };\n\n        if (bb.x2 === undefined) {\n          bb.x2 = bb.x1 + bb.w;\n        }\n\n        if (bb.w === undefined) {\n          bb.w = bb.x2 - bb.x1;\n        }\n\n        if (bb.y2 === undefined) {\n          bb.y2 = bb.y1 + bb.h;\n        }\n\n        if (bb.h === undefined) {\n          bb.h = bb.y2 - bb.y1;\n        }\n\n        var updateNodePositions = function updateNodePositions() {\n          for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            var dimensions = node.layoutDimensions(options);\n            var scratch = node.scratch('cola'); // update node dims\n\n            if (!scratch.updatedDims) {\n              var padding = getOptVal(options.nodeSpacing, node);\n              scratch.width = dimensions.w + 2 * padding;\n              scratch.height = dimensions.h + 2 * padding;\n            }\n          }\n\n          nodes.positions(function (node) {\n            var scratch = node.scratch().cola;\n            var retPos = void 0;\n\n            if (!node.grabbed() && nonparentNodes.contains(node)) {\n              retPos = {\n                x: bb.x1 + scratch.x,\n                y: bb.y1 + scratch.y\n              };\n\n              if (!isNumber(retPos.x) || !isNumber(retPos.y)) {\n                retPos = undefined;\n              }\n            }\n\n            return retPos;\n          });\n          nodes.updateCompoundBounds(); // because the way this layout sets positions is buggy for some reason; ref #878\n\n          if (!ready) {\n            onReady();\n            ready = true;\n          }\n\n          if (options.fit) {\n            cy.fit(options.padding);\n          }\n        };\n\n        var onDone = function onDone() {\n          if (options.ungrabifyWhileSimulating) {\n            grabbableNodes.grabify();\n          }\n\n          cy.off('destroy', destroyHandler);\n          nodes.off('grab free position', grabHandler);\n          nodes.off('lock unlock', lockHandler); // trigger layoutstop when the layout stops (e.g. finishes)\n\n          layout.one('layoutstop', options.stop);\n          layout.trigger({\n            type: 'layoutstop',\n            layout: layout\n          });\n        };\n\n        var onReady = function onReady() {\n          // trigger layoutready when each node has had its position set at least once\n          layout.one('layoutready', options.ready);\n          layout.trigger({\n            type: 'layoutready',\n            layout: layout\n          });\n        };\n\n        var ticksPerFrame = options.refresh;\n\n        if (options.refresh < 0) {\n          ticksPerFrame = 1;\n        } else {\n          ticksPerFrame = Math.max(1, ticksPerFrame); // at least 1\n        }\n\n        var adaptor = layout.adaptor = cola.adaptor({\n          trigger: function trigger(e) {\n            // on sim event\n            var TICK = cola.EventType ? cola.EventType.tick : null;\n            var END = cola.EventType ? cola.EventType.end : null;\n\n            switch (e.type) {\n              case 'tick':\n              case TICK:\n                if (options.animate) {\n                  updateNodePositions();\n                }\n\n                break;\n\n              case 'end':\n              case END:\n                updateNodePositions();\n\n                if (!options.infinite) {\n                  onDone();\n                }\n\n                break;\n            }\n          },\n          kick: function kick() {\n            // kick off the simulation\n            //let skip = 0;\n            var firstTick = true;\n\n            var inftick = function inftick() {\n              if (layout.manuallyStopped) {\n                onDone();\n                return true;\n              }\n\n              var ret = adaptor.tick();\n\n              if (!options.infinite && !firstTick) {\n                adaptor.convergenceThreshold(options.convergenceThreshold);\n              }\n\n              firstTick = false;\n\n              if (ret && options.infinite) {\n                // resume layout if done\n                adaptor.resume(); // resume => new kick\n              }\n\n              return ret; // allow regular finish b/c of new kick\n            };\n\n            var multitick = function multitick() {\n              // multiple ticks in a row\n              var ret = void 0;\n\n              for (var i = 0; i < ticksPerFrame && !ret; i++) {\n                ret = ret || inftick(); // pick up true ret vals => sim done\n              }\n\n              return ret;\n            };\n\n            if (options.animate) {\n              var frame = function frame() {\n                if (multitick()) {\n                  return;\n                }\n\n                raf(frame);\n              };\n\n              raf(frame);\n            } else {\n              while (!inftick()) {// keep going...\n              }\n            }\n          },\n          on: nop,\n          // dummy; not needed\n          drag: nop // not needed for our case\n\n        });\n        layout.adaptor = adaptor; // if set no grabbing during layout\n\n        var grabbableNodes = nodes.filter(':grabbable');\n\n        if (options.ungrabifyWhileSimulating) {\n          grabbableNodes.ungrabify();\n        }\n\n        var destroyHandler = void 0;\n        cy.one('destroy', destroyHandler = function destroyHandler() {\n          layout.stop();\n        }); // handle node dragging\n\n        var grabHandler = void 0;\n        nodes.on('grab free position', grabHandler = function grabHandler(e) {\n          var node = this;\n          var scrCola = node.scratch().cola;\n          var pos = node.position();\n          var nodeIsTarget = e.cyTarget === node || e.target === node;\n\n          if (!nodeIsTarget) {\n            return;\n          }\n\n          switch (e.type) {\n            case 'grab':\n              adaptor.dragstart(scrCola);\n              break;\n\n            case 'free':\n              adaptor.dragend(scrCola);\n              break;\n\n            case 'position':\n              // only update when different (i.e. manual .position() call or drag) so we don't loop needlessly\n              if (scrCola.px !== pos.x - bb.x1 || scrCola.py !== pos.y - bb.y1) {\n                scrCola.px = pos.x - bb.x1;\n                scrCola.py = pos.y - bb.y1;\n              }\n\n              break;\n          }\n        });\n        var lockHandler = void 0;\n        nodes.on('lock unlock', lockHandler = function lockHandler() {\n          var node = this;\n          var scrCola = node.scratch().cola;\n          scrCola.fixed = node.locked();\n\n          if (node.locked()) {\n            adaptor.dragstart(scrCola);\n          } else {\n            adaptor.dragend(scrCola);\n          }\n        }); // add nodes to cola\n\n        adaptor.nodes(nonparentNodes.map(function (node, i) {\n          var padding = getOptVal(options.nodeSpacing, node);\n          var pos = node.position();\n          var dimensions = node.layoutDimensions(options);\n          var struct = node.scratch().cola = {\n            x: options.randomize || pos.x === undefined ? Math.round(Math.random() * bb.w) : pos.x,\n            y: options.randomize || pos.y === undefined ? Math.round(Math.random() * bb.h) : pos.y,\n            width: dimensions.w + 2 * padding,\n            height: dimensions.h + 2 * padding,\n            index: i,\n            fixed: node.locked()\n          };\n          return struct;\n        })); // the constraints to be added on nodes\n\n        var constraints = [];\n\n        if (options.alignment) {\n          // then set alignment constraints\n          var offsetsX = [];\n          var offsetsY = [];\n          nonparentNodes.forEach(function (node) {\n            var align = getOptVal(options.alignment, node);\n            var scrCola = node.scratch().cola;\n            var index = scrCola.index;\n\n            if (!align) {\n              return;\n            }\n\n            if (align.x != null) {\n              offsetsX.push({\n                node: index,\n                offset: align.x\n              });\n            }\n\n            if (align.y != null) {\n              offsetsY.push({\n                node: index,\n                offset: align.y\n              });\n            }\n          });\n\n          if (offsetsX.length > 0) {\n            constraints.push({\n              type: 'alignment',\n              axis: 'x',\n              offsets: offsetsX\n            });\n          }\n\n          if (offsetsY.length > 0) {\n            constraints.push({\n              type: 'alignment',\n              axis: 'y',\n              offsets: offsetsY\n            });\n          }\n        } // if gapInequalities variable is set add each inequality constraint to list of constraints\n\n\n        if (options.gapInequalities) {\n          options.gapInequalities.forEach(function (inequality) {\n            // for the constraints to be passed to cola layout adaptor use indices of nodes,\n            // not the nodes themselves\n            var leftIndex = inequality.left.scratch().cola.index;\n            var rightIndex = inequality.right.scratch().cola.index;\n            constraints.push({\n              axis: inequality.axis,\n              left: leftIndex,\n              right: rightIndex,\n              gap: inequality.gap,\n              equality: inequality.equality\n            });\n          });\n        } // add constraints if any\n\n\n        if (constraints.length > 0) {\n          adaptor.constraints(constraints);\n        } // add compound nodes to cola\n\n\n        adaptor.groups(parentNodes.map(function (node, i) {\n          // add basic group incl leaf nodes\n          var optPadding = getOptVal(options.nodeSpacing, node);\n\n          var getPadding = function getPadding(d) {\n            return parseFloat(node.style('padding-' + d));\n          };\n\n          var pleft = getPadding('left') + optPadding;\n          var pright = getPadding('right') + optPadding;\n          var ptop = getPadding('top') + optPadding;\n          var pbottom = getPadding('bottom') + optPadding;\n          node.scratch().cola = {\n            index: i,\n            padding: Math.max(pleft, pright, ptop, pbottom),\n            // leaves should only contain direct descendants (children),\n            // not the leaves of nested compound nodes or any nodes that are compounds themselves\n            leaves: node.children().intersection(nonparentNodes).map(function (child) {\n              return child[0].scratch().cola.index;\n            }),\n            fixed: node.locked()\n          };\n          return node;\n        }).map(function (node) {\n          // add subgroups\n          node.scratch().cola.groups = node.children().intersection(parentNodes).map(function (child) {\n            return child.scratch().cola.index;\n          });\n          return node.scratch().cola;\n        })); // get the edge length setting mechanism\n\n        var length = void 0;\n        var lengthFnName = void 0;\n\n        if (options.edgeLength != null) {\n          length = options.edgeLength;\n          lengthFnName = 'linkDistance';\n        } else if (options.edgeSymDiffLength != null) {\n          length = options.edgeSymDiffLength;\n          lengthFnName = 'symmetricDiffLinkLengths';\n        } else if (options.edgeJaccardLength != null) {\n          length = options.edgeJaccardLength;\n          lengthFnName = 'jaccardLinkLengths';\n        } else {\n          length = 100;\n          lengthFnName = 'linkDistance';\n        }\n\n        var lengthGetter = function lengthGetter(link) {\n          return link.calcLength;\n        }; // add the edges to cola\n\n\n        adaptor.links(edges.stdFilter(function (edge) {\n          return nonparentNodes.contains(edge.source()) && nonparentNodes.contains(edge.target());\n        }).map(function (edge) {\n          var c = edge.scratch().cola = {\n            source: edge.source()[0].scratch().cola.index,\n            target: edge.target()[0].scratch().cola.index\n          };\n\n          if (length != null) {\n            c.calcLength = getOptVal(length, edge);\n          }\n\n          return c;\n        }));\n        adaptor.size([bb.w, bb.h]);\n\n        if (length != null) {\n          adaptor[lengthFnName](lengthGetter);\n        } // set the flow of cola\n\n\n        if (options.flow) {\n          var flow = void 0;\n          var defAxis = 'y';\n          var defMinSep = 50;\n\n          if (isString(options.flow)) {\n            flow = {\n              axis: options.flow,\n              minSeparation: defMinSep\n            };\n          } else if (isNumber(options.flow)) {\n            flow = {\n              axis: defAxis,\n              minSeparation: options.flow\n            };\n          } else if (isObject(options.flow)) {\n            flow = options.flow;\n            flow.axis = flow.axis || defAxis;\n            flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;\n          } else {\n            // e.g. options.flow: true\n            flow = {\n              axis: defAxis,\n              minSeparation: defMinSep\n            };\n          }\n\n          adaptor.flowLayout(flow.axis, flow.minSeparation);\n        }\n\n        layout.trigger({\n          type: 'layoutstart',\n          layout: layout\n        });\n        adaptor.avoidOverlaps(options.avoidOverlap).handleDisconnected(options.handleDisconnected).start(options.unconstrIter, options.userConstIter, options.allConstIter);\n\n        if (!options.infinite) {\n          setTimeout(function () {\n            if (!layout.manuallyStopped) {\n              adaptor.stop();\n            }\n          }, options.maxSimulationTime);\n        }\n\n        return this; // chaining\n      }; // called on continuous layouts to stop them before they finish\n\n\n      ColaLayout.prototype.stop = function () {\n        if (this.adaptor) {\n          this.manuallyStopped = true;\n          this.adaptor.stop();\n        }\n\n        return this; // chaining\n      };\n\n      module.exports = ColaLayout;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // Simple, internal Object.assign() polyfill for options objects etc.\n\n      module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n        for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          srcs[_key - 1] = arguments[_key];\n        }\n\n        srcs.filter(function (src) {\n          return src != null;\n        }).forEach(function (src) {\n          Object.keys(src).forEach(function (k) {\n            return tgt[k] = src[k];\n          });\n        });\n        return tgt;\n      };\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // default layout options\n\n      var defaults = {\n        animate: true,\n        // whether to show the layout as it's running\n        refresh: 1,\n        // number of ticks per frame; higher is faster but more jerky\n        maxSimulationTime: 4000,\n        // max length in ms to run the layout\n        ungrabifyWhileSimulating: false,\n        // so you can't drag nodes during layout\n        fit: true,\n        // on every layout reposition of nodes, fit the viewport\n        padding: 30,\n        // padding around the simulation\n        boundingBox: undefined,\n        // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n        nodeDimensionsIncludeLabels: false,\n        // whether labels should be included in determining the space used by a node\n        // layout event callbacks\n        ready: function ready() {},\n        // on layoutready\n        stop: function stop() {},\n        // on layoutstop\n        // positioning options\n        randomize: false,\n        // use random node positions at beginning of layout\n        avoidOverlap: true,\n        // if true, prevents overlap of node bounding boxes\n        handleDisconnected: true,\n        // if true, avoids disconnected components from overlapping\n        convergenceThreshold: 0.01,\n        // when the alpha value (system energy) falls below this value, the layout stops\n        nodeSpacing: function nodeSpacing(node) {\n          return 10;\n        },\n        // extra spacing around nodes\n        flow: undefined,\n        // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }\n        alignment: undefined,\n        // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }\n        gapInequalities: undefined,\n        // list of inequality constraints for the gap between the nodes, e.g. [{\"axis\":\"y\", \"left\":node1, \"right\":node2, \"gap\":25}]\n        // different methods of specifying edge length\n        // each can be a constant numerical value or a function like `function( edge ){ return 2; }`\n        edgeLength: undefined,\n        // sets edge length directly in simulation\n        edgeSymDiffLength: undefined,\n        // symmetric diff edge length in simulation\n        edgeJaccardLength: undefined,\n        // jaccard edge length in simulation\n        // iterations of cola algorithm; uses default values on undefined\n        unconstrIter: undefined,\n        // unconstrained initial layout iterations\n        userConstIter: undefined,\n        // initial layout iterations with user-specified constraints\n        allConstIter: undefined,\n        // initial layout iterations with all constraints including non-overlap\n        // infinite layout options\n        infinite: false // overrides all other options for a forces-all-the-time mode\n\n      };\n      module.exports = defaults;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var impl = __webpack_require__(0); // registers the extension on a cytoscape lib ref\n\n\n      var register = function register(cytoscape) {\n        if (!cytoscape) {\n          return;\n        } // can't register if cytoscape unspecified\n\n\n        cytoscape('layout', 'cola', impl); // register with cytoscape.js\n      };\n\n      if (typeof cytoscape !== 'undefined') {\n        // expose to global cytoscape (i.e. window.cytoscape)\n        register(cytoscape);\n      }\n\n      module.exports = register;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var raf = void 0;\n\n      if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) !== (true ? \"undefined\" : _typeof(undefined))) {\n        raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (fn) {\n          return setTimeout(fn, 16);\n        };\n      } else {\n        // if not available, all you get is immediate calls\n        raf = function raf(cb) {\n          cb();\n        };\n      }\n\n      module.exports = raf;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":{"version":3,"sources":["/root/GraduateProject/node_modules/cytoscape-cola/cytoscape-cola.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE_5__","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","_typeof","Symbol","iterator","obj","constructor","assign","defaults","cola","window","raf","isString","isNumber","isObject","isFunction","nop","getOptVal","val","ele","fn","apply","ColaLayout","options","run","layout","manuallyStopped","cy","eles","nodes","edges","ready","isParent","parentNodes","filter","nonparentNodes","subtract","bb","boundingBox","x1","y1","w","width","h","height","x2","undefined","y2","updateNodePositions","length","node","dimensions","layoutDimensions","scratch","updatedDims","padding","nodeSpacing","positions","retPos","grabbed","contains","x","y","updateCompoundBounds","onReady","fit","onDone","ungrabifyWhileSimulating","grabbableNodes","grabify","off","destroyHandler","grabHandler","lockHandler","one","stop","trigger","type","ticksPerFrame","refresh","Math","max","adaptor","e","TICK","EventType","tick","END","end","animate","infinite","kick","firstTick","inftick","ret","convergenceThreshold","resume","multitick","frame","on","drag","ungrabify","scrCola","pos","position","nodeIsTarget","cyTarget","target","dragstart","dragend","px","py","fixed","locked","map","struct","randomize","round","random","index","constraints","alignment","offsetsX","offsetsY","forEach","align","push","offset","axis","offsets","gapInequalities","inequality","leftIndex","left","rightIndex","right","gap","equality","groups","optPadding","getPadding","parseFloat","style","pleft","pright","ptop","pbottom","leaves","children","intersection","child","lengthFnName","edgeLength","edgeSymDiffLength","edgeJaccardLength","lengthGetter","link","calcLength","links","stdFilter","edge","source","size","flow","defAxis","defMinSep","minSeparation","flowLayout","avoidOverlaps","avoidOverlap","handleDisconnected","start","unconstrIter","userConstIter","allConstIter","setTimeout","maxSimulationTime","bind","tgt","_len","arguments","srcs","Array","_key","src","keys","k","nodeDimensionsIncludeLabels","impl","register","cytoscape","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"webcola\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"webcola\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeCola\"] = factory(require(\"webcola\"));\n\telse\n\t\troot[\"cytoscapeCola\"] = factory(root[\"webcola\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar assign = __webpack_require__(1);\nvar defaults = __webpack_require__(2);\nvar cola = __webpack_require__(5) || (typeof window !== 'undefined' ? window.cola : null);\nvar raf = __webpack_require__(4);\nvar isString = function isString(o) {\n  return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof('');\n};\nvar isNumber = function isNumber(o) {\n  return (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof(0);\n};\nvar isObject = function isObject(o) {\n  return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof({});\n};\nvar isFunction = function isFunction(o) {\n  return o != null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === _typeof(function () {});\n};\nvar nop = function nop() {};\n\nvar getOptVal = function getOptVal(val, ele) {\n  if (isFunction(val)) {\n    var fn = val;\n    return fn.apply(ele, [ele]);\n  } else {\n    return val;\n  }\n};\n\n// constructor\n// options : object containing layout options\nfunction ColaLayout(options) {\n  this.options = assign({}, defaults, options);\n}\n\n// runs the layout\nColaLayout.prototype.run = function () {\n  var layout = this;\n  var options = this.options;\n\n  layout.manuallyStopped = false;\n\n  var cy = options.cy; // cy is automatically populated for us in the constructor\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n  var ready = false;\n\n  var isParent = function isParent(ele) {\n    return ele.isParent();\n  };\n\n  var parentNodes = nodes.filter(isParent);\n\n  var nonparentNodes = nodes.subtract(parentNodes);\n\n  var bb = options.boundingBox || { x1: 0, y1: 0, w: cy.width(), h: cy.height() };\n  if (bb.x2 === undefined) {\n    bb.x2 = bb.x1 + bb.w;\n  }\n  if (bb.w === undefined) {\n    bb.w = bb.x2 - bb.x1;\n  }\n  if (bb.y2 === undefined) {\n    bb.y2 = bb.y1 + bb.h;\n  }\n  if (bb.h === undefined) {\n    bb.h = bb.y2 - bb.y1;\n  }\n\n  var updateNodePositions = function updateNodePositions() {\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var dimensions = node.layoutDimensions(options);\n      var scratch = node.scratch('cola');\n\n      // update node dims\n      if (!scratch.updatedDims) {\n        var padding = getOptVal(options.nodeSpacing, node);\n\n        scratch.width = dimensions.w + 2 * padding;\n        scratch.height = dimensions.h + 2 * padding;\n      }\n    }\n\n    nodes.positions(function (node) {\n      var scratch = node.scratch().cola;\n      var retPos = void 0;\n\n      if (!node.grabbed() && nonparentNodes.contains(node)) {\n        retPos = {\n          x: bb.x1 + scratch.x,\n          y: bb.y1 + scratch.y\n        };\n\n        if (!isNumber(retPos.x) || !isNumber(retPos.y)) {\n          retPos = undefined;\n        }\n      }\n\n      return retPos;\n    });\n\n    nodes.updateCompoundBounds(); // because the way this layout sets positions is buggy for some reason; ref #878\n\n    if (!ready) {\n      onReady();\n      ready = true;\n    }\n\n    if (options.fit) {\n      cy.fit(options.padding);\n    }\n  };\n\n  var onDone = function onDone() {\n    if (options.ungrabifyWhileSimulating) {\n      grabbableNodes.grabify();\n    }\n\n    cy.off('destroy', destroyHandler);\n\n    nodes.off('grab free position', grabHandler);\n    nodes.off('lock unlock', lockHandler);\n\n    // trigger layoutstop when the layout stops (e.g. finishes)\n    layout.one('layoutstop', options.stop);\n    layout.trigger({ type: 'layoutstop', layout: layout });\n  };\n\n  var onReady = function onReady() {\n    // trigger layoutready when each node has had its position set at least once\n    layout.one('layoutready', options.ready);\n    layout.trigger({ type: 'layoutready', layout: layout });\n  };\n\n  var ticksPerFrame = options.refresh;\n\n  if (options.refresh < 0) {\n    ticksPerFrame = 1;\n  } else {\n    ticksPerFrame = Math.max(1, ticksPerFrame); // at least 1\n  }\n\n  var adaptor = layout.adaptor = cola.adaptor({\n    trigger: function trigger(e) {\n      // on sim event\n      var TICK = cola.EventType ? cola.EventType.tick : null;\n      var END = cola.EventType ? cola.EventType.end : null;\n\n      switch (e.type) {\n        case 'tick':\n        case TICK:\n          if (options.animate) {\n            updateNodePositions();\n          }\n          break;\n\n        case 'end':\n        case END:\n          updateNodePositions();\n          if (!options.infinite) {\n            onDone();\n          }\n          break;\n      }\n    },\n\n    kick: function kick() {\n      // kick off the simulation\n      //let skip = 0;\n\n      var firstTick = true;\n\n      var inftick = function inftick() {\n        if (layout.manuallyStopped) {\n          onDone();\n\n          return true;\n        }\n\n        var ret = adaptor.tick();\n\n        if (!options.infinite && !firstTick) {\n          adaptor.convergenceThreshold(options.convergenceThreshold);\n        }\n\n        firstTick = false;\n\n        if (ret && options.infinite) {\n          // resume layout if done\n          adaptor.resume(); // resume => new kick\n        }\n\n        return ret; // allow regular finish b/c of new kick\n      };\n\n      var multitick = function multitick() {\n        // multiple ticks in a row\n        var ret = void 0;\n\n        for (var i = 0; i < ticksPerFrame && !ret; i++) {\n          ret = ret || inftick(); // pick up true ret vals => sim done\n        }\n\n        return ret;\n      };\n\n      if (options.animate) {\n        var frame = function frame() {\n          if (multitick()) {\n            return;\n          }\n\n          raf(frame);\n        };\n\n        raf(frame);\n      } else {\n        while (!inftick()) {\n          // keep going...\n        }\n      }\n    },\n\n    on: nop, // dummy; not needed\n\n    drag: nop // not needed for our case\n  });\n  layout.adaptor = adaptor;\n\n  // if set no grabbing during layout\n  var grabbableNodes = nodes.filter(':grabbable');\n  if (options.ungrabifyWhileSimulating) {\n    grabbableNodes.ungrabify();\n  }\n\n  var destroyHandler = void 0;\n  cy.one('destroy', destroyHandler = function destroyHandler() {\n    layout.stop();\n  });\n\n  // handle node dragging\n  var grabHandler = void 0;\n  nodes.on('grab free position', grabHandler = function grabHandler(e) {\n    var node = this;\n    var scrCola = node.scratch().cola;\n    var pos = node.position();\n    var nodeIsTarget = e.cyTarget === node || e.target === node;\n\n    if (!nodeIsTarget) {\n      return;\n    }\n\n    switch (e.type) {\n      case 'grab':\n        adaptor.dragstart(scrCola);\n        break;\n      case 'free':\n        adaptor.dragend(scrCola);\n        break;\n      case 'position':\n        // only update when different (i.e. manual .position() call or drag) so we don't loop needlessly\n        if (scrCola.px !== pos.x - bb.x1 || scrCola.py !== pos.y - bb.y1) {\n          scrCola.px = pos.x - bb.x1;\n          scrCola.py = pos.y - bb.y1;\n        }\n        break;\n    }\n  });\n\n  var lockHandler = void 0;\n  nodes.on('lock unlock', lockHandler = function lockHandler() {\n    var node = this;\n    var scrCola = node.scratch().cola;\n\n    scrCola.fixed = node.locked();\n\n    if (node.locked()) {\n      adaptor.dragstart(scrCola);\n    } else {\n      adaptor.dragend(scrCola);\n    }\n  });\n\n  // add nodes to cola\n  adaptor.nodes(nonparentNodes.map(function (node, i) {\n    var padding = getOptVal(options.nodeSpacing, node);\n    var pos = node.position();\n    var dimensions = node.layoutDimensions(options);\n\n    var struct = node.scratch().cola = {\n      x: options.randomize || pos.x === undefined ? Math.round(Math.random() * bb.w) : pos.x,\n      y: options.randomize || pos.y === undefined ? Math.round(Math.random() * bb.h) : pos.y,\n      width: dimensions.w + 2 * padding,\n      height: dimensions.h + 2 * padding,\n      index: i,\n      fixed: node.locked()\n    };\n\n    return struct;\n  }));\n\n  // the constraints to be added on nodes\n  var constraints = [];\n\n  if (options.alignment) {\n    // then set alignment constraints\n\n    var offsetsX = [];\n    var offsetsY = [];\n\n    nonparentNodes.forEach(function (node) {\n      var align = getOptVal(options.alignment, node);\n      var scrCola = node.scratch().cola;\n      var index = scrCola.index;\n\n      if (!align) {\n        return;\n      }\n\n      if (align.x != null) {\n        offsetsX.push({\n          node: index,\n          offset: align.x\n        });\n      }\n\n      if (align.y != null) {\n        offsetsY.push({\n          node: index,\n          offset: align.y\n        });\n      }\n    });\n\n    if (offsetsX.length > 0) {\n      constraints.push({\n        type: 'alignment',\n        axis: 'x',\n        offsets: offsetsX\n      });\n    }\n\n    if (offsetsY.length > 0) {\n      constraints.push({\n        type: 'alignment',\n        axis: 'y',\n        offsets: offsetsY\n      });\n    }\n  }\n\n  // if gapInequalities variable is set add each inequality constraint to list of constraints\n  if (options.gapInequalities) {\n    options.gapInequalities.forEach(function (inequality) {\n\n      // for the constraints to be passed to cola layout adaptor use indices of nodes,\n      // not the nodes themselves\n      var leftIndex = inequality.left.scratch().cola.index;\n      var rightIndex = inequality.right.scratch().cola.index;\n\n      constraints.push({\n        axis: inequality.axis,\n        left: leftIndex,\n        right: rightIndex,\n        gap: inequality.gap,\n        equality: inequality.equality\n      });\n    });\n  }\n\n  // add constraints if any\n  if (constraints.length > 0) {\n    adaptor.constraints(constraints);\n  }\n\n  // add compound nodes to cola\n  adaptor.groups(parentNodes.map(function (node, i) {\n    // add basic group incl leaf nodes\n    var optPadding = getOptVal(options.nodeSpacing, node);\n    var getPadding = function getPadding(d) {\n      return parseFloat(node.style('padding-' + d));\n    };\n\n    var pleft = getPadding('left') + optPadding;\n    var pright = getPadding('right') + optPadding;\n    var ptop = getPadding('top') + optPadding;\n    var pbottom = getPadding('bottom') + optPadding;\n\n    node.scratch().cola = {\n      index: i,\n\n      padding: Math.max(pleft, pright, ptop, pbottom),\n\n      // leaves should only contain direct descendants (children),\n      // not the leaves of nested compound nodes or any nodes that are compounds themselves\n      leaves: node.children().intersection(nonparentNodes).map(function (child) {\n        return child[0].scratch().cola.index;\n      }),\n\n      fixed: node.locked()\n    };\n\n    return node;\n  }).map(function (node) {\n    // add subgroups\n    node.scratch().cola.groups = node.children().intersection(parentNodes).map(function (child) {\n      return child.scratch().cola.index;\n    });\n\n    return node.scratch().cola;\n  }));\n\n  // get the edge length setting mechanism\n  var length = void 0;\n  var lengthFnName = void 0;\n  if (options.edgeLength != null) {\n    length = options.edgeLength;\n    lengthFnName = 'linkDistance';\n  } else if (options.edgeSymDiffLength != null) {\n    length = options.edgeSymDiffLength;\n    lengthFnName = 'symmetricDiffLinkLengths';\n  } else if (options.edgeJaccardLength != null) {\n    length = options.edgeJaccardLength;\n    lengthFnName = 'jaccardLinkLengths';\n  } else {\n    length = 100;\n    lengthFnName = 'linkDistance';\n  }\n\n  var lengthGetter = function lengthGetter(link) {\n    return link.calcLength;\n  };\n\n  // add the edges to cola\n  adaptor.links(edges.stdFilter(function (edge) {\n    return nonparentNodes.contains(edge.source()) && nonparentNodes.contains(edge.target());\n  }).map(function (edge) {\n    var c = edge.scratch().cola = {\n      source: edge.source()[0].scratch().cola.index,\n      target: edge.target()[0].scratch().cola.index\n    };\n\n    if (length != null) {\n      c.calcLength = getOptVal(length, edge);\n    }\n\n    return c;\n  }));\n\n  adaptor.size([bb.w, bb.h]);\n\n  if (length != null) {\n    adaptor[lengthFnName](lengthGetter);\n  }\n\n  // set the flow of cola\n  if (options.flow) {\n    var flow = void 0;\n    var defAxis = 'y';\n    var defMinSep = 50;\n\n    if (isString(options.flow)) {\n      flow = {\n        axis: options.flow,\n        minSeparation: defMinSep\n      };\n    } else if (isNumber(options.flow)) {\n      flow = {\n        axis: defAxis,\n        minSeparation: options.flow\n      };\n    } else if (isObject(options.flow)) {\n      flow = options.flow;\n\n      flow.axis = flow.axis || defAxis;\n      flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;\n    } else {\n      // e.g. options.flow: true\n      flow = {\n        axis: defAxis,\n        minSeparation: defMinSep\n      };\n    }\n\n    adaptor.flowLayout(flow.axis, flow.minSeparation);\n  }\n\n  layout.trigger({ type: 'layoutstart', layout: layout });\n\n  adaptor.avoidOverlaps(options.avoidOverlap).handleDisconnected(options.handleDisconnected).start(options.unconstrIter, options.userConstIter, options.allConstIter);\n\n  if (!options.infinite) {\n    setTimeout(function () {\n      if (!layout.manuallyStopped) {\n        adaptor.stop();\n      }\n    }, options.maxSimulationTime);\n  }\n\n  return this; // chaining\n};\n\n// called on continuous layouts to stop them before they finish\nColaLayout.prototype.stop = function () {\n  if (this.adaptor) {\n    this.manuallyStopped = true;\n    this.adaptor.stop();\n  }\n\n  return this; // chaining\n};\n\nmodule.exports = ColaLayout;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.filter(function (src) {\n    return src != null;\n  }).forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// default layout options\nvar defaults = {\n  animate: true, // whether to show the layout as it's running\n  refresh: 1, // number of ticks per frame; higher is faster but more jerky\n  maxSimulationTime: 4000, // max length in ms to run the layout\n  ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n  fit: true, // on every layout reposition of nodes, fit the viewport\n  padding: 30, // padding around the simulation\n  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n  nodeDimensionsIncludeLabels: false, // whether labels should be included in determining the space used by a node\n\n  // layout event callbacks\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {}, // on layoutstop\n\n  // positioning options\n  randomize: false, // use random node positions at beginning of layout\n  avoidOverlap: true, // if true, prevents overlap of node bounding boxes\n  handleDisconnected: true, // if true, avoids disconnected components from overlapping\n  convergenceThreshold: 0.01, // when the alpha value (system energy) falls below this value, the layout stops\n  nodeSpacing: function nodeSpacing(node) {\n    return 10;\n  }, // extra spacing around nodes\n  flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }\n  alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }\n  gapInequalities: undefined, // list of inequality constraints for the gap between the nodes, e.g. [{\"axis\":\"y\", \"left\":node1, \"right\":node2, \"gap\":25}]\n\n  // different methods of specifying edge length\n  // each can be a constant numerical value or a function like `function( edge ){ return 2; }`\n  edgeLength: undefined, // sets edge length directly in simulation\n  edgeSymDiffLength: undefined, // symmetric diff edge length in simulation\n  edgeJaccardLength: undefined, // jaccard edge length in simulation\n\n  // iterations of cola algorithm; uses default values on undefined\n  unconstrIter: undefined, // unconstrained initial layout iterations\n  userConstIter: undefined, // initial layout iterations with user-specified constraints\n  allConstIter: undefined, // initial layout iterations with all constraints including non-overlap\n\n  // infinite layout options\n  infinite: false // overrides all other options for a forces-all-the-time mode\n};\n\nmodule.exports = defaults;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar impl = __webpack_require__(0);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'cola', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar raf = void 0;\n\nif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) !== ( true ? \"undefined\" : _typeof(undefined))) {\n  raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (fn) {\n    return setTimeout(fn, 16);\n  };\n} else {\n  // if not available, all you get is immediate calls\n  raf = function raf(cb) {\n    cb();\n  };\n}\n\nmodule.exports = raf;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ })\n/******/ ]);\n});"]},"metadata":{},"sourceType":"script"}