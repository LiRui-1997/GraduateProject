{"ast":null,"code":"import _objectSpread from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { genStatsKey, statsQueryToKey } from 'types/MetricsOptions';\nimport { average } from '../MathUtils';\nexport var averageSpanDuration = function averageSpanDuration(trace) {\n  var spansWithDuration = trace.spans.filter(function (s) {\n    return s.duration && s.duration > 0;\n  });\n  return average(spansWithDuration, function (span) {\n    return span.duration;\n  });\n};\nexport var isSimilarTrace = function isSimilarTrace(t1, t2) {\n  if (t1.spans.length === 0 || t2.spans.length === 0) {\n    // Shouldn't happen... but avoid /0 anyway\n    return false;\n  } // Similarity algorithm:\n  //  First criteria: if numbers of spans are close\n  //  Second criteria: we'll count the number of occurrences of operations per trace, and look at the highest occuring operations.\n  //  The closest their count are, the more similar the traces are.\n\n\n  var nbSpansScore = distanceScore(t1.spans.length, t2.spans.length);\n  var countOperations = new Map();\n  t1.spans.forEach(function (s) {\n    var counter = countOperations.get(s.operationName);\n\n    if (counter) {\n      counter.t1++;\n    } else {\n      countOperations.set(s.operationName, {\n        op: s.operationName,\n        t1: 1,\n        t2: 0\n      });\n    }\n  });\n  t2.spans.forEach(function (s) {\n    var counter = countOperations.get(s.operationName);\n\n    if (counter) {\n      counter.t2++;\n    } else {\n      countOperations.set(s.operationName, {\n        op: s.operationName,\n        t1: 0,\n        t2: 1\n      });\n    }\n  });\n  var values = Array.from(countOperations.values());\n\n  var operationSimilarityScore = function operationSimilarityScore(counterGetter) {\n    var sorted = values.sort(function (a, b) {\n      return counterGetter(b) - counterGetter(a);\n    });\n    var score = 0;\n    var total = Math.min(4, sorted.length);\n\n    for (var i = 0; i < total; i++) {\n      score += distanceScore(sorted[i].t1, sorted[i].t2);\n    }\n\n    return score / total;\n  };\n\n  var score1 = operationSimilarityScore(function (counter) {\n    return counter.t1;\n  });\n  var score2 = operationSimilarityScore(function (counter) {\n    return counter.t2;\n  });\n  var total = (nbSpansScore + score1 + score2) / 3; // Arbitrary threshold: score below 0.3 means \"similar\"\n\n  return total < 0.3;\n};\n\nvar distanceScore = function distanceScore(n1, n2) {\n  // Some score of how two numbers are \"close\" to each other\n  return Math.abs(n1 - n2) / Math.max(1, Math.max(n1, n2));\n};\n\nvar statsQuantiles = ['0.5', '0.9', '0.99'];\nexport var statsAvgWithQuantiles = ['avg'].concat(statsQuantiles);\nexport var allStatsIntervals = ['10m', '60m', '6h'];\nexport var compactStatsIntervals = ['60m', '6h'];\nexport var statsPerPeer = false;\nexport var statsCompareKind = 'workload';\nexport var buildQueriesFromSpans = function buildQueriesFromSpans(items) {\n  var queryTime = Math.floor(Date.now() / 1000); // Load stats for first 10 spans, to avoid heavy loading. More stats can be loaded individually.\n\n  var queries = items.filter(function (s) {\n    return s.type === 'envoy';\n  }).slice(0, 10).flatMap(function (item) {\n    var info = item.info;\n\n    if (!info.direction) {\n      console.warn('Could not determine direction from Envoy span.');\n      return [];\n    }\n\n    if (statsPerPeer && !info.peer) {\n      console.warn('Could not determine peer from Envoy span.');\n      return [];\n    }\n\n    var name = statsCompareKind === 'app' ? item.app : item.workload;\n\n    if (!name) {\n      console.warn('Could not determine workload from Envoy span.');\n      return [];\n    }\n\n    var query = {\n      queryTime: queryTime,\n      target: {\n        namespace: item.namespace,\n        name: name,\n        kind: statsCompareKind\n      },\n      peerTarget: statsPerPeer ? info.peer : undefined,\n      interval: '',\n      // placeholder\n      direction: info.direction,\n      avg: true,\n      quantiles: statsQuantiles\n    };\n    return allStatsIntervals.map(function (interval) {\n      return _objectSpread(_objectSpread({}, query), {}, {\n        interval: interval\n      });\n    });\n  });\n  return deduplicateMetricQueries(queries);\n};\n\nvar deduplicateMetricQueries = function deduplicateMetricQueries(queries) {\n  // Exclude redundant queries based on this keygen as a merger, + hashmap\n  var dedup = new Map();\n  queries.forEach(function (q) {\n    var key = statsQueryToKey(q);\n\n    if (key) {\n      dedup.set(key, q);\n    }\n  });\n  return Array.from(dedup.values());\n};\n\nexport var initStatsMatrix = function initStatsMatrix(intervals) {\n  return new Array(statsAvgWithQuantiles.length).fill(0).map(function () {\n    return new Array(intervals.length).fill(0).map(function () {\n      return undefined;\n    });\n  });\n};\nexport var statsToMatrix = function statsToMatrix(itemStats, intervals) {\n  var matrix = initStatsMatrix(intervals);\n  itemStats.forEach(function (stats) {\n    stats.responseTimes.forEach(function (stat) {\n      var x = statsAvgWithQuantiles.indexOf(stat.name);\n\n      if (x >= 0) {\n        matrix[x][stats.intervalIndex] = stat.value;\n      }\n    });\n  });\n  return matrix;\n};\nexport var getSpanStats = function getSpanStats(item, intervals, metricsStats) {\n  return intervals.flatMap(function (interval, intervalIndex) {\n    var info = item.info;\n    var target = {\n      namespace: item.namespace,\n      name: statsCompareKind === 'app' ? item.app : item.workload,\n      kind: statsCompareKind\n    };\n    var key = genStatsKey(target, statsPerPeer ? info.peer : undefined, info.direction, interval);\n\n    if (key) {\n      var stats = metricsStats.get(key);\n\n      if (stats) {\n        var baseLine = item.duration / 1000;\n        var statsDiff = stats.responseTimes.map(function (stat) {\n          return {\n            name: stat.name,\n            value: baseLine - stat.value\n          };\n        });\n        return [{\n          responseTimes: statsDiff,\n          intervalIndex: intervalIndex\n        }];\n      }\n    }\n\n    return [];\n  });\n};\nexport var reduceMetricsStats = function reduceMetricsStats(trace, intervals, allStats) {\n  var isComplete = true; // Aggregate all spans stats, per stat name/interval, into a temporary map\n\n  var aggregatedStats = new Map();\n  trace.spans.filter(function (s) {\n    return s.type === 'envoy';\n  }).forEach(function (span) {\n    var spanStats = getSpanStats(span, intervals, allStats);\n\n    if (spanStats.length > 0) {\n      spanStats.forEach(function (statsPerInterval) {\n        statsPerInterval.responseTimes.forEach(function (stat) {\n          var aggKey = stat.name + '@' + statsPerInterval.intervalIndex;\n          var aggStat = aggregatedStats.get(aggKey);\n\n          if (aggStat) {\n            aggStat.values.push(stat.value);\n          } else {\n            aggregatedStats.set(aggKey, {\n              name: stat.name,\n              intervalIndex: statsPerInterval.intervalIndex,\n              values: [stat.value]\n            });\n          }\n        });\n      });\n    } else {\n      isComplete = false;\n    }\n  }); // Convert the temporary map into a matrix\n\n  var matrix = initStatsMatrix(intervals);\n  aggregatedStats.forEach(function (aggStat) {\n    // compute mean per stat\n    var x = statsAvgWithQuantiles.indexOf(aggStat.name);\n\n    if (x >= 0) {\n      var len = aggStat.values.length;\n\n      if (len > 0) {\n        matrix[x][aggStat.intervalIndex] = aggStat.values.reduce(function (p, c) {\n          return p + c;\n        }, 0) / len;\n      }\n    }\n  });\n  return {\n    matrix: matrix,\n    isComplete: isComplete\n  };\n};","map":{"version":3,"sources":["/root/kiali-ui/src/utils/tracing/TraceStats.ts"],"names":["genStatsKey","statsQueryToKey","average","averageSpanDuration","trace","spansWithDuration","spans","filter","s","duration","span","isSimilarTrace","t1","t2","length","nbSpansScore","distanceScore","countOperations","Map","forEach","counter","get","operationName","set","op","values","Array","from","operationSimilarityScore","counterGetter","sorted","sort","a","b","score","total","Math","min","i","score1","score2","n1","n2","abs","max","statsQuantiles","statsAvgWithQuantiles","allStatsIntervals","compactStatsIntervals","statsPerPeer","statsCompareKind","buildQueriesFromSpans","items","queryTime","floor","Date","now","queries","type","slice","flatMap","item","info","direction","console","warn","peer","name","app","workload","query","target","namespace","kind","peerTarget","undefined","interval","avg","quantiles","map","deduplicateMetricQueries","dedup","q","key","initStatsMatrix","intervals","fill","statsToMatrix","itemStats","matrix","stats","responseTimes","stat","x","indexOf","intervalIndex","value","getSpanStats","metricsStats","baseLine","statsDiff","reduceMetricsStats","allStats","isComplete","aggregatedStats","spanStats","statsPerInterval","aggKey","aggStat","push","len","reduce","p","c"],"mappings":"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","sourcesContent":["import { EnvoySpanInfo, JaegerTrace, RichSpanData } from 'types/JaegerInfo';\nimport { MetricsStats } from 'types/Metrics';\nimport { genStatsKey, MetricsStatsQuery, statsQueryToKey } from 'types/MetricsOptions';\nimport { average } from '../MathUtils';\n\nexport const averageSpanDuration = (trace: JaegerTrace): number | undefined => {\n  const spansWithDuration = trace.spans.filter(s => s.duration && s.duration > 0);\n  return average(spansWithDuration, span => span.duration);\n};\n\nexport const isSimilarTrace = (t1: JaegerTrace, t2: JaegerTrace): boolean => {\n  if (t1.spans.length === 0 || t2.spans.length === 0) {\n    // Shouldn't happen... but avoid /0 anyway\n    return false;\n  }\n  // Similarity algorithm:\n  //  First criteria: if numbers of spans are close\n  //  Second criteria: we'll count the number of occurrences of operations per trace, and look at the highest occuring operations.\n  //  The closest their count are, the more similar the traces are.\n  const nbSpansScore = distanceScore(t1.spans.length, t2.spans.length);\n  type OpOccur = { op: string; t1: number; t2: number };\n  const countOperations = new Map<String, OpOccur>();\n  t1.spans.forEach(s => {\n    const counter = countOperations.get(s.operationName);\n    if (counter) {\n      counter.t1++;\n    } else {\n      countOperations.set(s.operationName, { op: s.operationName, t1: 1, t2: 0 });\n    }\n  });\n  t2.spans.forEach(s => {\n    const counter = countOperations.get(s.operationName);\n    if (counter) {\n      counter.t2++;\n    } else {\n      countOperations.set(s.operationName, { op: s.operationName, t1: 0, t2: 1 });\n    }\n  });\n  const values = Array.from(countOperations.values());\n  const operationSimilarityScore = (counterGetter: (counter: OpOccur) => number): number => {\n    const sorted = values.sort((a, b) => counterGetter(b) - counterGetter(a));\n    let score = 0;\n    const total = Math.min(4, sorted.length);\n    for (let i = 0; i < total; i++) {\n      score += distanceScore(sorted[i].t1, sorted[i].t2);\n    }\n    return score / total;\n  };\n  const score1 = operationSimilarityScore(counter => counter.t1);\n  const score2 = operationSimilarityScore(counter => counter.t2);\n  const total = (nbSpansScore + score1 + score2) / 3;\n  // Arbitrary threshold: score below 0.3 means \"similar\"\n  return total < 0.3;\n};\n\nconst distanceScore = (n1: number, n2: number): number => {\n  // Some score of how two numbers are \"close\" to each other\n  return Math.abs(n1 - n2) / Math.max(1, Math.max(n1, n2));\n};\nconst statsQuantiles = ['0.5', '0.9', '0.99'];\nexport const statsAvgWithQuantiles = ['avg', ...statsQuantiles];\nexport const allStatsIntervals = ['10m', '60m', '6h'];\nexport const compactStatsIntervals = ['60m', '6h'];\nexport const statsPerPeer = false;\nexport let statsCompareKind: 'app' | 'workload' = 'workload';\n\nexport const buildQueriesFromSpans = (items: RichSpanData[]) => {\n  const queryTime = Math.floor(Date.now() / 1000);\n  // Load stats for first 10 spans, to avoid heavy loading. More stats can be loaded individually.\n  const queries = items\n    .filter(s => s.type === 'envoy')\n    .slice(0, 10)\n    .flatMap(item => {\n      const info = item.info as EnvoySpanInfo;\n      if (!info.direction) {\n        console.warn('Could not determine direction from Envoy span.');\n        return [];\n      }\n      if (statsPerPeer && !info.peer) {\n        console.warn('Could not determine peer from Envoy span.');\n        return [];\n      }\n      const name = statsCompareKind === 'app' ? item.app : item.workload;\n      if (!name) {\n        console.warn('Could not determine workload from Envoy span.');\n        return [];\n      }\n      const query: MetricsStatsQuery = {\n        queryTime: queryTime,\n        target: {\n          namespace: item.namespace,\n          name: name,\n          kind: statsCompareKind\n        },\n        peerTarget: statsPerPeer ? info.peer : undefined,\n        interval: '', // placeholder\n        direction: info.direction,\n        avg: true,\n        quantiles: statsQuantiles\n      };\n      return allStatsIntervals.map(interval => ({ ...query, interval: interval }));\n    });\n  return deduplicateMetricQueries(queries);\n};\n\nconst deduplicateMetricQueries = (queries: MetricsStatsQuery[]) => {\n  // Exclude redundant queries based on this keygen as a merger, + hashmap\n  const dedup = new Map<string, MetricsStatsQuery>();\n  queries.forEach(q => {\n    const key = statsQueryToKey(q);\n    if (key) {\n      dedup.set(key, q);\n    }\n  });\n  return Array.from(dedup.values());\n};\n\nexport type StatsWithIntervalIndex = MetricsStats & { intervalIndex: number };\nexport type StatsMatrix = (number | undefined)[][];\nexport const initStatsMatrix = (intervals: string[]): StatsMatrix => {\n  return new Array(statsAvgWithQuantiles.length)\n    .fill(0)\n    .map(() => new Array(intervals.length).fill(0).map(() => undefined));\n};\n\nexport const statsToMatrix = (itemStats: StatsWithIntervalIndex[], intervals: string[]): StatsMatrix => {\n  const matrix = initStatsMatrix(intervals);\n  itemStats.forEach(stats => {\n    stats.responseTimes.forEach(stat => {\n      const x = statsAvgWithQuantiles.indexOf(stat.name);\n      if (x >= 0) {\n        matrix[x][stats.intervalIndex] = stat.value;\n      }\n    });\n  });\n  return matrix;\n};\n\nexport const getSpanStats = (\n  item: RichSpanData,\n  intervals: string[],\n  metricsStats: Map<string, MetricsStats>\n): StatsWithIntervalIndex[] => {\n  return intervals.flatMap((interval, intervalIndex) => {\n    const info = item.info as EnvoySpanInfo;\n    const target = {\n      namespace: item.namespace,\n      name: statsCompareKind === 'app' ? item.app : item.workload!,\n      kind: statsCompareKind\n    };\n    const key = genStatsKey(target, statsPerPeer ? info.peer : undefined, info.direction!, interval);\n    if (key) {\n      const stats = metricsStats.get(key);\n      if (stats) {\n        const baseLine = item.duration / 1000;\n        const statsDiff = stats.responseTimes.map(stat => {\n          return { name: stat.name, value: baseLine - stat.value };\n        });\n        return [{ responseTimes: statsDiff, intervalIndex: intervalIndex }];\n      }\n    }\n    return [];\n  });\n};\n\nexport const reduceMetricsStats = (trace: JaegerTrace, intervals: string[], allStats: Map<string, MetricsStats>) => {\n  let isComplete = true;\n  // Aggregate all spans stats, per stat name/interval, into a temporary map\n  type AggregatedStat = { name: string; intervalIndex: number; values: number[] };\n  const aggregatedStats = new Map<string, AggregatedStat>();\n  trace.spans\n    .filter(s => s.type === 'envoy')\n    .forEach(span => {\n      const spanStats = getSpanStats(span, intervals, allStats);\n      if (spanStats.length > 0) {\n        spanStats.forEach(statsPerInterval => {\n          statsPerInterval.responseTimes.forEach(stat => {\n            const aggKey = stat.name + '@' + statsPerInterval.intervalIndex;\n            const aggStat = aggregatedStats.get(aggKey);\n            if (aggStat) {\n              aggStat.values.push(stat.value);\n            } else {\n              aggregatedStats.set(aggKey, {\n                name: stat.name,\n                intervalIndex: statsPerInterval.intervalIndex,\n                values: [stat.value]\n              });\n            }\n          });\n        });\n      } else {\n        isComplete = false;\n      }\n    });\n  // Convert the temporary map into a matrix\n  const matrix = initStatsMatrix(intervals);\n  aggregatedStats.forEach(aggStat => {\n    // compute mean per stat\n    const x = statsAvgWithQuantiles.indexOf(aggStat.name);\n    if (x >= 0) {\n      const len = aggStat.values.length;\n      if (len > 0) {\n        matrix[x][aggStat.intervalIndex] = aggStat.values.reduce((p, c) => p + c, 0) / len;\n      }\n    }\n  });\n  return { matrix: matrix, isComplete: isComplete };\n};\n"]},"metadata":{},"sourceType":"module"}