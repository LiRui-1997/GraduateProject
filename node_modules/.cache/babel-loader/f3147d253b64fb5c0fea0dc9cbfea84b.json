{"ast":null,"code":"import _slicedToArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar allMatch = new RegExp('.*');\n/*\n Parse configuration from backend format to regex expression\n*/\n\nexport var parseHealthConfig = function parseHealthConfig(healthConfig) {\n  for (var _i = 0, _Object$entries = Object.entries(healthConfig.rate); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        r = _Object$entries$_i[1];\n\n    healthConfig.rate[key].namespace = getExpr(healthConfig.rate[key].namespace);\n    healthConfig.rate[key].name = getExpr(healthConfig.rate[key].name);\n    healthConfig.rate[key].kind = getExpr(healthConfig.rate[key].kind);\n\n    for (var _i2 = 0, _Object$values = Object.values(r.tolerance); _i2 < _Object$values.length; _i2++) {\n      var t = _Object$values[_i2];\n      t.code = getExpr(t.code, true);\n      t.direction = getExpr(t.direction);\n      t.protocol = getExpr(t.protocol);\n    }\n  }\n\n  return healthConfig;\n};\n/*\n  Convert the string to regex, if isCode is true then call to replaceXCode to change the X|x in code expression to \\d\n*/\n\nexport var getExpr = function getExpr(value) {\n  var isCode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (value) {\n    if (typeof value === 'string' && value !== '') {\n      var v = value.replace('\\\\\\\\', '\\\\');\n      return new RegExp(isCode ? replaceXCode(v) : v);\n    }\n\n    if (typeof value === 'object' && value.toString() !== '/(?:)/') {\n      return value;\n    }\n  }\n\n  return allMatch;\n};\n/* Replace x|X by the regular expression\n   Example: 4XX or 5XX to 4\\d\\d 5\\d\\d\n*/\n\nvar replaceXCode = function replaceXCode(value) {\n  return value.replace(/x|X/g, '\\\\d');\n};\n/*\n Export for tests\n*/\n\n\nexport var allMatchTEST = allMatch;\nexport var getExprTEST = getExpr;\nexport var replaceXCodeTEST = replaceXCode;","map":{"version":3,"sources":["/root/kiali-ui/src/config/HealthConfig.ts"],"names":["allMatch","RegExp","parseHealthConfig","healthConfig","Object","entries","rate","key","r","namespace","getExpr","name","kind","values","tolerance","t","code","direction","protocol","value","isCode","v","replace","replaceXCode","toString","allMatchTEST","getExprTEST","replaceXCodeTEST"],"mappings":";AAEA,IAAMA,QAAQ,GAAG,IAAIC,MAAJ,CAAW,IAAX,CAAjB;AAEA;AACA;AACA;;AACA,OAAO,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,YAAD,EAAgC;AAC/D,qCAAqBC,MAAM,CAACC,OAAP,CAAeF,YAAY,CAACG,IAA5B,CAArB,qCAAwD;AAAnD;AAAA,QAAKC,GAAL;AAAA,QAAUC,CAAV;;AACHL,IAAAA,YAAY,CAACG,IAAb,CAAkBC,GAAlB,EAAuBE,SAAvB,GAAmCC,OAAO,CAACP,YAAY,CAACG,IAAb,CAAkBC,GAAlB,EAAuBE,SAAxB,CAA1C;AACAN,IAAAA,YAAY,CAACG,IAAb,CAAkBC,GAAlB,EAAuBI,IAAvB,GAA8BD,OAAO,CAACP,YAAY,CAACG,IAAb,CAAkBC,GAAlB,EAAuBI,IAAxB,CAArC;AACAR,IAAAA,YAAY,CAACG,IAAb,CAAkBC,GAAlB,EAAuBK,IAAvB,GAA8BF,OAAO,CAACP,YAAY,CAACG,IAAb,CAAkBC,GAAlB,EAAuBK,IAAxB,CAArC;;AACA,uCAAcR,MAAM,CAACS,MAAP,CAAcL,CAAC,CAACM,SAAhB,CAAd,sCAA0C;AAArC,UAAIC,CAAC,sBAAL;AACHA,MAAAA,CAAC,CAACC,IAAF,GAASN,OAAO,CAACK,CAAC,CAACC,IAAH,EAAS,IAAT,CAAhB;AACAD,MAAAA,CAAC,CAACE,SAAF,GAAcP,OAAO,CAACK,CAAC,CAACE,SAAH,CAArB;AACAF,MAAAA,CAAC,CAACG,QAAF,GAAaR,OAAO,CAACK,CAAC,CAACG,QAAH,CAApB;AACD;AACF;;AACD,SAAOf,YAAP;AACD,CAZM;AAcP;AACA;AACA;;AACA,OAAO,IAAMO,OAAO,GAAG,SAAVA,OAAU,CAACS,KAAD,EAAqE;AAAA,MAApCC,MAAoC,uEAAlB,KAAkB;;AAC1F,MAAID,KAAJ,EAAW;AACT,QAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,EAA3C,EAA+C;AAC7C,UAAME,CAAC,GAAGF,KAAK,CAACG,OAAN,CAAc,MAAd,EAAsB,IAAtB,CAAV;AACA,aAAO,IAAIrB,MAAJ,CAAWmB,MAAM,GAAGG,YAAY,CAACF,CAAD,CAAf,GAAqBA,CAAtC,CAAP;AACD;;AACD,QAAI,OAAOF,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACK,QAAN,OAAqB,QAAtD,EAAgE;AAC9D,aAAOL,KAAP;AACD;AACF;;AACD,SAAOnB,QAAP;AACD,CAXM;AAaP;AACA;AACA;;AACA,IAAMuB,YAAY,GAAG,SAAfA,YAAe,CAACJ,KAAD,EAA2B;AAC9C,SAAOA,KAAK,CAACG,OAAN,CAAc,MAAd,EAAsB,KAAtB,CAAP;AACD,CAFD;AAIA;AACA;AACA;;;AACA,OAAO,IAAMG,YAAY,GAAGzB,QAArB;AACP,OAAO,IAAM0B,WAAW,GAAGhB,OAApB;AACP,OAAO,IAAMiB,gBAAgB,GAAGJ,YAAzB","sourcesContent":["import { HealthConfig, RegexConfig } from '../types/ServerConfig';\n\nconst allMatch = new RegExp('.*');\n\n/*\n Parse configuration from backend format to regex expression\n*/\nexport const parseHealthConfig = (healthConfig: HealthConfig) => {\n  for (let [key, r] of Object.entries(healthConfig.rate)) {\n    healthConfig.rate[key].namespace = getExpr(healthConfig.rate[key].namespace);\n    healthConfig.rate[key].name = getExpr(healthConfig.rate[key].name);\n    healthConfig.rate[key].kind = getExpr(healthConfig.rate[key].kind);\n    for (let t of Object.values(r.tolerance)) {\n      t.code = getExpr(t.code, true);\n      t.direction = getExpr(t.direction);\n      t.protocol = getExpr(t.protocol);\n    }\n  }\n  return healthConfig;\n};\n\n/*\n  Convert the string to regex, if isCode is true then call to replaceXCode to change the X|x in code expression to \\d\n*/\nexport const getExpr = (value: RegexConfig | undefined, isCode: boolean = false): RegExp => {\n  if (value) {\n    if (typeof value === 'string' && value !== '') {\n      const v = value.replace('\\\\\\\\', '\\\\');\n      return new RegExp(isCode ? replaceXCode(v) : v);\n    }\n    if (typeof value === 'object' && value.toString() !== '/(?:)/') {\n      return value;\n    }\n  }\n  return allMatch;\n};\n\n/* Replace x|X by the regular expression\n   Example: 4XX or 5XX to 4\\d\\d 5\\d\\d\n*/\nconst replaceXCode = (value: string): string => {\n  return value.replace(/x|X/g, '\\\\d');\n};\n\n/*\n Export for tests\n*/\nexport const allMatchTEST = allMatch;\nexport const getExprTEST = getExpr;\nexport const replaceXCodeTEST = replaceXCode;\n"]},"metadata":{},"sourceType":"module"}