{"ast":null,"code":"import _toConsumableArray from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as Api from '../services/Api';\nimport { NamespaceActions } from './NamespaceAction';\n\nvar shouldFetchNamespaces = function shouldFetchNamespaces(state) {\n  if (!state) {\n    return true;\n  } else {\n    return !state.namespaces.isFetching;\n  }\n};\n\nvar NamespaceThunkActions = {\n  asyncFetchNamespaces: function asyncFetchNamespaces() {\n    return function (dispatch) {\n      dispatch(NamespaceActions.requestStarted());\n      return Api.getNamespaces().then(function (response) {\n        return response.data;\n      }).then(function (data) {\n        dispatch(NamespaceActions.receiveList(_toConsumableArray(data), new Date()));\n      }).catch(function () {\n        return dispatch(NamespaceActions.requestFailed());\n      });\n    };\n  },\n  fetchNamespacesIfNeeded: function fetchNamespacesIfNeeded() {\n    // Note that the function also receives getState()\n    // which lets you choose what to dispatch next.\n    // This is useful for avoiding a network request if\n    // a cached value is already available.\n    return function (dispatch, getState) {\n      if (shouldFetchNamespaces(getState())) {\n        var state = getState().authentication;\n\n        if (!state || !state.session) {\n          return Promise.resolve();\n        } // Dispatch a thunk from thunk!\n\n\n        return dispatch(NamespaceThunkActions.asyncFetchNamespaces());\n      } else {\n        // Let the calling code know there's nothing to wait for.\n        return Promise.resolve();\n      }\n    };\n  }\n};\nexport default NamespaceThunkActions;","map":{"version":3,"sources":["/root/GraduateProject/src/actions/NamespaceThunkActions.ts"],"names":["Api","NamespaceActions","shouldFetchNamespaces","state","namespaces","isFetching","NamespaceThunkActions","asyncFetchNamespaces","dispatch","requestStarted","getNamespaces","then","response","data","receiveList","Date","catch","requestFailed","fetchNamespacesIfNeeded","getState","authentication","session","Promise","resolve"],"mappings":";AAEA,OAAO,KAAKA,GAAZ,MAAqB,iBAArB;AAEA,SAASC,gBAAT,QAAiC,mBAAjC;;AAEA,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACC,KAAD,EAA0B;AACtD,MAAI,CAACA,KAAL,EAAY;AACV,WAAO,IAAP;AACD,GAFD,MAEO;AACL,WAAO,CAACA,KAAK,CAACC,UAAN,CAAiBC,UAAzB;AACD;AACF,CAND;;AAQA,IAAMC,qBAAqB,GAAG;AAC5BC,EAAAA,oBAAoB,EAAE,gCAAM;AAC1B,WAAO,UAACC,QAAD,EAAkE;AACvEA,MAAAA,QAAQ,CAACP,gBAAgB,CAACQ,cAAjB,EAAD,CAAR;AACA,aAAOT,GAAG,CAACU,aAAJ,GACJC,IADI,CACC,UAAAC,QAAQ;AAAA,eAAIA,QAAQ,CAACC,IAAb;AAAA,OADT,EAEJF,IAFI,CAEC,UAAAE,IAAI,EAAI;AACZL,QAAAA,QAAQ,CAACP,gBAAgB,CAACa,WAAjB,oBAAiCD,IAAjC,GAAwC,IAAIE,IAAJ,EAAxC,CAAD,CAAR;AACD,OAJI,EAKJC,KALI,CAKE;AAAA,eAAMR,QAAQ,CAACP,gBAAgB,CAACgB,aAAjB,EAAD,CAAd;AAAA,OALF,CAAP;AAMD,KARD;AASD,GAX2B;AAa5BC,EAAAA,uBAAuB,EAAE,mCAAM;AAC7B;AACA;AACA;AACA;AACA,WAAO,UAACV,QAAD,EAA+DW,QAA/D,EAAiG;AACtG,UAAIjB,qBAAqB,CAACiB,QAAQ,EAAT,CAAzB,EAAuC;AACrC,YAAMhB,KAAK,GAAGgB,QAAQ,GAAGC,cAAzB;;AAEA,YAAI,CAACjB,KAAD,IAAU,CAACA,KAAK,CAACkB,OAArB,EAA8B;AAC5B,iBAAOC,OAAO,CAACC,OAAR,EAAP;AACD,SALoC,CAOrC;;;AACA,eAAOf,QAAQ,CAACF,qBAAqB,CAACC,oBAAtB,EAAD,CAAf;AACD,OATD,MASO;AACL;AACA,eAAOe,OAAO,CAACC,OAAR,EAAP;AACD;AACF,KAdD;AAeD;AAjC2B,CAA9B;AAoCA,eAAejB,qBAAf","sourcesContent":["import { ThunkDispatch } from 'redux-thunk';\nimport { KialiAppState } from '../store/Store';\nimport * as Api from '../services/Api';\nimport { KialiAppAction } from './KialiAppAction';\nimport { NamespaceActions } from './NamespaceAction';\n\nconst shouldFetchNamespaces = (state: KialiAppState) => {\n  if (!state) {\n    return true;\n  } else {\n    return !state.namespaces.isFetching;\n  }\n};\n\nconst NamespaceThunkActions = {\n  asyncFetchNamespaces: () => {\n    return (dispatch: ThunkDispatch<KialiAppState, void, KialiAppAction>) => {\n      dispatch(NamespaceActions.requestStarted());\n      return Api.getNamespaces()\n        .then(response => response.data)\n        .then(data => {\n          dispatch(NamespaceActions.receiveList([...data], new Date()));\n        })\n        .catch(() => dispatch(NamespaceActions.requestFailed()));\n    };\n  },\n\n  fetchNamespacesIfNeeded: () => {\n    // Note that the function also receives getState()\n    // which lets you choose what to dispatch next.\n    // This is useful for avoiding a network request if\n    // a cached value is already available.\n    return (dispatch: ThunkDispatch<KialiAppState, void, KialiAppAction>, getState: () => KialiAppState) => {\n      if (shouldFetchNamespaces(getState())) {\n        const state = getState().authentication;\n\n        if (!state || !state.session) {\n          return Promise.resolve();\n        }\n\n        // Dispatch a thunk from thunk!\n        return dispatch(NamespaceThunkActions.asyncFetchNamespaces());\n      } else {\n        // Let the calling code know there's nothing to wait for.\n        return Promise.resolve();\n      }\n    };\n  }\n};\n\nexport default NamespaceThunkActions;\n"]},"metadata":{},"sourceType":"module"}