{"ast":null,"code":"import _toConsumableArray from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { makeLegend } from 'types/VictoryChartInfo';\nimport { filterAndRenameMetric } from 'utils/TimeSeriesUtils';\nexport var toVCDatapoints = function toVCDatapoints(dps, name) {\n  return dps.map(function (dp) {\n    return {\n      name: name,\n      x: new Date(dp[0] * 1000),\n      y: Number(dp[1])\n    };\n  }).filter(function (dp) {\n    return !isNaN(dp.y);\n  });\n};\nexport var toVCSinglePoint = function toVCSinglePoint(dps, name) {\n  var last = dps.filter(function (dp) {\n    return !isNaN(dp[1]);\n  }).reduce(function (p, c) {\n    return c[0] > p[0] ? c : p;\n  });\n\n  if (last) {\n    return [{\n      name: name,\n      time: new Date(last[0] * 1000),\n      x: 0,\n      // placeholder\n      y: Number(last[1])\n    }];\n  }\n\n  return [];\n};\n\nvar buildVCLine = function buildVCLine(dps, lineInfo) {\n  var datapoints = dps.map(function (dp) {\n    return _objectSpread(_objectSpread({}, lineInfo), dp);\n  });\n  var legendItem = makeLegend(lineInfo.name, lineInfo.color, lineInfo.symbol);\n  return {\n    datapoints: datapoints,\n    legendItem: legendItem,\n    color: lineInfo.color\n  };\n};\n\nexport var toVCLine = function toVCLine(dps, name, color) {\n  return buildVCLine(toVCDatapoints(dps, name), {\n    name: name,\n    color: color\n  });\n};\nvar colorsIdx = 0;\nexport var toVCLines = function toVCLines(metrics, unit, colors) {\n  var xAxis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'time';\n  return metrics.map(function (line) {\n    var color = colors[colorsIdx % colors.length];\n    colorsIdx++;\n    var dps = xAxis === 'time' ? toVCDatapoints(line.datapoints, line.name) : toVCSinglePoint(line.datapoints, line.name);\n    return buildVCLine(dps, {\n      name: line.name,\n      unit: unit,\n      color: color\n    });\n  });\n};\nexport var getDataSupplier = function getDataSupplier(chart, labels, colors) {\n  return function () {\n    colorsIdx = 0;\n    var filtered = filterAndRenameMetric(chart.metrics, labels);\n    return toVCLines(filtered, chart.unit, colors, chart.xAxis || 'time');\n  };\n}; // toBuckets accumulates datapoints into bukets.\n// The result is still a (smaller) list of VCDataPoints, but with Y value being an array of values instead of a single value.\n// This data structure is required by VictoryBoxPlot object.\n\nexport var toBuckets = function toBuckets(nbuckets, datapoints, lineInfo, timeWindow) {\n  if (datapoints.length === 0) {\n    return [];\n  } // xBuilder will preserve X-axis type when building buckets (either dates or raw numbers)\n\n\n  var xBuilder = typeof datapoints[0].x === 'object' ? function (x) {\n    return new Date(x);\n  } : function (x) {\n    return x;\n  };\n  var min = 0;\n  var max = 0;\n\n  if (timeWindow) {\n    min = timeWindow[0].getTime();\n    max = timeWindow[1].getTime();\n  } else {\n    var times = datapoints.map(function (dp) {\n      return Number(dp.x);\n    });\n    min = Math.min.apply(Math, _toConsumableArray(times));\n    max = Math.max.apply(Math, _toConsumableArray(times));\n  }\n\n  var bucketSize = (1 + max - min) / nbuckets; // Create $nbuckets buckets at regular intervals with preset / static content $dpInject\n\n  var buckets = Array.from({\n    length: nbuckets\n  }, function (_, idx) {\n    var start = Math.floor(min + idx * bucketSize);\n    var end = Math.floor(start + bucketSize - 1);\n    return _objectSpread(_objectSpread({}, lineInfo), {}, {\n      start: xBuilder(start),\n      end: xBuilder(end),\n      x: xBuilder(Math.floor(start + bucketSize / 2)),\n      y: []\n    });\n  });\n  datapoints.forEach(function (dp) {\n    // Get bucket index from timestamp\n    var idx = Math.floor((Number(dp.x) - min) / bucketSize); // This index might be out of range when a timeWindow is provided, so protect against that\n\n    if (idx >= 0 && idx < buckets.length) {\n      buckets[idx].y.push(dp.y);\n    }\n  });\n  return buckets.filter(function (b) {\n    return b.y.length > 0;\n  });\n};\nexport var toOverlay = function toOverlay(info, dps) {\n  return {\n    info: info,\n    vcLine: buildVCLine(dps, info.lineInfo)\n  };\n};","map":{"version":3,"sources":["/root/GraduateProject/src/utils/VictoryChartsUtils.ts"],"names":["makeLegend","filterAndRenameMetric","toVCDatapoints","dps","name","map","dp","x","Date","y","Number","filter","isNaN","toVCSinglePoint","last","reduce","p","c","time","buildVCLine","lineInfo","datapoints","legendItem","color","symbol","toVCLine","colorsIdx","toVCLines","metrics","unit","colors","xAxis","line","length","getDataSupplier","chart","labels","filtered","toBuckets","nbuckets","timeWindow","xBuilder","min","max","getTime","times","Math","bucketSize","buckets","Array","from","_","idx","start","floor","end","forEach","push","b","toOverlay","info","vcLine"],"mappings":"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","sourcesContent":["import { Datapoint, Metric } from 'types/Metrics';\nimport {\n  VCLines,\n  VCLine,\n  LegendItem,\n  VCDataPoint,\n  makeLegend,\n  RichDataPoint,\n  LineInfo,\n  BucketDataPoint\n} from 'types/VictoryChartInfo';\nimport { filterAndRenameMetric, LabelsInfo } from 'utils/TimeSeriesUtils';\nimport { ChartModel, XAxisType } from 'types/Dashboards';\nimport { Overlay, OverlayInfo } from 'types/Overlay';\n\nexport const toVCDatapoints = (dps: Datapoint[], name: string): VCDataPoint[] => {\n  return dps\n    .map(dp => {\n      return {\n        name: name,\n        x: new Date(dp[0] * 1000),\n        y: Number(dp[1])\n      };\n    })\n    .filter(dp => !isNaN(dp.y));\n};\n\nexport const toVCSinglePoint = (dps: Datapoint[], name: string): VCDataPoint[] => {\n  const last = dps.filter(dp => !isNaN(dp[1])).reduce((p, c) => (c[0] > p[0] ? c : p));\n  if (last) {\n    return [\n      {\n        name: name,\n        time: new Date(last[0] * 1000),\n        x: 0, // placeholder\n        y: Number(last[1])\n      } as VCDataPoint\n    ];\n  }\n  return [];\n};\n\nconst buildVCLine = <T extends LineInfo>(dps: VCDataPoint[], lineInfo: T): VCLine<VCDataPoint & T> => {\n  const datapoints: (VCDataPoint & T)[] = dps.map(dp => ({ ...lineInfo, ...dp }));\n  const legendItem: LegendItem = makeLegend(lineInfo.name, lineInfo.color, lineInfo.symbol);\n  return {\n    datapoints: datapoints,\n    legendItem: legendItem,\n    color: lineInfo.color\n  };\n};\n\nexport const toVCLine = (dps: Datapoint[], name: string, color: string): VCLine<RichDataPoint> => {\n  return buildVCLine(toVCDatapoints(dps, name), { name: name, color: color });\n};\n\nlet colorsIdx = 0;\nexport const toVCLines = (\n  metrics: Metric[],\n  unit: string,\n  colors: string[],\n  xAxis: XAxisType = 'time'\n): VCLines<RichDataPoint> => {\n  return metrics.map(line => {\n    const color = colors[colorsIdx % colors.length];\n    colorsIdx++;\n    const dps =\n      xAxis === 'time' ? toVCDatapoints(line.datapoints, line.name) : toVCSinglePoint(line.datapoints, line.name);\n    return buildVCLine(dps, { name: line.name, unit: unit, color: color });\n  });\n};\n\nexport const getDataSupplier = (\n  chart: ChartModel,\n  labels: LabelsInfo,\n  colors: string[]\n): (() => VCLines<RichDataPoint>) => {\n  return () => {\n    colorsIdx = 0;\n    const filtered = filterAndRenameMetric(chart.metrics, labels);\n    return toVCLines(filtered, chart.unit, colors, chart.xAxis || 'time');\n  };\n};\n\n// toBuckets accumulates datapoints into bukets.\n// The result is still a (smaller) list of VCDataPoints, but with Y value being an array of values instead of a single value.\n// This data structure is required by VictoryBoxPlot object.\nexport const toBuckets = <T extends LineInfo>(\n  nbuckets: number,\n  datapoints: VCDataPoint[],\n  lineInfo: T,\n  timeWindow?: [Date, Date]\n): (T & BucketDataPoint)[] => {\n  if (datapoints.length === 0) {\n    return [];\n  }\n  // xBuilder will preserve X-axis type when building buckets (either dates or raw numbers)\n  const xBuilder: (x: number) => number | Date = typeof datapoints[0].x === 'object' ? x => new Date(x) : x => x;\n\n  let min = 0;\n  let max = 0;\n  if (timeWindow) {\n    min = timeWindow[0].getTime();\n    max = timeWindow[1].getTime();\n  } else {\n    const times = datapoints.map(dp => Number(dp.x));\n    min = Math.min(...times);\n    max = Math.max(...times);\n  }\n  const bucketSize = (1 + max - min) / nbuckets;\n  // Create $nbuckets buckets at regular intervals with preset / static content $dpInject\n  const buckets: (T & BucketDataPoint)[] = Array.from({ length: nbuckets }, (_, idx) => {\n    const start = Math.floor(min + idx * bucketSize);\n    const end = Math.floor(start + bucketSize - 1);\n    return {\n      ...lineInfo,\n      start: xBuilder(start),\n      end: xBuilder(end),\n      x: xBuilder(Math.floor(start + bucketSize / 2)),\n      y: []\n    };\n  });\n  datapoints.forEach(dp => {\n    // Get bucket index from timestamp\n    const idx = Math.floor((Number(dp.x) - min) / bucketSize);\n    // This index might be out of range when a timeWindow is provided, so protect against that\n    if (idx >= 0 && idx < buckets.length) {\n      buckets[idx].y.push(dp.y);\n    }\n  });\n  return buckets.filter(b => b.y.length > 0);\n};\n\nexport const toOverlay = <T extends LineInfo>(info: OverlayInfo<T>, dps: VCDataPoint[]): Overlay<T> => {\n  return {\n    info: info,\n    vcLine: buildVCLine(dps, info.lineInfo)\n  };\n};\n"]},"metadata":{},"sourceType":"module"}