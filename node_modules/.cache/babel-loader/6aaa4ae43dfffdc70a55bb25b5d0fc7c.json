{"ast":null,"code":"import { CyNode } from './CytoscapeGraphUtils';\nimport { NodeType, GraphType } from 'types/Graph';\nimport { getAppFromSpan, getWorkloadFromSpan, searchParentApp, searchParentWorkload } from 'utils/tracing/TracingHelper';\nexport var showTrace = function showTrace(cy, graphType, trace) {\n  if (!cy) {\n    return;\n  }\n\n  cy.startBatch();\n  hideTrace(cy);\n  trace.spans.forEach(function (span) {\n    return showSpanSubtrace(cy, graphType, span);\n  });\n  cy.endBatch();\n};\n\nvar showSpanSubtrace = function showSpanSubtrace(cy, graphType, span) {\n  var split = span.process.serviceName.split('.');\n  var app = split[0]; // From upstream to downstream: Parent app or workload, Inbound Service Entry, Service, App or Workload, Outbound Service Entry\n\n  var lastSelection = undefined;\n\n  if (graphType === GraphType.SERVICE) {\n    // In service graph type, parent can be a Service or a Workload (e.g. when it initiates the transaction)\n    var sourceAppNs = searchParentApp(span);\n\n    if (sourceAppNs) {\n      var _selector = \"node[!\".concat(CyNode.isBox, \"][\").concat(CyNode.nodeType, \"=\\\"\").concat(NodeType.SERVICE, \"\\\"][\").concat(CyNode.app, \"=\\\"\").concat(sourceAppNs.app, \"\\\"][\").concat(CyNode.namespace, \"=\\\"\").concat(sourceAppNs.namespace, \"\\\"]\");\n\n      var parent = cy.elements(_selector);\n\n      if (!parent || parent.length === 0) {\n        // Try workload\n        var sourceWlNs = searchParentWorkload(span);\n\n        if (sourceWlNs) {\n          _selector = \"node[\".concat(CyNode.workload, \"=\\\"\").concat(sourceWlNs.workload, \"\\\"][\").concat(CyNode.namespace, \"=\\\"\").concat(sourceWlNs.namespace, \"\\\"]\");\n          parent = cy.elements(_selector);\n        }\n      }\n\n      if (!!parent && parent.length !== 0) {\n        lastSelection = parent;\n      }\n    }\n  } else if (graphType === GraphType.APP) {\n    // Parent app\n    var _sourceAppNs = searchParentApp(span);\n\n    if (_sourceAppNs) {\n      var _selector2 = \"node[\".concat(CyNode.nodeType, \"=\\\"\").concat(NodeType.APP, \"\\\"][\").concat(CyNode.app, \"=\\\"\").concat(_sourceAppNs.app, \"\\\"][\").concat(CyNode.namespace, \"=\\\"\").concat(_sourceAppNs.namespace, \"\\\"]\");\n\n      var _parent = cy.elements(_selector2);\n\n      if (!!_parent && _parent.length !== 0) {\n        lastSelection = _parent;\n      }\n    }\n  } else {\n    // Parent workload\n    var _sourceWlNs = searchParentWorkload(span);\n\n    if (_sourceWlNs) {\n      var _selector3 = \"node[\".concat(CyNode.workload, \"=\\\"\").concat(_sourceWlNs.workload, \"\\\"][\").concat(CyNode.namespace, \"=\\\"\").concat(_sourceWlNs.namespace, \"\\\"]\");\n\n      var _parent2 = cy.elements(_selector3);\n\n      if (!!_parent2 && _parent2.length !== 0) {\n        lastSelection = _parent2;\n      }\n    }\n  } // Inbound service entry\n\n\n  var seSelectionInbound = getInboundServiceEntry(span, cy);\n  lastSelection = nextHop(span, seSelectionInbound, lastSelection); // Main service\n\n  var nsSelector = split.length > 1 ? \"[\".concat(CyNode.namespace, \"=\\\"\").concat(split[1], \"\\\"]\") : '';\n  var selector = \"[\".concat(CyNode.nodeType, \"=\\\"\").concat(NodeType.SERVICE, \"\\\"][\").concat(CyNode.app, \"=\\\"\").concat(app, \"\\\"]\").concat(nsSelector);\n  lastSelection = nextHop(span, cy.elements(selector), lastSelection);\n\n  if (graphType === GraphType.APP) {\n    // Main app\n    var destAppNs = getAppFromSpan(span);\n\n    if (destAppNs) {\n      var _selector4 = \"node[\".concat(CyNode.nodeType, \"=\\\"\").concat(NodeType.APP, \"\\\"][\").concat(CyNode.app, \"=\\\"\").concat(destAppNs.app, \"\\\"][\").concat(CyNode.namespace, \"=\\\"\").concat(destAppNs.namespace, \"\\\"]\");\n\n      lastSelection = nextHop(span, cy.elements(_selector4), lastSelection);\n    }\n  } else {\n    // Main workload\n    var destWlNs = getWorkloadFromSpan(span);\n\n    if (destWlNs) {\n      var _selector5 = \"node[\".concat(CyNode.workload, \"=\\\"\").concat(destWlNs.workload, \"\\\"][\").concat(CyNode.namespace, \"=\\\"\").concat(destWlNs.namespace, \"\\\"]\");\n\n      lastSelection = nextHop(span, cy.elements(_selector5), lastSelection);\n    }\n  } // Outbound service entry\n\n\n  var seSelection = getOutboundServiceEntry(span, cy);\n  nextHop(span, seSelection, lastSelection);\n};\n\nvar singleEdge = function singleEdge(edges) {\n  if (edges.length > 1) {\n    console.debug(\"Expected singleton, found [\".concat(edges.length, \"] edges. Using first.\"));\n  }\n\n  return edges.length > 0 ? edges[0] : undefined;\n};\n\nvar singleNode = function singleNode(nodes) {\n  if (nodes.length > 1) {\n    console.debug(\"Expected singleton, found [\".concat(nodes.length, \"] nodes. Using first.\"));\n  }\n\n  return nodes.length > 0 ? nodes[0] : undefined;\n};\n\nvar addSpan = function addSpan(ele, span) {\n  if (!ele) {\n    return;\n  }\n\n  if (ele.hasClass('span')) {\n    ele.data('spans').push(span);\n  } else {\n    ele.addClass('span');\n    ele.data('spans', [span]);\n  }\n};\n\nexport var hideTrace = function hideTrace(cy) {\n  if (!cy) {\n    return;\n  } // unhighlight old span-hits\n\n\n  var spanHits = cy.elements('*.span');\n  spanHits.removeClass('span');\n  spanHits.data('spans', undefined);\n};\n\nvar getOutboundServiceEntry = function getOutboundServiceEntry(span, cy) {\n  // see https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  if (span.tags.some(function (tag) {\n    return tag.key === 'span.kind' && (tag.value === 'client' || tag.value === 'producer');\n  })) {\n    return findServiceEntry(span, cy);\n  }\n\n  return undefined;\n};\n\nvar getInboundServiceEntry = function getInboundServiceEntry(span, cy) {\n  // see https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  if (span.tags.some(function (tag) {\n    return tag.key === 'span.kind' && (tag.value === 'server' || tag.value === 'consumer');\n  })) {\n    return findServiceEntry(span, cy);\n  }\n\n  return undefined;\n};\n\nvar findServiceEntry = function findServiceEntry(span, cy) {\n  var hostname = span.tags.find(function (tag) {\n    return tag.key === 'peer.hostname';\n  });\n\n  if (hostname && hostname.value !== '') {\n    return findSEHost(hostname.value, cy);\n  }\n\n  var addr = span.tags.find(function (tag) {\n    return tag.key === 'peer.address';\n  });\n\n  if (addr && addr.value !== '') {\n    return findSEHost(addr.value.split(':')[0], cy);\n  }\n\n  return undefined;\n};\n\nvar findSEHost = function findSEHost(hostname, cy) {\n  return cy.elements(\"[\".concat(CyNode.nodeType, \"=\\\"\").concat(NodeType.SERVICE, \"\\\"]\")).filter(function (ele) {\n    var seInfo = ele.data(CyNode.isServiceEntry);\n\n    if (seInfo) {\n      // TODO: improve host matching, as \"startsWith\" allows false-positives\n      if (seInfo.hosts.some(function (h) {\n        return h.startsWith(hostname);\n      })) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\n\nvar nextHop = function nextHop(span, next, last) {\n  if (!!next && next.length !== 0) {\n    var node = singleNode(next);\n    addSpan(node, span);\n\n    if (last) {\n      // Try both inbound and outbound, because of TCP edges where direction might not be correctly represented in graph\n      var edge = last.edgesTo(next);\n\n      if (!edge || edge.length === 0) {\n        edge = next.edgesTo(last);\n      }\n\n      addSpan(singleEdge(edge), span);\n    }\n\n    return next;\n  }\n\n  return last;\n};","map":{"version":3,"sources":["/root/GraduateProject/src/components/CytoscapeGraph/CytoscapeTrace.ts"],"names":["CyNode","NodeType","GraphType","getAppFromSpan","getWorkloadFromSpan","searchParentApp","searchParentWorkload","showTrace","cy","graphType","trace","startBatch","hideTrace","spans","forEach","span","showSpanSubtrace","endBatch","split","process","serviceName","app","lastSelection","undefined","SERVICE","sourceAppNs","selector","isBox","nodeType","namespace","parent","elements","length","sourceWlNs","workload","APP","seSelectionInbound","getInboundServiceEntry","nextHop","nsSelector","destAppNs","destWlNs","seSelection","getOutboundServiceEntry","singleEdge","edges","console","debug","singleNode","nodes","addSpan","ele","hasClass","data","push","addClass","spanHits","removeClass","tags","some","tag","key","value","findServiceEntry","hostname","find","findSEHost","addr","filter","seInfo","isServiceEntry","hosts","h","startsWith","next","last","node","edge","edgesTo"],"mappings":"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","sourcesContent":["import * as Cy from 'cytoscape';\nimport { CyNode } from './CytoscapeGraphUtils';\nimport { JaegerTrace, Span } from 'types/JaegerInfo';\nimport { NodeType, GraphType, SEInfo } from 'types/Graph';\nimport {\n  getAppFromSpan,\n  getWorkloadFromSpan,\n  searchParentApp,\n  searchParentWorkload\n} from 'utils/tracing/TracingHelper';\n\nexport const showTrace = (cy: Cy.Core, graphType: GraphType, trace: JaegerTrace) => {\n  if (!cy) {\n    return;\n  }\n\n  cy.startBatch();\n  hideTrace(cy);\n  trace.spans.forEach(span => showSpanSubtrace(cy, graphType, span));\n  cy.endBatch();\n};\n\nconst showSpanSubtrace = (cy: Cy.Core, graphType: GraphType, span: Span) => {\n  const split = span.process.serviceName.split('.');\n  const app = split[0];\n\n  // From upstream to downstream: Parent app or workload, Inbound Service Entry, Service, App or Workload, Outbound Service Entry\n  let lastSelection: Cy.NodeCollection | undefined = undefined;\n\n  if (graphType === GraphType.SERVICE) {\n    // In service graph type, parent can be a Service or a Workload (e.g. when it initiates the transaction)\n    const sourceAppNs = searchParentApp(span);\n    if (sourceAppNs) {\n      let selector = `node[!${CyNode.isBox}][${CyNode.nodeType}=\"${NodeType.SERVICE}\"][${CyNode.app}=\"${sourceAppNs.app}\"][${CyNode.namespace}=\"${sourceAppNs.namespace}\"]`;\n      let parent = cy.elements(selector);\n      if (!parent || parent.length === 0) {\n        // Try workload\n        const sourceWlNs = searchParentWorkload(span);\n        if (sourceWlNs) {\n          selector = `node[${CyNode.workload}=\"${sourceWlNs.workload}\"][${CyNode.namespace}=\"${sourceWlNs.namespace}\"]`;\n          parent = cy.elements(selector);\n        }\n      }\n      if (!!parent && parent.length !== 0) {\n        lastSelection = parent;\n      }\n    }\n  } else if (graphType === GraphType.APP) {\n    // Parent app\n    const sourceAppNs = searchParentApp(span);\n    if (sourceAppNs) {\n      const selector = `node[${CyNode.nodeType}=\"${NodeType.APP}\"][${CyNode.app}=\"${sourceAppNs.app}\"][${CyNode.namespace}=\"${sourceAppNs.namespace}\"]`;\n      const parent = cy.elements(selector);\n      if (!!parent && parent.length !== 0) {\n        lastSelection = parent;\n      }\n    }\n  } else {\n    // Parent workload\n    const sourceWlNs = searchParentWorkload(span);\n    if (sourceWlNs) {\n      const selector = `node[${CyNode.workload}=\"${sourceWlNs.workload}\"][${CyNode.namespace}=\"${sourceWlNs.namespace}\"]`;\n      const parent = cy.elements(selector);\n      if (!!parent && parent.length !== 0) {\n        lastSelection = parent;\n      }\n    }\n  }\n\n  // Inbound service entry\n  const seSelectionInbound = getInboundServiceEntry(span, cy);\n  lastSelection = nextHop(span, seSelectionInbound, lastSelection);\n\n  // Main service\n  const nsSelector = split.length > 1 ? `[${CyNode.namespace}=\"${split[1]}\"]` : '';\n  const selector = `[${CyNode.nodeType}=\"${NodeType.SERVICE}\"][${CyNode.app}=\"${app}\"]${nsSelector}`;\n  lastSelection = nextHop(span, cy.elements(selector), lastSelection);\n\n  if (graphType === GraphType.APP) {\n    // Main app\n    const destAppNs = getAppFromSpan(span);\n    if (destAppNs) {\n      const selector = `node[${CyNode.nodeType}=\"${NodeType.APP}\"][${CyNode.app}=\"${destAppNs.app}\"][${CyNode.namespace}=\"${destAppNs.namespace}\"]`;\n      lastSelection = nextHop(span, cy.elements(selector), lastSelection);\n    }\n  } else {\n    // Main workload\n    const destWlNs = getWorkloadFromSpan(span);\n    if (destWlNs) {\n      const selector = `node[${CyNode.workload}=\"${destWlNs.workload}\"][${CyNode.namespace}=\"${destWlNs.namespace}\"]`;\n      lastSelection = nextHop(span, cy.elements(selector), lastSelection);\n    }\n  }\n\n  // Outbound service entry\n  const seSelection = getOutboundServiceEntry(span, cy);\n  nextHop(span, seSelection, lastSelection);\n};\n\nconst singleEdge = (edges: Cy.EdgeCollection): Cy.EdgeSingular | undefined => {\n  if (edges.length > 1) {\n    console.debug(`Expected singleton, found [${edges.length}] edges. Using first.`);\n  }\n  return edges.length > 0 ? edges[0] : undefined;\n};\n\nconst singleNode = (nodes: Cy.NodeCollection): Cy.NodeSingular | undefined => {\n  if (nodes.length > 1) {\n    console.debug(`Expected singleton, found [${nodes.length}] nodes. Using first.`);\n  }\n  return nodes.length > 0 ? nodes[0] : undefined;\n};\n\nconst addSpan = (ele: Cy.NodeSingular | Cy.EdgeSingular | undefined, span: Span): void => {\n  if (!ele) {\n    return;\n  }\n\n  if (ele.hasClass('span')) {\n    ele.data('spans').push(span);\n  } else {\n    ele.addClass('span');\n    ele.data('spans', [span]);\n  }\n};\n\nexport const hideTrace = (cy: Cy.Core) => {\n  if (!cy) {\n    return;\n  }\n  // unhighlight old span-hits\n  const spanHits = cy.elements('*.span');\n  spanHits.removeClass('span');\n  spanHits.data('spans', undefined);\n};\n\nconst getOutboundServiceEntry = (span: Span, cy: Cy.Core): Cy.NodeCollection | undefined => {\n  // see https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  if (span.tags.some(tag => tag.key === 'span.kind' && (tag.value === 'client' || tag.value === 'producer'))) {\n    return findServiceEntry(span, cy);\n  }\n  return undefined;\n};\n\nconst getInboundServiceEntry = (span: Span, cy: Cy.Core): Cy.NodeCollection | undefined => {\n  // see https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  if (span.tags.some(tag => tag.key === 'span.kind' && (tag.value === 'server' || tag.value === 'consumer'))) {\n    return findServiceEntry(span, cy);\n  }\n  return undefined;\n};\n\nconst findServiceEntry = (span: Span, cy: Cy.Core): Cy.NodeCollection | undefined => {\n  const hostname = span.tags.find(tag => tag.key === 'peer.hostname');\n  if (hostname && hostname.value !== '') {\n    return findSEHost(hostname.value, cy);\n  }\n  const addr = span.tags.find(tag => tag.key === 'peer.address');\n  if (addr && addr.value !== '') {\n    return findSEHost(addr.value.split(':')[0], cy);\n  }\n  return undefined;\n};\n\nconst findSEHost = (hostname: string, cy: Cy.Core): Cy.NodeCollection | undefined => {\n  return cy.elements(`[${CyNode.nodeType}=\"${NodeType.SERVICE}\"]`).filter(ele => {\n    const seInfo: SEInfo | undefined = ele.data(CyNode.isServiceEntry);\n    if (seInfo) {\n      // TODO: improve host matching, as \"startsWith\" allows false-positives\n      if (seInfo.hosts.some(h => h.startsWith(hostname))) {\n        return true;\n      }\n    }\n    return false;\n  });\n};\n\nconst nextHop = (\n  span: Span,\n  next: Cy.NodeCollection | undefined,\n  last: Cy.NodeCollection | undefined\n): Cy.NodeCollection | undefined => {\n  if (!!next && next.length !== 0) {\n    const node = singleNode(next);\n    addSpan(node, span);\n    if (last) {\n      // Try both inbound and outbound, because of TCP edges where direction might not be correctly represented in graph\n      let edge = last.edgesTo(next);\n      if (!edge || edge.length === 0) {\n        edge = next.edgesTo(last);\n      }\n      addSpan(singleEdge(edge), span);\n    }\n    return next;\n  }\n  return last;\n};\n"]},"metadata":{},"sourceType":"module"}