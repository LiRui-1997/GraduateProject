{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"layout-base\"));else if (typeof define === 'function' && define.amd) define([\"layout-base\"], factory);else if (typeof exports === 'object') exports[\"coseBase\"] = factory(require(\"layout-base\"));else root[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 7);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\n      function CoSEConstants() {} //CoSEConstants inherits static props in FDLayoutConstants\n\n\n      for (var prop in FDLayoutConstants) {\n        CoSEConstants[prop] = FDLayoutConstants[prop];\n      }\n\n      CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n      CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n      CoSEConstants.TILE = true;\n      CoSEConstants.TILING_PADDING_VERTICAL = 10;\n      CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n      CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\n      module.exports = CoSEConstants;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\n      function CoSEEdge(source, target, vEdge) {\n        FDLayoutEdge.call(this, source, target, vEdge);\n      }\n\n      CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n\n      for (var prop in FDLayoutEdge) {\n        CoSEEdge[prop] = FDLayoutEdge[prop];\n      }\n\n      module.exports = CoSEEdge;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraph = __webpack_require__(0).LGraph;\n\n      function CoSEGraph(parent, graphMgr, vGraph) {\n        LGraph.call(this, parent, graphMgr, vGraph);\n      }\n\n      CoSEGraph.prototype = Object.create(LGraph.prototype);\n\n      for (var prop in LGraph) {\n        CoSEGraph[prop] = LGraph[prop];\n      }\n\n      module.exports = CoSEGraph;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var LGraphManager = __webpack_require__(0).LGraphManager;\n\n      function CoSEGraphManager(layout) {\n        LGraphManager.call(this, layout);\n      }\n\n      CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n\n      for (var prop in LGraphManager) {\n        CoSEGraphManager[prop] = LGraphManager[prop];\n      }\n\n      module.exports = CoSEGraphManager;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayoutNode = __webpack_require__(0).FDLayoutNode;\n\n      var IMath = __webpack_require__(0).IMath;\n\n      function CoSENode(gm, loc, size, vNode) {\n        FDLayoutNode.call(this, gm, loc, size, vNode);\n      }\n\n      CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n\n      for (var prop in FDLayoutNode) {\n        CoSENode[prop] = FDLayoutNode[prop];\n      }\n\n      CoSENode.prototype.move = function () {\n        var layout = this.graphManager.getLayout();\n        this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n        this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n        if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n          this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n        }\n\n        if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n          this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n        } // a simple node, just move it\n\n\n        if (this.child == null) {\n          this.moveBy(this.displacementX, this.displacementY);\n        } // an empty compound node, again just move it\n        else if (this.child.getNodes().length == 0) {\n            this.moveBy(this.displacementX, this.displacementY);\n          } // non-empty compound node, propogate movement to children as well\n          else {\n              this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n            }\n\n        layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n        this.springForceX = 0;\n        this.springForceY = 0;\n        this.repulsionForceX = 0;\n        this.repulsionForceY = 0;\n        this.gravitationForceX = 0;\n        this.gravitationForceY = 0;\n        this.displacementX = 0;\n        this.displacementY = 0;\n      };\n\n      CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n        var nodes = this.getChild().getNodes();\n        var node;\n\n        for (var i = 0; i < nodes.length; i++) {\n          node = nodes[i];\n\n          if (node.getChild() == null) {\n            node.moveBy(dX, dY);\n            node.displacementX += dX;\n            node.displacementY += dY;\n          } else {\n            node.propogateDisplacementToChildren(dX, dY);\n          }\n        }\n      };\n\n      CoSENode.prototype.setPred1 = function (pred1) {\n        this.pred1 = pred1;\n      };\n\n      CoSENode.prototype.getPred1 = function () {\n        return pred1;\n      };\n\n      CoSENode.prototype.getPred2 = function () {\n        return pred2;\n      };\n\n      CoSENode.prototype.setNext = function (next) {\n        this.next = next;\n      };\n\n      CoSENode.prototype.getNext = function () {\n        return next;\n      };\n\n      CoSENode.prototype.setProcessed = function (processed) {\n        this.processed = processed;\n      };\n\n      CoSENode.prototype.isProcessed = function () {\n        return processed;\n      };\n\n      module.exports = CoSENode;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var FDLayout = __webpack_require__(0).FDLayout;\n\n      var CoSEGraphManager = __webpack_require__(4);\n\n      var CoSEGraph = __webpack_require__(3);\n\n      var CoSENode = __webpack_require__(5);\n\n      var CoSEEdge = __webpack_require__(2);\n\n      var CoSEConstants = __webpack_require__(1);\n\n      var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\n      var LayoutConstants = __webpack_require__(0).LayoutConstants;\n\n      var Point = __webpack_require__(0).Point;\n\n      var PointD = __webpack_require__(0).PointD;\n\n      var Layout = __webpack_require__(0).Layout;\n\n      var Integer = __webpack_require__(0).Integer;\n\n      var IGeometry = __webpack_require__(0).IGeometry;\n\n      var LGraph = __webpack_require__(0).LGraph;\n\n      var Transform = __webpack_require__(0).Transform;\n\n      function CoSELayout() {\n        FDLayout.call(this);\n        this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n      }\n\n      CoSELayout.prototype = Object.create(FDLayout.prototype);\n\n      for (var prop in FDLayout) {\n        CoSELayout[prop] = FDLayout[prop];\n      }\n\n      CoSELayout.prototype.newGraphManager = function () {\n        var gm = new CoSEGraphManager(this);\n        this.graphManager = gm;\n        return gm;\n      };\n\n      CoSELayout.prototype.newGraph = function (vGraph) {\n        return new CoSEGraph(null, this.graphManager, vGraph);\n      };\n\n      CoSELayout.prototype.newNode = function (vNode) {\n        return new CoSENode(this.graphManager, vNode);\n      };\n\n      CoSELayout.prototype.newEdge = function (vEdge) {\n        return new CoSEEdge(null, null, vEdge);\n      };\n\n      CoSELayout.prototype.initParameters = function () {\n        FDLayout.prototype.initParameters.call(this, arguments);\n\n        if (!this.isSubLayout) {\n          if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n            this.idealEdgeLength = 10;\n          } else {\n            this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n          }\n\n          this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n          this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n          this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n          this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n          this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n          this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n          this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR; // variables for tree reduction support\n\n          this.prunedNodesAll = [];\n          this.growTreeIterations = 0;\n          this.afterGrowthIterations = 0;\n          this.isTreeGrowing = false;\n          this.isGrowthFinished = false; // variables for cooling\n\n          this.coolingCycle = 0;\n          this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n          this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n          this.coolingAdjuster = 1;\n        }\n      };\n\n      CoSELayout.prototype.layout = function () {\n        var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n\n        if (createBendsAsNeeded) {\n          this.createBendpoints();\n          this.graphManager.resetAllEdges();\n        }\n\n        this.level = 0;\n        return this.classicLayout();\n      };\n\n      CoSELayout.prototype.classicLayout = function () {\n        this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n        this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n        this.calcNoOfChildrenForAllNodes();\n        this.graphManager.calcLowestCommonAncestors();\n        this.graphManager.calcInclusionTreeDepths();\n        this.graphManager.getRoot().calcEstimatedSize();\n        this.calcIdealEdgeLengths();\n\n        if (!this.incremental) {\n          var forest = this.getFlatForest(); // The graph associated with this layout is flat and a forest\n\n          if (forest.length > 0) {\n            this.positionNodesRadially(forest);\n          } // The graph associated with this layout is not flat or a forest\n          else {\n              // Reduce the trees when incremental mode is not enabled and graph is not a forest \n              this.reduceTrees(); // Update nodes that gravity will be applied\n\n              this.graphManager.resetAllNodesToApplyGravitation();\n              var allNodes = new Set(this.getAllNodes());\n              var intersection = this.nodesWithGravity.filter(function (x) {\n                return allNodes.has(x);\n              });\n              this.graphManager.setAllNodesToApplyGravitation(intersection);\n              this.positionNodesRandomly();\n            }\n        } else {\n          if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n            // Reduce the trees in incremental mode if only this constant is set to true \n            this.reduceTrees(); // Update nodes that gravity will be applied\n\n            this.graphManager.resetAllNodesToApplyGravitation();\n            var allNodes = new Set(this.getAllNodes());\n            var intersection = this.nodesWithGravity.filter(function (x) {\n              return allNodes.has(x);\n            });\n            this.graphManager.setAllNodesToApplyGravitation(intersection);\n          }\n        }\n\n        this.initSpringEmbedder();\n        this.runSpringEmbedder();\n        return true;\n      };\n\n      CoSELayout.prototype.tick = function () {\n        this.totalIterations++;\n\n        if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n          if (this.prunedNodesAll.length > 0) {\n            this.isTreeGrowing = true;\n          } else {\n            return true;\n          }\n        }\n\n        if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n          if (this.isConverged()) {\n            if (this.prunedNodesAll.length > 0) {\n              this.isTreeGrowing = true;\n            } else {\n              return true;\n            }\n          }\n\n          this.coolingCycle++;\n\n          if (this.layoutQuality == 0) {\n            // quality - \"draft\"\n            this.coolingAdjuster = this.coolingCycle;\n          } else if (this.layoutQuality == 1) {\n            // quality - \"default\"\n            this.coolingAdjuster = this.coolingCycle / 3;\n          } // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n\n\n          this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n          this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n        } // Operations while tree is growing again \n\n\n        if (this.isTreeGrowing) {\n          if (this.growTreeIterations % 10 == 0) {\n            if (this.prunedNodesAll.length > 0) {\n              this.graphManager.updateBounds();\n              this.updateGrid();\n              this.growTree(this.prunedNodesAll); // Update nodes that gravity will be applied\n\n              this.graphManager.resetAllNodesToApplyGravitation();\n              var allNodes = new Set(this.getAllNodes());\n              var intersection = this.nodesWithGravity.filter(function (x) {\n                return allNodes.has(x);\n              });\n              this.graphManager.setAllNodesToApplyGravitation(intersection);\n              this.graphManager.updateBounds();\n              this.updateGrid();\n              this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n            } else {\n              this.isTreeGrowing = false;\n              this.isGrowthFinished = true;\n            }\n          }\n\n          this.growTreeIterations++;\n        } // Operations after growth is finished\n\n\n        if (this.isGrowthFinished) {\n          if (this.isConverged()) {\n            return true;\n          }\n\n          if (this.afterGrowthIterations % 10 == 0) {\n            this.graphManager.updateBounds();\n            this.updateGrid();\n          }\n\n          this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n          this.afterGrowthIterations++;\n        }\n\n        var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n        var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n        this.totalDisplacement = 0;\n        this.graphManager.updateBounds();\n        this.calcSpringForces();\n        this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n        this.calcGravitationalForces();\n        this.moveNodes();\n        this.animate();\n        return false; // Layout is not ended yet return false\n      };\n\n      CoSELayout.prototype.getPositionsData = function () {\n        var allNodes = this.graphManager.getAllNodes();\n        var pData = {};\n\n        for (var i = 0; i < allNodes.length; i++) {\n          var rect = allNodes[i].rect;\n          var id = allNodes[i].id;\n          pData[id] = {\n            id: id,\n            x: rect.getCenterX(),\n            y: rect.getCenterY(),\n            w: rect.width,\n            h: rect.height\n          };\n        }\n\n        return pData;\n      };\n\n      CoSELayout.prototype.runSpringEmbedder = function () {\n        this.initialAnimationPeriod = 25;\n        this.animationPeriod = this.initialAnimationPeriod;\n        var layoutEnded = false; // If aminate option is 'during' signal that layout is supposed to start iterating\n\n        if (FDLayoutConstants.ANIMATE === 'during') {\n          this.emit('layoutstarted');\n        } else {\n          // If aminate option is 'during' tick() function will be called on index.js\n          while (!layoutEnded) {\n            layoutEnded = this.tick();\n          }\n\n          this.graphManager.updateBounds();\n        }\n      };\n\n      CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n        var nodeList = [];\n        var graph;\n        var graphs = this.graphManager.getGraphs();\n        var size = graphs.length;\n        var i;\n\n        for (i = 0; i < size; i++) {\n          graph = graphs[i];\n          graph.updateConnected();\n\n          if (!graph.isConnected) {\n            nodeList = nodeList.concat(graph.getNodes());\n          }\n        }\n\n        return nodeList;\n      };\n\n      CoSELayout.prototype.createBendpoints = function () {\n        var edges = [];\n        edges = edges.concat(this.graphManager.getAllEdges());\n        var visited = new Set();\n        var i;\n\n        for (i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n\n          if (!visited.has(edge)) {\n            var source = edge.getSource();\n            var target = edge.getTarget();\n\n            if (source == target) {\n              edge.getBendpoints().push(new PointD());\n              edge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(edge);\n              visited.add(edge);\n            } else {\n              var edgeList = [];\n              edgeList = edgeList.concat(source.getEdgeListToNode(target));\n              edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n              if (!visited.has(edgeList[0])) {\n                if (edgeList.length > 1) {\n                  var k;\n\n                  for (k = 0; k < edgeList.length; k++) {\n                    var multiEdge = edgeList[k];\n                    multiEdge.getBendpoints().push(new PointD());\n                    this.createDummyNodesForBendpoints(multiEdge);\n                  }\n                }\n\n                edgeList.forEach(function (edge) {\n                  visited.add(edge);\n                });\n              }\n            }\n          }\n\n          if (visited.size == edges.length) {\n            break;\n          }\n        }\n      };\n\n      CoSELayout.prototype.positionNodesRadially = function (forest) {\n        // We tile the trees to a grid row by row; first tree starts at (0,0)\n        var currentStartingPoint = new Point(0, 0);\n        var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n        var height = 0;\n        var currentY = 0;\n        var currentX = 0;\n        var point = new PointD(0, 0);\n\n        for (var i = 0; i < forest.length; i++) {\n          if (i % numberOfColumns == 0) {\n            // Start of a new row, make the x coordinate 0, increment the\n            // y coordinate with the max height of the previous row\n            currentX = 0;\n            currentY = height;\n\n            if (i != 0) {\n              currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n            }\n\n            height = 0;\n          }\n\n          var tree = forest[i]; // Find the center of the tree\n\n          var centerNode = Layout.findCenterOfTree(tree); // Set the staring point of the next tree\n\n          currentStartingPoint.x = currentX;\n          currentStartingPoint.y = currentY; // Do a radial layout starting with the center\n\n          point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n          if (point.y > height) {\n            height = Math.floor(point.y);\n          }\n\n          currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n        }\n\n        this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n      };\n\n      CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n        var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n        CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n        var bounds = LGraph.calculateBounds(tree);\n        var transform = new Transform();\n        transform.setDeviceOrgX(bounds.getMinX());\n        transform.setDeviceOrgY(bounds.getMinY());\n        transform.setWorldOrgX(startingPoint.x);\n        transform.setWorldOrgY(startingPoint.y);\n\n        for (var i = 0; i < tree.length; i++) {\n          var node = tree[i];\n          node.transform(transform);\n        }\n\n        var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n        return transform.inverseTransformPoint(bottomRight);\n      };\n\n      CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n        // First, position this node by finding its angle.\n        var halfInterval = (endAngle - startAngle + 1) / 2;\n\n        if (halfInterval < 0) {\n          halfInterval += 180;\n        }\n\n        var nodeAngle = (halfInterval + startAngle) % 360;\n        var teta = nodeAngle * IGeometry.TWO_PI / 360; // Make polar to java cordinate conversion.\n\n        var cos_teta = Math.cos(teta);\n        var x_ = distance * Math.cos(teta);\n        var y_ = distance * Math.sin(teta);\n        node.setCenter(x_, y_); // Traverse all neighbors of this node and recursively call this\n        // function.\n\n        var neighborEdges = [];\n        neighborEdges = neighborEdges.concat(node.getEdges());\n        var childCount = neighborEdges.length;\n\n        if (parentOfNode != null) {\n          childCount--;\n        }\n\n        var branchCount = 0;\n        var incEdgesCount = neighborEdges.length;\n        var startIndex;\n        var edges = node.getEdgesBetween(parentOfNode); // If there are multiple edges, prune them until there remains only one\n        // edge.\n\n        while (edges.length > 1) {\n          //neighborEdges.remove(edges.remove(0));\n          var temp = edges[0];\n          edges.splice(0, 1);\n          var index = neighborEdges.indexOf(temp);\n\n          if (index >= 0) {\n            neighborEdges.splice(index, 1);\n          }\n\n          incEdgesCount--;\n          childCount--;\n        }\n\n        if (parentOfNode != null) {\n          //assert edges.length == 1;\n          startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n        } else {\n          startIndex = 0;\n        }\n\n        var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n        for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n          var currentNeighbor = neighborEdges[i].getOtherEnd(node); // Don't back traverse to root node in current tree.\n\n          if (currentNeighbor == parentOfNode) {\n            continue;\n          }\n\n          var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n          var childEndAngle = (childStartAngle + stepAngle) % 360;\n          CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n          branchCount++;\n        }\n      };\n\n      CoSELayout.maxDiagonalInTree = function (tree) {\n        var maxDiagonal = Integer.MIN_VALUE;\n\n        for (var i = 0; i < tree.length; i++) {\n          var node = tree[i];\n          var diagonal = node.getDiagonal();\n\n          if (diagonal > maxDiagonal) {\n            maxDiagonal = diagonal;\n          }\n        }\n\n        return maxDiagonal;\n      };\n\n      CoSELayout.prototype.calcRepulsionRange = function () {\n        // formula is 2 x (level + 1) x idealEdgeLength\n        return 2 * (this.level + 1) * this.idealEdgeLength;\n      }; // Tiling methods\n      // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n\n\n      CoSELayout.prototype.groupZeroDegreeMembers = function () {\n        var self = this; // array of [parent_id x oneDegreeNode_id]\n\n        var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n\n        this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n\n        this.idToDummyNode = {}; // A map of id to dummy node \n\n        var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n\n        var allNodes = this.graphManager.getAllNodes(); // Fill zero degree list\n\n        for (var i = 0; i < allNodes.length; i++) {\n          var node = allNodes[i];\n          var parent = node.getParent(); // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n\n          if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n            zeroDegree.push(node);\n          }\n        } // Create a map of parent node and its zero degree members\n\n\n        for (var i = 0; i < zeroDegree.length; i++) {\n          var node = zeroDegree[i]; // Zero degree node itself\n\n          var p_id = node.getParent().id; // Parent id\n\n          if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n          tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n        } // If there are at least two nodes at a level, create a dummy compound for them\n\n\n        Object.keys(tempMemberGroups).forEach(function (p_id) {\n          if (tempMemberGroups[p_id].length > 1) {\n            var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n\n            self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n            var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n            // Create a dummy compound with calculated id\n\n            var dummyCompound = new CoSENode(self.graphManager);\n            dummyCompound.id = dummyCompoundId;\n            dummyCompound.paddingLeft = parent.paddingLeft || 0;\n            dummyCompound.paddingRight = parent.paddingRight || 0;\n            dummyCompound.paddingBottom = parent.paddingBottom || 0;\n            dummyCompound.paddingTop = parent.paddingTop || 0;\n            self.idToDummyNode[dummyCompoundId] = dummyCompound;\n            var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n            var parentGraph = parent.getChild(); // Add dummy compound to parent the graph\n\n            parentGraph.add(dummyCompound); // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n\n            for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n              var node = tempMemberGroups[p_id][i];\n              parentGraph.remove(node);\n              dummyParentGraph.add(node);\n            }\n          }\n        });\n      };\n\n      CoSELayout.prototype.clearCompounds = function () {\n        var childGraphMap = {};\n        var idToNode = {}; // Get compound ordering by finding the inner one first\n\n        this.performDFSOnCompounds();\n\n        for (var i = 0; i < this.compoundOrder.length; i++) {\n          idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n          childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes()); // Remove children of compounds\n\n          this.graphManager.remove(this.compoundOrder[i].getChild());\n          this.compoundOrder[i].child = null;\n        }\n\n        this.graphManager.resetAllNodes(); // Tile the removed children\n\n        this.tileCompoundMembers(childGraphMap, idToNode);\n      };\n\n      CoSELayout.prototype.clearZeroDegreeMembers = function () {\n        var self = this;\n        var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n        Object.keys(this.memberGroups).forEach(function (id) {\n          var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n          tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight); // Set the width and height of the dummy compound as calculated\n\n          compoundNode.rect.width = tiledZeroDegreePack[id].width;\n          compoundNode.rect.height = tiledZeroDegreePack[id].height;\n        });\n      };\n\n      CoSELayout.prototype.repopulateCompounds = function () {\n        for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n          var lCompoundNode = this.compoundOrder[i];\n          var id = lCompoundNode.id;\n          var horizontalMargin = lCompoundNode.paddingLeft;\n          var verticalMargin = lCompoundNode.paddingTop;\n          this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n        }\n      };\n\n      CoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n        var self = this;\n        var tiledPack = this.tiledZeroDegreePack;\n        Object.keys(tiledPack).forEach(function (id) {\n          var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n\n          var horizontalMargin = compoundNode.paddingLeft;\n          var verticalMargin = compoundNode.paddingTop; // Adjust the positions of nodes wrt its compound\n\n          self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n        });\n      };\n\n      CoSELayout.prototype.getToBeTiled = function (node) {\n        var id = node.id; //firstly check the previous results\n\n        if (this.toBeTiled[id] != null) {\n          return this.toBeTiled[id];\n        } //only compound nodes are to be tiled\n\n\n        var childGraph = node.getChild();\n\n        if (childGraph == null) {\n          this.toBeTiled[id] = false;\n          return false;\n        }\n\n        var children = childGraph.getNodes(); // Get the children nodes\n        //a compound node is not to be tiled if all of its compound children are not to be tiled\n\n        for (var i = 0; i < children.length; i++) {\n          var theChild = children[i];\n\n          if (this.getNodeDegree(theChild) > 0) {\n            this.toBeTiled[id] = false;\n            return false;\n          } //pass the children not having the compound structure\n\n\n          if (theChild.getChild() == null) {\n            this.toBeTiled[theChild.id] = false;\n            continue;\n          }\n\n          if (!this.getToBeTiled(theChild)) {\n            this.toBeTiled[id] = false;\n            return false;\n          }\n        }\n\n        this.toBeTiled[id] = true;\n        return true;\n      }; // Get degree of a node depending of its edges and independent of its children\n\n\n      CoSELayout.prototype.getNodeDegree = function (node) {\n        var id = node.id;\n        var edges = node.getEdges();\n        var degree = 0; // For the edges connected\n\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n\n          if (edge.getSource().id !== edge.getTarget().id) {\n            degree = degree + 1;\n          }\n        }\n\n        return degree;\n      }; // Get degree of a node with its children\n\n\n      CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n        var degree = this.getNodeDegree(node);\n\n        if (node.getChild() == null) {\n          return degree;\n        }\n\n        var children = node.getChild().getNodes();\n\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          degree += this.getNodeDegreeWithChildren(child);\n        }\n\n        return degree;\n      };\n\n      CoSELayout.prototype.performDFSOnCompounds = function () {\n        this.compoundOrder = [];\n        this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n      };\n\n      CoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n\n          if (child.getChild() != null) {\n            this.fillCompexOrderByDFS(child.getChild().getNodes());\n          }\n\n          if (this.getToBeTiled(child)) {\n            this.compoundOrder.push(child);\n          }\n        }\n      };\n      /**\n      * This method places each zero degree member wrt given (x,y) coordinates (top left).\n      */\n\n\n      CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n        x += compoundHorizontalMargin;\n        y += compoundVerticalMargin;\n        var left = x;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          var row = organization.rows[i];\n          x = left;\n          var maxHeight = 0;\n\n          for (var j = 0; j < row.length; j++) {\n            var lnode = row[j];\n            lnode.rect.x = x; // + lnode.rect.width / 2;\n\n            lnode.rect.y = y; // + lnode.rect.height / 2;\n\n            x += lnode.rect.width + organization.horizontalPadding;\n            if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n          }\n\n          y += maxHeight + organization.verticalPadding;\n        }\n      };\n\n      CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n        var self = this;\n        this.tiledMemberPack = [];\n        Object.keys(childGraphMap).forEach(function (id) {\n          // Get the compound node\n          var compoundNode = idToNode[id];\n          self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n          compoundNode.rect.width = self.tiledMemberPack[id].width;\n          compoundNode.rect.height = self.tiledMemberPack[id].height;\n        });\n      };\n\n      CoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n        var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n        var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n        var organization = {\n          rows: [],\n          rowWidth: [],\n          rowHeight: [],\n          width: 0,\n          height: minWidth,\n          // assume minHeight equals to minWidth\n          verticalPadding: verticalPadding,\n          horizontalPadding: horizontalPadding\n        }; // Sort the nodes in ascending order of their areas\n\n        nodes.sort(function (n1, n2) {\n          if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n          if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n          return 0;\n        }); // Create the organization -> tile members\n\n        for (var i = 0; i < nodes.length; i++) {\n          var lNode = nodes[i];\n\n          if (organization.rows.length == 0) {\n            this.insertNodeToRow(organization, lNode, 0, minWidth);\n          } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n            this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n          } else {\n            this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n          }\n\n          this.shiftToLastRow(organization);\n        }\n\n        return organization;\n      };\n\n      CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n        var minCompoundSize = minWidth; // Add new row if needed\n\n        if (rowIndex == organization.rows.length) {\n          var secondDimension = [];\n          organization.rows.push(secondDimension);\n          organization.rowWidth.push(minCompoundSize);\n          organization.rowHeight.push(0);\n        } // Update row width\n\n\n        var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n        if (organization.rows[rowIndex].length > 0) {\n          w += organization.horizontalPadding;\n        }\n\n        organization.rowWidth[rowIndex] = w; // Update compound width\n\n        if (organization.width < w) {\n          organization.width = w;\n        } // Update height\n\n\n        var h = node.rect.height;\n        if (rowIndex > 0) h += organization.verticalPadding;\n        var extraHeight = 0;\n\n        if (h > organization.rowHeight[rowIndex]) {\n          extraHeight = organization.rowHeight[rowIndex];\n          organization.rowHeight[rowIndex] = h;\n          extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n        }\n\n        organization.height += extraHeight; // Insert node\n\n        organization.rows[rowIndex].push(node);\n      }; //Scans the rows of an organization and returns the one with the min width\n\n\n      CoSELayout.prototype.getShortestRowIndex = function (organization) {\n        var r = -1;\n        var min = Number.MAX_VALUE;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          if (organization.rowWidth[i] < min) {\n            r = i;\n            min = organization.rowWidth[i];\n          }\n        }\n\n        return r;\n      }; //Scans the rows of an organization and returns the one with the max width\n\n\n      CoSELayout.prototype.getLongestRowIndex = function (organization) {\n        var r = -1;\n        var max = Number.MIN_VALUE;\n\n        for (var i = 0; i < organization.rows.length; i++) {\n          if (organization.rowWidth[i] > max) {\n            r = i;\n            max = organization.rowWidth[i];\n          }\n        }\n\n        return r;\n      };\n      /**\n      * This method checks whether adding extra width to the organization violates\n      * the aspect ratio(1) or not.\n      */\n\n\n      CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n        var sri = this.getShortestRowIndex(organization);\n\n        if (sri < 0) {\n          return true;\n        }\n\n        var min = organization.rowWidth[sri];\n        if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n        var hDiff = 0; // Adding to an existing row\n\n        if (organization.rowHeight[sri] < extraHeight) {\n          if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n        }\n\n        var add_to_row_ratio;\n\n        if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n          add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n        } else {\n          add_to_row_ratio = (organization.height + hDiff) / organization.width;\n        } // Adding a new row for this node\n\n\n        hDiff = extraHeight + organization.verticalPadding;\n        var add_new_row_ratio;\n\n        if (organization.width < extraWidth) {\n          add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n        } else {\n          add_new_row_ratio = (organization.height + hDiff) / organization.width;\n        }\n\n        if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n        if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n        return add_to_row_ratio < add_new_row_ratio;\n      }; //If moving the last node from the longest row and adding it to the last\n      //row makes the bounding box smaller, do it.\n\n\n      CoSELayout.prototype.shiftToLastRow = function (organization) {\n        var longest = this.getLongestRowIndex(organization);\n        var last = organization.rowWidth.length - 1;\n        var row = organization.rows[longest];\n        var node = row[row.length - 1];\n        var diff = node.width + organization.horizontalPadding; // Check if there is enough space on the last row\n\n        if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n          // Remove the last element of the longest row\n          row.splice(-1, 1); // Push it to the last row\n\n          organization.rows[last].push(node);\n          organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n          organization.rowWidth[last] = organization.rowWidth[last] + diff;\n          organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)]; // Update heights of the organization\n\n          var maxHeight = Number.MIN_VALUE;\n\n          for (var i = 0; i < row.length; i++) {\n            if (row[i].height > maxHeight) maxHeight = row[i].height;\n          }\n\n          if (longest > 0) maxHeight += organization.verticalPadding;\n          var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n          organization.rowHeight[longest] = maxHeight;\n          if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n          var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n          organization.height += finalTotal - prevTotal;\n          this.shiftToLastRow(organization);\n        }\n      };\n\n      CoSELayout.prototype.tilingPreLayout = function () {\n        if (CoSEConstants.TILE) {\n          // Find zero degree nodes and create a compound for each level\n          this.groupZeroDegreeMembers(); // Tile and clear children of each compound\n\n          this.clearCompounds(); // Separately tile and clear zero degree nodes for each level\n\n          this.clearZeroDegreeMembers();\n        }\n      };\n\n      CoSELayout.prototype.tilingPostLayout = function () {\n        if (CoSEConstants.TILE) {\n          this.repopulateZeroDegreeMembers();\n          this.repopulateCompounds();\n        }\n      }; // -----------------------------------------------------------------------------\n      // Section: Tree Reduction methods\n      // -----------------------------------------------------------------------------\n      // Reduce trees \n\n\n      CoSELayout.prototype.reduceTrees = function () {\n        var prunedNodesAll = [];\n        var containsLeaf = true;\n        var node;\n\n        while (containsLeaf) {\n          var allNodes = this.graphManager.getAllNodes();\n          var prunedNodesInStepTemp = [];\n          containsLeaf = false;\n\n          for (var i = 0; i < allNodes.length; i++) {\n            node = allNodes[i];\n\n            if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n              prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n              containsLeaf = true;\n            }\n          }\n\n          if (containsLeaf == true) {\n            var prunedNodesInStep = [];\n\n            for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n              if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n              }\n            }\n\n            prunedNodesAll.push(prunedNodesInStep);\n            this.graphManager.resetAllNodes();\n            this.graphManager.resetAllEdges();\n          }\n        }\n\n        this.prunedNodesAll = prunedNodesAll;\n      }; // Grow tree one step \n\n\n      CoSELayout.prototype.growTree = function (prunedNodesAll) {\n        var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n        var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n        var nodeData;\n\n        for (var i = 0; i < prunedNodesInStep.length; i++) {\n          nodeData = prunedNodesInStep[i];\n          this.findPlaceforPrunedNode(nodeData);\n          nodeData[2].add(nodeData[0]);\n          nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n        }\n\n        prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n        this.graphManager.resetAllNodes();\n        this.graphManager.resetAllEdges();\n      }; // Find an appropriate position to replace pruned node, this method can be improved\n\n\n      CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n        var gridForPrunedNode;\n        var nodeToConnect;\n        var prunedNode = nodeData[0];\n\n        if (prunedNode == nodeData[1].source) {\n          nodeToConnect = nodeData[1].target;\n        } else {\n          nodeToConnect = nodeData[1].source;\n        }\n\n        var startGridX = nodeToConnect.startX;\n        var finishGridX = nodeToConnect.finishX;\n        var startGridY = nodeToConnect.startY;\n        var finishGridY = nodeToConnect.finishY;\n        var upNodeCount = 0;\n        var downNodeCount = 0;\n        var rightNodeCount = 0;\n        var leftNodeCount = 0;\n        var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n        if (startGridY > 0) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n          }\n        }\n\n        if (finishGridX < this.grid.length - 1) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n          }\n        }\n\n        if (finishGridY < this.grid[0].length - 1) {\n          for (var i = startGridX; i <= finishGridX; i++) {\n            controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n          }\n        }\n\n        if (startGridX > 0) {\n          for (var i = startGridY; i <= finishGridY; i++) {\n            controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n          }\n        }\n\n        var min = Integer.MAX_VALUE;\n        var minCount;\n        var minIndex;\n\n        for (var j = 0; j < controlRegions.length; j++) {\n          if (controlRegions[j] < min) {\n            min = controlRegions[j];\n            minCount = 1;\n            minIndex = j;\n          } else if (controlRegions[j] == min) {\n            minCount++;\n          }\n        }\n\n        if (minCount == 3 && min == 0) {\n          if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n            gridForPrunedNode = 1;\n          } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 0;\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 3;\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n            gridForPrunedNode = 2;\n          }\n        } else if (minCount == 2 && min == 0) {\n          var random = Math.floor(Math.random() * 2);\n\n          if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n            ;\n\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 1;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 0;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 2;\n            }\n          } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n            if (random == 0) {\n              gridForPrunedNode = 1;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          } else {\n            if (random == 0) {\n              gridForPrunedNode = 2;\n            } else {\n              gridForPrunedNode = 3;\n            }\n          }\n        } else if (minCount == 4 && min == 0) {\n          var random = Math.floor(Math.random() * 4);\n          gridForPrunedNode = random;\n        } else {\n          gridForPrunedNode = minIndex;\n        }\n\n        if (gridForPrunedNode == 0) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n        } else if (gridForPrunedNode == 1) {\n          prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        } else if (gridForPrunedNode == 2) {\n          prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n        } else {\n          prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n        }\n      };\n\n      module.exports = CoSELayout;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var coseBase = {};\n      coseBase.layoutBase = __webpack_require__(0);\n      coseBase.CoSEConstants = __webpack_require__(1);\n      coseBase.CoSEEdge = __webpack_require__(2);\n      coseBase.CoSEGraph = __webpack_require__(3);\n      coseBase.CoSEGraphManager = __webpack_require__(4);\n      coseBase.CoSELayout = __webpack_require__(6);\n      coseBase.CoSENode = __webpack_require__(5);\n      module.exports = coseBase;\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":{"version":3,"sources":["/root/GraduateProject/node_modules/cose-base/cose-base.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE_0__","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","FDLayoutConstants","CoSEConstants","prop","DEFAULT_USE_MULTI_LEVEL_SCALING","DEFAULT_RADIAL_SEPARATION","DEFAULT_EDGE_LENGTH","DEFAULT_COMPONENT_SEPERATION","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","TREE_REDUCTION_ON_INCREMENTAL","FDLayoutEdge","CoSEEdge","source","target","vEdge","create","LGraph","CoSEGraph","parent","graphMgr","vGraph","LGraphManager","CoSEGraphManager","layout","FDLayoutNode","IMath","CoSENode","gm","loc","size","vNode","move","graphManager","getLayout","displacementX","coolingFactor","springForceX","repulsionForceX","gravitationForceX","noOfChildren","displacementY","springForceY","repulsionForceY","gravitationForceY","Math","abs","maxNodeDisplacement","sign","child","moveBy","getNodes","length","propogateDisplacementToChildren","totalDisplacement","dX","dY","nodes","getChild","node","setPred1","pred1","getPred1","getPred2","pred2","setNext","next","getNext","setProcessed","processed","isProcessed","FDLayout","LayoutConstants","Point","PointD","Layout","Integer","IGeometry","Transform","CoSELayout","toBeTiled","newGraphManager","newGraph","newNode","newEdge","initParameters","arguments","isSubLayout","idealEdgeLength","useSmartIdealEdgeLengthCalculation","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","springConstant","DEFAULT_SPRING_STRENGTH","repulsionConstant","DEFAULT_REPULSION_STRENGTH","gravityConstant","DEFAULT_GRAVITY_STRENGTH","compoundGravityConstant","DEFAULT_COMPOUND_GRAVITY_STRENGTH","gravityRangeFactor","DEFAULT_GRAVITY_RANGE_FACTOR","compoundGravityRangeFactor","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","prunedNodesAll","growTreeIterations","afterGrowthIterations","isTreeGrowing","isGrowthFinished","coolingCycle","maxCoolingCycle","maxIterations","CONVERGENCE_CHECK_PERIOD","finalTemperature","coolingAdjuster","createBendsAsNeeded","DEFAULT_CREATE_BENDS_AS_NEEDED","createBendpoints","resetAllEdges","level","classicLayout","nodesWithGravity","calculateNodesToApplyGravitationTo","setAllNodesToApplyGravitation","calcNoOfChildrenForAllNodes","calcLowestCommonAncestors","calcInclusionTreeDepths","getRoot","calcEstimatedSize","calcIdealEdgeLengths","incremental","forest","getFlatForest","positionNodesRadially","reduceTrees","resetAllNodesToApplyGravitation","allNodes","Set","getAllNodes","intersection","filter","x","has","positionNodesRandomly","initSpringEmbedder","runSpringEmbedder","tick","totalIterations","isConverged","layoutQuality","max","initialCoolingFactor","pow","log","animationPeriod","ceil","initialAnimationPeriod","sqrt","updateBounds","updateGrid","growTree","DEFAULT_COOLING_FACTOR_INCREMENTAL","gridUpdateAllowed","forceToNodeSurroundingUpdate","calcSpringForces","calcRepulsionForces","calcGravitationalForces","moveNodes","animate","getPositionsData","pData","rect","id","getCenterX","y","getCenterY","w","width","h","height","layoutEnded","ANIMATE","emit","nodeList","graph","graphs","getGraphs","updateConnected","isConnected","concat","edges","getAllEdges","visited","edge","getSource","getTarget","getBendpoints","push","createDummyNodesForBendpoints","add","edgeList","getEdgeListToNode","k","multiEdge","forEach","currentStartingPoint","numberOfColumns","currentY","currentX","point","tree","centerNode","findCenterOfTree","radialLayout","floor","transform","WORLD_CENTER_X","WORLD_CENTER_Y","startingPoint","radialSep","maxDiagonalInTree","branchRadialLayout","bounds","calculateBounds","setDeviceOrgX","getMinX","setDeviceOrgY","getMinY","setWorldOrgX","setWorldOrgY","bottomRight","getMaxX","getMaxY","inverseTransformPoint","parentOfNode","startAngle","endAngle","distance","radialSeparation","halfInterval","nodeAngle","teta","TWO_PI","cos_teta","cos","x_","y_","sin","setCenter","neighborEdges","getEdges","childCount","branchCount","incEdgesCount","startIndex","getEdgesBetween","temp","splice","index","indexOf","stepAngle","currentNeighbor","getOtherEnd","childStartAngle","childEndAngle","maxDiagonal","MIN_VALUE","diagonal","getDiagonal","calcRepulsionRange","groupZeroDegreeMembers","self","tempMemberGroups","memberGroups","idToDummyNode","zeroDegree","getParent","getNodeDegreeWithChildren","undefined","getToBeTiled","p_id","keys","dummyCompoundId","dummyCompound","paddingLeft","paddingRight","paddingBottom","paddingTop","dummyParentGraph","getGraphManager","parentGraph","remove","clearCompounds","childGraphMap","idToNode","performDFSOnCompounds","compoundOrder","resetAllNodes","tileCompoundMembers","clearZeroDegreeMembers","tiledZeroDegreePack","compoundNode","tileNodes","repopulateCompounds","lCompoundNode","horizontalMargin","verticalMargin","adjustLocations","tiledMemberPack","repopulateZeroDegreeMembers","tiledPack","childGraph","children","theChild","getNodeDegree","degree","fillCompexOrderByDFS","organization","compoundHorizontalMargin","compoundVerticalMargin","left","rows","row","maxHeight","j","lnode","horizontalPadding","verticalPadding","minWidth","rowWidth","rowHeight","sort","n1","n2","lNode","insertNodeToRow","canAddHorizontal","getShortestRowIndex","shiftToLastRow","rowIndex","minCompoundSize","secondDimension","extraHeight","r","min","Number","MAX_VALUE","getLongestRowIndex","extraWidth","sri","hDiff","add_to_row_ratio","add_new_row_ratio","longest","last","diff","instance","prevTotal","finalTotal","tilingPreLayout","tilingPostLayout","containsLeaf","prunedNodesInStepTemp","isInterGraph","getOwner","prunedNodesInStep","lengthOfPrunedNodesInStep","nodeData","findPlaceforPrunedNode","gridForPrunedNode","nodeToConnect","prunedNode","startGridX","startX","finishGridX","finishX","startGridY","startY","finishGridY","finishY","upNodeCount","downNodeCount","rightNodeCount","leftNodeCount","controlRegions","grid","minCount","minIndex","random","getHeight","getWidth","coseBase","layoutBase"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"layout-base\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"layout-base\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"coseBase\"] = factory(require(\"layout-base\"));\n\telse\n\t\troot[\"coseBase\"] = factory(root[\"layoutBase\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph = __webpack_require__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __webpack_require__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __webpack_require__(0).FDLayoutNode;\nvar IMath = __webpack_require__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar FDLayout = __webpack_require__(0).FDLayout;\nvar CoSEGraphManager = __webpack_require__(4);\nvar CoSEGraph = __webpack_require__(3);\nvar CoSENode = __webpack_require__(5);\nvar CoSEEdge = __webpack_require__(2);\nvar CoSEConstants = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;\nvar LayoutConstants = __webpack_require__(0).LayoutConstants;\nvar Point = __webpack_require__(0).Point;\nvar PointD = __webpack_require__(0).PointD;\nvar Layout = __webpack_require__(0).Layout;\nvar Integer = __webpack_require__(0).Integer;\nvar IGeometry = __webpack_require__(0).IGeometry;\nvar LGraph = __webpack_require__(0).LGraph;\nvar Transform = __webpack_require__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __webpack_require__(0);\ncoseBase.CoSEConstants = __webpack_require__(1);\ncoseBase.CoSEEdge = __webpack_require__(2);\ncoseBase.CoSEGraph = __webpack_require__(3);\ncoseBase.CoSEGraphManager = __webpack_require__(4);\ncoseBase.CoSELayout = __webpack_require__(6);\ncoseBase.CoSENode = __webpack_require__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});"]},"metadata":{},"sourceType":"script"}