{"ast":null,"code":"import _defineProperty from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _WIZARD_TITLES;\n\nimport { PeerAuthenticationMutualTLSMode } from '../../types/IstioObjects';\nimport { serverConfig } from '../../config';\nimport { ConsistentHashType, MUTUAL, UNSET } from './TrafficPolicy';\nimport { ALLOW } from '../../pages/IstioConfigNew/AuthorizationPolicyForm';\nimport { NodeType } from '../../types/Graph';\nexport var WIZARD_TRAFFIC_SHIFTING = 'traffic_shifting';\nexport var WIZARD_TCP_TRAFFIC_SHIFTING = 'tcp_traffic_shifting';\nexport var WIZARD_REQUEST_ROUTING = 'request_routing';\nexport var WIZARD_FAULT_INJECTION = 'fault_injection';\nexport var WIZARD_REQUEST_TIMEOUTS = 'request_timeouts';\nexport var WIZARD_ENABLE_AUTO_INJECTION = 'enable_auto_injection';\nexport var WIZARD_DISABLE_AUTO_INJECTION = 'disable_auto_injection';\nexport var WIZARD_REMOVE_AUTO_INJECTION = 'remove_auto_injection';\nexport var SERVICE_WIZARD_ACTIONS = [WIZARD_REQUEST_ROUTING, WIZARD_FAULT_INJECTION, WIZARD_TRAFFIC_SHIFTING, WIZARD_TCP_TRAFFIC_SHIFTING, WIZARD_REQUEST_TIMEOUTS];\nexport var WIZARD_TITLES = (_WIZARD_TITLES = {}, _defineProperty(_WIZARD_TITLES, WIZARD_REQUEST_ROUTING, 'Request Routing'), _defineProperty(_WIZARD_TITLES, WIZARD_FAULT_INJECTION, 'Fault Injection'), _defineProperty(_WIZARD_TITLES, WIZARD_TRAFFIC_SHIFTING, 'Traffic Shifting'), _defineProperty(_WIZARD_TITLES, WIZARD_TCP_TRAFFIC_SHIFTING, 'TCP Traffic Shifting'), _defineProperty(_WIZARD_TITLES, WIZARD_REQUEST_TIMEOUTS, 'Request Timeouts'), _WIZARD_TITLES);\nexport var KIALI_WIZARD_LABEL = 'kiali_wizard';\nexport var KIALI_RELATED_LABEL = 'kiali_wizard_related';\nexport var fqdnServiceName = function fqdnServiceName(serviceName, namespace) {\n  return serviceName + '.' + namespace + '.' + serverConfig.istioIdentityDomain;\n};\n\nvar buildHTTPMatchRequest = function buildHTTPMatchRequest(matches) {\n  var matchRequests = [];\n  var matchHeaders = {\n    headers: {}\n  }; // Headers are grouped\n\n  matches.filter(function (match) {\n    return match.startsWith('headers');\n  }).forEach(function (match) {\n    // match follows format:  headers [<header-name>] <op> <value>\n    var i0 = match.indexOf('[');\n    var j0 = match.indexOf(']');\n    var headerName = match.substring(i0 + 1, j0).trim();\n    var i1 = match.indexOf(' ', j0 + 1);\n    var j1 = match.indexOf(' ', i1 + 1);\n    var op = match.substring(i1 + 1, j1).trim();\n    var value = match.substring(j1 + 1).trim();\n    matchHeaders.headers[headerName] = _defineProperty({}, op, value);\n  });\n\n  if (Object.keys(matchHeaders.headers || {}).length > 0) {\n    matchRequests.push(matchHeaders);\n  } // Rest of matches\n\n\n  matches.filter(function (match) {\n    return !match.startsWith('headers');\n  }).forEach(function (match) {\n    // match follows format: <name> <op> <value>\n    var i = match.indexOf(' ');\n    var j = match.indexOf(' ', i + 1);\n    var name = match.substring(0, i).trim();\n    var op = match.substring(i + 1, j).trim();\n    var value = match.substring(j + 1).trim();\n    matchRequests.push(_defineProperty({}, name, _defineProperty({}, op, value)));\n  });\n  return matchRequests;\n};\n\nvar parseStringMatch = function parseStringMatch(value) {\n  if (value.exact) {\n    return 'exact ' + value.exact;\n  }\n\n  if (value.prefix) {\n    return 'prefix ' + value.prefix;\n  }\n\n  if (value.regex) {\n    return 'regex ' + value.regex;\n  }\n\n  return '';\n};\n\nvar parseHttpMatchRequest = function parseHttpMatchRequest(httpMatchRequest) {\n  var matches = []; // Headers\n\n  if (httpMatchRequest.headers) {\n    Object.keys(httpMatchRequest.headers).forEach(function (headerName) {\n      var value = httpMatchRequest.headers[headerName];\n      matches.push('headers [' + headerName + '] ' + parseStringMatch(value));\n    });\n  }\n\n  if (httpMatchRequest.uri) {\n    matches.push('uri ' + parseStringMatch(httpMatchRequest.uri));\n  }\n\n  if (httpMatchRequest.scheme) {\n    matches.push('scheme ' + parseStringMatch(httpMatchRequest.scheme));\n  }\n\n  if (httpMatchRequest.method) {\n    matches.push('method ' + parseStringMatch(httpMatchRequest.method));\n  }\n\n  if (httpMatchRequest.authority) {\n    matches.push('authority ' + parseStringMatch(httpMatchRequest.authority));\n  }\n\n  return matches;\n};\n\nexport var getGatewayName = function getGatewayName(namespace, serviceName, gatewayNames) {\n  var gatewayName = namespace + '/' + serviceName + '-gateway';\n\n  if (gatewayNames.length === 0) {\n    return gatewayName;\n  }\n\n  var goodName = false;\n\n  while (!goodName) {\n    if (!gatewayNames.includes(gatewayName)) {\n      goodName = true;\n    } else {\n      // Iterate until we find a good gatewayName\n      if (gatewayName.charAt(gatewayName.length - 2) === '-') {\n        var version = +gatewayName.charAt(gatewayName.length - 1);\n        version = version + 1;\n        gatewayName = gatewayName.substr(0, gatewayName.length - 1) + version;\n      } else {\n        gatewayName = gatewayName + '-1';\n      }\n    }\n  }\n\n  return gatewayName;\n};\nexport var buildIstioConfig = function buildIstioConfig(wProps, wState) {\n  var wkdNameVersion = {}; // DestinationRule from the labels\n\n  var drName = wProps.serviceName; // In some limited scenarios DR may be created externally to Kiali (i.e. extensions)\n\n  if (wProps.destinationRules.items.length === 1 && wProps.destinationRules.items[0].metadata.name !== drName) {\n    drName = wProps.destinationRules.items[0].metadata.name;\n  }\n\n  var wizardDR = {\n    metadata: {\n      namespace: wProps.namespace,\n      name: drName,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, wProps.type)\n    },\n    spec: {\n      host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n    }\n  };\n  var subsets = wProps.workloads.filter(function (workload) {\n    // Filter out workloads without version label\n    var versionLabelName = serverConfig.istioLabels.versionLabelName;\n    return workload.labels[versionLabelName];\n  }).map(function (workload) {\n    // Using version\n    var versionLabelName = serverConfig.istioLabels.versionLabelName;\n    var versionValue = workload.labels[versionLabelName];\n    var labels = {};\n    labels[versionLabelName] = versionValue; // Populate helper table workloadName -> version\n\n    wkdNameVersion[workload.name] = versionValue;\n    return {\n      name: versionValue,\n      labels: labels\n    };\n  });\n\n  if (subsets.length > 0) {\n    wizardDR.spec.subsets = subsets;\n  } // In some limited scenarios VS may be created externally to Kiali (i.e. extensions)\n\n\n  var vsName = wProps.serviceName;\n\n  if (wProps.virtualServices.items.length === 1 && wProps.virtualServices.items[0].metadata.name !== vsName) {\n    vsName = wProps.virtualServices.items[0].metadata.name;\n  }\n\n  var wizardVS = {\n    metadata: {\n      namespace: wProps.namespace,\n      name: vsName,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, wProps.type)\n    },\n    spec: {}\n  };\n  var wizardPA = undefined; // Wizard is optional, only when user has explicitly selected \"Create a Gateway\"\n\n  var fullNewGatewayName = getGatewayName(wProps.namespace, wProps.serviceName, wProps.gateways);\n  var wizardGW = wState.gateway && wState.gateway.addGateway && wState.gateway.newGateway ? {\n    metadata: {\n      namespace: wProps.namespace,\n      name: fullNewGatewayName.substr(wProps.namespace.length + 1),\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, wProps.type)\n    },\n    spec: {\n      selector: {\n        istio: 'ingressgateway'\n      },\n      servers: [{\n        port: {\n          number: wState.gateway.port,\n          name: 'http',\n          protocol: 'HTTP'\n        },\n        hosts: wState.gateway.gwHosts.split(',')\n      }]\n    }\n  } : undefined;\n\n  switch (wProps.type) {\n    case WIZARD_TRAFFIC_SHIFTING:\n      {\n        var _wizardVS$spec, _wizardVS$spec$http;\n\n        // VirtualService from the weights\n        wizardVS.spec = {\n          http: [{\n            route: wState.workloads.filter(function (workload) {\n              return !workload.mirrored;\n            }).map(function (workload) {\n              var httpRouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n\n              if (wkdNameVersion[workload.name]) {\n                httpRouteDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n\n              return httpRouteDestination;\n            })\n          }]\n        }; // Update HTTP Route with mirror destination + percentage\n\n        var mirrorWorkload = wState.workloads.filter(function (workload) {\n          return workload.mirrored;\n        }).pop();\n\n        if (mirrorWorkload && (wizardVS === null || wizardVS === void 0 ? void 0 : (_wizardVS$spec = wizardVS.spec) === null || _wizardVS$spec === void 0 ? void 0 : (_wizardVS$spec$http = _wizardVS$spec.http) === null || _wizardVS$spec$http === void 0 ? void 0 : _wizardVS$spec$http.length) === 1) {\n          wizardVS.spec.http[0].mirror = {\n            host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n          };\n\n          if (wkdNameVersion[mirrorWorkload.name]) {\n            wizardVS.spec.http[0].mirror.subset = wkdNameVersion[mirrorWorkload.name];\n          }\n\n          wizardVS.spec.http[0].mirrorPercentage = {\n            value: mirrorWorkload.weight\n          };\n        }\n\n        break;\n      }\n\n    case WIZARD_TCP_TRAFFIC_SHIFTING:\n      {\n        // VirtualService from the weights\n        wizardVS.spec = {\n          tcp: [{\n            route: wState.workloads.map(function (workload) {\n              var routeDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n\n              if (wkdNameVersion[workload.name]) {\n                routeDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n\n              return routeDestination;\n            })\n          }]\n        };\n        break;\n      }\n\n    case WIZARD_REQUEST_ROUTING:\n      {\n        // VirtualService from the routes\n        wizardVS.spec = {\n          http: wState.rules.map(function (rule) {\n            var httpRoute = {};\n            httpRoute.route = [];\n            rule.workloadWeights.filter(function (workload) {\n              return !workload.mirrored;\n            }).forEach(function (workload) {\n              var _httpRoute$route;\n\n              var destW = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n\n              if (wkdNameVersion[workload.name]) {\n                destW.destination.subset = wkdNameVersion[workload.name];\n              }\n\n              (_httpRoute$route = httpRoute.route) === null || _httpRoute$route === void 0 ? void 0 : _httpRoute$route.push(destW);\n            });\n            var mirrorWorkload = rule.workloadWeights.filter(function (workload) {\n              return workload.mirrored;\n            }).pop();\n\n            if (mirrorWorkload) {\n              httpRoute.mirror = {\n                host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n              };\n\n              if (wkdNameVersion[mirrorWorkload.name]) {\n                httpRoute.mirror.subset = wkdNameVersion[mirrorWorkload.name];\n              }\n\n              httpRoute.mirrorPercentage = {\n                value: mirrorWorkload.weight\n              };\n            }\n\n            if (rule.matches.length > 0) {\n              httpRoute.match = buildHTTPMatchRequest(rule.matches);\n            }\n\n            if (rule.delay || rule.abort) {\n              httpRoute.fault = {};\n\n              if (rule.delay) {\n                httpRoute.fault.delay = rule.delay;\n              }\n\n              if (rule.abort) {\n                httpRoute.fault.abort = rule.abort;\n              }\n            }\n\n            if (rule.timeout) {\n              httpRoute.timeout = rule.timeout;\n            }\n\n            if (rule.retries) {\n              httpRoute.retries = rule.retries;\n            }\n\n            return httpRoute;\n          })\n        };\n        break;\n      }\n\n    case WIZARD_FAULT_INJECTION:\n      {\n        // VirtualService from the weights mapped in the FaultInjectionRoute\n        wizardVS.spec = {\n          http: [{\n            route: wState.faultInjectionRoute.workloads.map(function (workload) {\n              var httpRouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n\n              if (wkdNameVersion[workload.name]) {\n                httpRouteDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n\n              return httpRouteDestination;\n            })\n          }]\n        };\n\n        if (wizardVS.spec.http && wizardVS.spec.http[0]) {\n          if (wState.faultInjectionRoute.delayed || wState.faultInjectionRoute.aborted) {\n            wizardVS.spec.http[0].fault = {};\n\n            if (wState.faultInjectionRoute.delayed) {\n              wizardVS.spec.http[0].fault.delay = wState.faultInjectionRoute.delay;\n            }\n\n            if (wState.faultInjectionRoute.aborted) {\n              wizardVS.spec.http[0].fault.abort = wState.faultInjectionRoute.abort;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case WIZARD_REQUEST_TIMEOUTS:\n      {\n        // VirtualService from the weights mapped in the TimeoutRetryRoute\n        wizardVS.spec = {\n          http: [{\n            route: wState.timeoutRetryRoute.workloads.map(function (workload) {\n              var httpRouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace),\n                  subset: wkdNameVersion[workload.name]\n                },\n                weight: workload.weight\n              };\n\n              if (wkdNameVersion[workload.name]) {\n                httpRouteDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n\n              return httpRouteDestination;\n            })\n          }]\n        };\n\n        if (wizardVS.spec.http && wizardVS.spec.http[0]) {\n          if (wState.timeoutRetryRoute.isTimeout) {\n            wizardVS.spec.http[0].timeout = wState.timeoutRetryRoute.timeout;\n          }\n\n          if (wState.timeoutRetryRoute.isRetry) {\n            wizardVS.spec.http[0].retries = wState.timeoutRetryRoute.retries;\n          }\n        }\n\n        break;\n      }\n\n    default:\n      console.log('Unrecognized type');\n  }\n\n  wizardVS.spec.hosts = wState.vsHosts.length > 1 || wState.vsHosts.length === 1 && wState.vsHosts[0].length > 0 ? wState.vsHosts : [wProps.serviceName];\n\n  if (wState.trafficPolicy.tlsModified && wState.trafficPolicy.mtlsMode !== UNSET) {\n    wizardDR.spec.trafficPolicy = {};\n    wizardDR.spec.trafficPolicy.tls = {\n      mode: wState.trafficPolicy.mtlsMode,\n      clientCertificate: null,\n      privateKey: null,\n      caCertificates: null\n    };\n\n    if (wState.trafficPolicy.mtlsMode === MUTUAL) {\n      wizardDR.spec.trafficPolicy.tls.clientCertificate = wState.trafficPolicy.clientCertificate;\n      wizardDR.spec.trafficPolicy.tls.privateKey = wState.trafficPolicy.privateKey;\n      wizardDR.spec.trafficPolicy.tls.caCertificates = wState.trafficPolicy.caCertificates;\n    }\n  }\n\n  if (wState.trafficPolicy.peerAuthnSelector.addPeerAuthentication) {\n    var peerAuthnLabels = {};\n    peerAuthnLabels[serverConfig.istioLabels.appLabelName] = wProps.workloads[0].labels[serverConfig.istioLabels.appLabelName];\n    wizardPA = {\n      metadata: {\n        namespace: wProps.namespace,\n        name: wProps.serviceName,\n        labels: _defineProperty({}, KIALI_WIZARD_LABEL, wProps.type)\n      },\n      spec: {\n        selector: {\n          matchLabels: peerAuthnLabels\n        },\n        mtls: {\n          mode: wState.trafficPolicy.peerAuthnSelector.mode\n        }\n      }\n    };\n    wizardDR.metadata.annotations = {};\n    wizardDR.metadata.annotations[KIALI_RELATED_LABEL] = 'PeerAuthentication/' + wProps.serviceName;\n  }\n\n  if (wState.trafficPolicy.addLoadBalancer) {\n    if (!wizardDR.spec.trafficPolicy) {\n      wizardDR.spec.trafficPolicy = {};\n    }\n\n    if (wState.trafficPolicy.simpleLB) {\n      // Remember to put a null fields that need to be deleted on a JSON merge patch\n      wizardDR.spec.trafficPolicy.loadBalancer = {\n        simple: wState.trafficPolicy.loadBalancer.simple,\n        consistentHash: null\n      };\n    } else {\n      wizardDR.spec.trafficPolicy.loadBalancer = {\n        simple: null,\n        consistentHash: {}\n      };\n      wizardDR.spec.trafficPolicy.loadBalancer.consistentHash = {\n        httpHeaderName: null,\n        httpCookie: null,\n        useSourceIp: null\n      };\n\n      if (wState.trafficPolicy.loadBalancer.consistentHash) {\n        var consistentHash = wState.trafficPolicy.loadBalancer.consistentHash;\n\n        switch (wState.trafficPolicy.consistentHashType) {\n          case ConsistentHashType.HTTP_HEADER_NAME:\n            wizardDR.spec.trafficPolicy.loadBalancer.consistentHash.httpHeaderName = consistentHash.httpHeaderName;\n            break;\n\n          case ConsistentHashType.HTTP_COOKIE:\n            wizardDR.spec.trafficPolicy.loadBalancer.consistentHash.httpCookie = consistentHash.httpCookie;\n            break;\n\n          case ConsistentHashType.USE_SOURCE_IP:\n            wizardDR.spec.trafficPolicy.loadBalancer.consistentHash.useSourceIp = true;\n            break;\n\n          default: /// No default action\n\n        }\n      }\n    }\n  }\n\n  if (wState.trafficPolicy.addConnectionPool) {\n    if (!wizardDR.spec.trafficPolicy) {\n      wizardDR.spec.trafficPolicy = {};\n    }\n\n    wizardDR.spec.trafficPolicy.connectionPool = wState.trafficPolicy.connectionPool;\n  }\n\n  if (wState.trafficPolicy.addOutlierDetection) {\n    if (!wizardDR.spec.trafficPolicy) {\n      wizardDR.spec.trafficPolicy = {};\n    }\n\n    wizardDR.spec.trafficPolicy.outlierDetection = wState.trafficPolicy.outlierDetection;\n  } // If traffic policy has empty objects, it will be invalidated because galleys expects at least one non-empty field.\n\n\n  if (!wizardDR.spec.trafficPolicy) {\n    wizardDR.spec.trafficPolicy = null;\n  } // If there isn't any PeerAuthn created/updated, remove the DR annotation\n\n\n  if (!wizardPA) {\n    // @ts-ignore\n    wizardDR.metadata.annotations = null;\n  }\n\n  if (wState.gateway && wState.gateway.addGateway) {\n    wizardVS.spec.gateways = [];\n\n    if (wState.gateway.newGateway) {\n      wizardVS.spec.gateways.push(fullNewGatewayName);\n    } else if (wState.gateway.selectedGateway.length > 0) {\n      wizardVS.spec.gateways.push(wState.gateway.selectedGateway);\n    }\n\n    if (wState.gateway.addMesh && !wizardVS.spec.gateways.includes('mesh')) {\n      wizardVS.spec.gateways.push('mesh');\n    } // Don't leave empty gateways\n\n\n    if (wizardVS.spec.gateways.length === 0) {\n      wizardVS.spec.gateways = null;\n    }\n  } else {\n    wizardVS.spec.gateways = null;\n  }\n\n  return [wizardDR, wizardVS, wizardGW, wizardPA];\n};\n\nvar getWorkloadsByVersion = function getWorkloadsByVersion(workloads, destinationRules) {\n  var versionLabelName = serverConfig.istioLabels.versionLabelName;\n  var wkdVersionName = {};\n  workloads.forEach(function (workload) {\n    return wkdVersionName[workload.labels[versionLabelName]] = workload.name;\n  });\n\n  if (destinationRules.items.length > 0) {\n    destinationRules.items.forEach(function (dr) {\n      var _dr$spec$subsets;\n\n      (_dr$spec$subsets = dr.spec.subsets) === null || _dr$spec$subsets === void 0 ? void 0 : _dr$spec$subsets.forEach(function (ss) {\n        var version = ss.labels[versionLabelName];\n        wkdVersionName[ss.name] = wkdVersionName[version];\n      });\n    });\n  }\n\n  return wkdVersionName;\n};\n\nexport var getDefaultWeights = function getDefaultWeights(workloads) {\n  var wkTraffic = workloads.length < 100 ? Math.floor(100 / workloads.length) : 0;\n  var remainTraffic = workloads.length < 100 ? 100 % workloads.length : 0;\n  var wkWeights = workloads.map(function (workload) {\n    return {\n      name: workload.name,\n      weight: wkTraffic,\n      locked: false,\n      maxWeight: 100,\n      mirrored: false\n    };\n  });\n\n  if (remainTraffic > 0) {\n    wkWeights[wkWeights.length - 1].weight = wkWeights[wkWeights.length - 1].weight + remainTraffic;\n  }\n\n  return wkWeights;\n};\nexport var getInitWeights = function getInitWeights(workloads, virtualServices, destinationRules) {\n  var wkdVersionName = getWorkloadsByVersion(workloads, destinationRules);\n  var wkdWeights = [];\n\n  if (virtualServices.items.length === 1) {\n    var route;\n\n    if (virtualServices.items[0].spec.http && virtualServices.items[0].spec.http.length === 1) {\n      route = virtualServices.items[0].spec.http[0];\n    }\n\n    if (virtualServices.items[0].spec.tcp && virtualServices.items[0].spec.tcp.length === 1) {\n      route = virtualServices.items[0].spec.tcp[0];\n    }\n\n    if (route) {\n      var _route$route;\n\n      // Populate WorkloadWeights from a VirtualService\n      (_route$route = route.route) === null || _route$route === void 0 ? void 0 : _route$route.forEach(function (route) {\n        if (route.destination.subset && wkdVersionName[route.destination.subset]) {\n          wkdWeights.push({\n            name: wkdVersionName[route.destination.subset],\n            weight: route.weight || 0,\n            locked: false,\n            maxWeight: 100,\n            mirrored: false\n          });\n        }\n      }); // Convention: we place the mirror routes as last position\n\n      if (route.mirror) {\n        var httpRoute = route; // Check mirror on HTTP Route\n\n        if (httpRoute.mirror && httpRoute.mirror.subset && wkdVersionName[httpRoute.mirror.subset]) {\n          var mirrorPercentage = httpRoute.mirrorPercentage ? httpRoute.mirrorPercentage.value : 100;\n          wkdWeights.push({\n            name: wkdVersionName[httpRoute.mirror.subset],\n            weight: mirrorPercentage,\n            locked: false,\n            maxWeight: 100,\n            mirrored: true\n          });\n        }\n      }\n    }\n  } // Add new workloads with 0 weight if there is missing workloads\n\n\n  if (wkdWeights.length > 0 && workloads.length !== wkdWeights.length) {\n    for (var i = 0; i < workloads.length; i++) {\n      var wkd = workloads[i];\n      var newWkd = true;\n\n      for (var j = 0; j < wkdWeights.length; j++) {\n        var wkdWeight = wkdWeights[j];\n\n        if (wkd.name === wkdWeight.name) {\n          newWkd = false;\n          break;\n        }\n      }\n\n      if (newWkd) {\n        wkdWeights.push({\n          name: wkd.name,\n          weight: 0,\n          locked: false,\n          maxWeight: 100,\n          mirrored: false\n        });\n      }\n    }\n  }\n\n  return wkdWeights;\n};\nexport var getInitRules = function getInitRules(workloads, virtualServices, destinationRules) {\n  var wkdVersionName = getWorkloadsByVersion(workloads, destinationRules);\n  var rules = [];\n\n  if (virtualServices.items.length === 1) {\n    virtualServices.items[0].spec.http.forEach(function (httpRoute) {\n      var rule = {\n        matches: [],\n        workloadWeights: []\n      };\n\n      if (httpRoute.match) {\n        httpRoute.match.forEach(function (m) {\n          return rule.matches = rule.matches.concat(parseHttpMatchRequest(m));\n        });\n      }\n\n      if (httpRoute.route) {\n        httpRoute.route.forEach(function (r) {\n          var subset = r.destination.subset;\n          var workload = wkdVersionName[subset || '']; // Not adding a route if a workload is not found with a destination subset\n          // That means that a workload has been deleted after a VS/DR has been generated\n\n          if (workload) {\n            rule.workloadWeights.push({\n              name: workload,\n              weight: r.weight ? r.weight : 0,\n              locked: false,\n              maxWeight: 100,\n              mirrored: false\n            });\n          }\n        });\n      }\n\n      if (httpRoute.mirror) {\n        var subset = httpRoute.mirror.subset;\n        var workload = wkdVersionName[subset || ''];\n        rule.workloadWeights.push({\n          name: workload,\n          weight: httpRoute.mirrorPercentage ? httpRoute.mirrorPercentage.value : 100,\n          locked: false,\n          maxWeight: 100,\n          mirrored: true\n        });\n      }\n\n      if (httpRoute.fault) {\n        if (httpRoute.fault.delay) {\n          rule.delay = httpRoute.fault.delay;\n        }\n\n        if (httpRoute.fault.abort) {\n          rule.abort = httpRoute.fault.abort;\n        }\n      }\n\n      if (httpRoute.timeout) {\n        rule.timeout = httpRoute.timeout;\n      }\n\n      if (httpRoute.retries) {\n        rule.retries = httpRoute.retries;\n      } // Not adding a rule if it has empty routes, probably this means that an existing workload was removed\n\n\n      if (rule.workloadWeights.length > 0) {\n        rules.push(rule);\n      }\n    });\n  }\n\n  return rules;\n};\nexport var getInitFaultInjectionRoute = function getInitFaultInjectionRoute(workloads, virtualServices, destinationRules) {\n  // Read potential predefined weights\n  var initWeights = getInitWeights(workloads, virtualServices, destinationRules);\n\n  if (workloads.length > 0 && initWeights.length === 0) {\n    initWeights = getDefaultWeights(workloads);\n  }\n\n  var fiRoute = {\n    workloads: initWeights,\n    delayed: false,\n    delay: {\n      percentage: {\n        value: 100\n      },\n      fixedDelay: '5s'\n    },\n    isValidDelay: true,\n    aborted: false,\n    abort: {\n      percentage: {\n        value: 100\n      },\n      httpStatus: 503\n    },\n    isValidAbort: true\n  }; // This use case is intended for VS with single HTTP Route, others scenarios should use the Request Routing Wizard\n\n  if (virtualServices.items.length === 1 && virtualServices.items[0].spec.http && virtualServices.items[0].spec.http.length === 1 && virtualServices.items[0].spec.http[0].fault) {\n    var fault = virtualServices.items[0].spec.http[0].fault;\n\n    if (fault.delay) {\n      fiRoute.delayed = true;\n      fiRoute.delay.percentage.value = fault.delay.percentage ? fault.delay.percentage.value : 100;\n      fiRoute.delay.fixedDelay = fault.delay.fixedDelay;\n    }\n\n    if (fault.abort) {\n      fiRoute.aborted = true;\n      fiRoute.abort.percentage.value = fault.abort.percentage ? fault.abort.percentage.value : 100;\n      fiRoute.abort.httpStatus = fault.abort.httpStatus;\n    }\n  }\n\n  return fiRoute;\n};\nexport var getInitTimeoutRetryRoute = function getInitTimeoutRetryRoute(workloads, virtualServices, destinationRules) {\n  // Read potential predefined weights\n  var initWeights = getInitWeights(workloads, virtualServices, destinationRules);\n\n  if (workloads.length > 0 && initWeights.length === 0) {\n    initWeights = getDefaultWeights(workloads);\n  }\n\n  var trRoute = {\n    workloads: initWeights,\n    isTimeout: false,\n    timeout: '2s',\n    isValidTimeout: true,\n    isRetry: false,\n    retries: {\n      attempts: 3,\n      perTryTimeout: '2s',\n      retryOn: 'gateway-error,connect-failure,refused-stream'\n    },\n    isValidRetry: true\n  }; // This use case is intended for VS with single HTTP Route, others scenarios should use the Request Routing Wizard\n\n  if (virtualServices.items.length === 1 && virtualServices.items[0].spec.http && virtualServices.items[0].spec.http.length === 1) {\n    if (virtualServices.items[0].spec.http[0].timeout) {\n      trRoute.isTimeout = true;\n      trRoute.timeout = virtualServices.items[0].spec.http[0].timeout;\n    }\n\n    if (virtualServices.items[0].spec.http[0].retries) {\n      trRoute.isRetry = true;\n      trRoute.retries.attempts = virtualServices.items[0].spec.http[0].retries.attempts;\n\n      if (virtualServices.items[0].spec.http[0].retries.perTryTimeout) {\n        trRoute.retries.perTryTimeout = virtualServices.items[0].spec.http[0].retries.perTryTimeout;\n      }\n\n      if (virtualServices.items[0].spec.http[0].retries.retryOn) {}\n    }\n  }\n\n  return trRoute;\n};\nexport var getInitTlsMode = function getInitTlsMode(destinationRules) {\n  if (destinationRules.items.length === 1 && destinationRules.items[0].spec.trafficPolicy && destinationRules.items[0].spec.trafficPolicy.tls) {\n    return [destinationRules.items[0].spec.trafficPolicy.tls.mode || '', destinationRules.items[0].spec.trafficPolicy.tls.clientCertificate || '', destinationRules.items[0].spec.trafficPolicy.tls.privateKey || '', destinationRules.items[0].spec.trafficPolicy.tls.caCertificates || ''];\n  }\n\n  return ['', '', '', ''];\n};\nexport var getInitLoadBalancer = function getInitLoadBalancer(destinationRules) {\n  if (destinationRules.items.length === 1 && destinationRules.items[0].spec.trafficPolicy && destinationRules.items[0].spec.trafficPolicy.loadBalancer) {\n    return destinationRules.items[0].spec.trafficPolicy.loadBalancer;\n  }\n\n  return undefined;\n};\nexport var getInitPeerAuthentication = function getInitPeerAuthentication(destinationRules, peerAuthentications) {\n  var paMode;\n\n  if (destinationRules.items.length === 1 && destinationRules.items[0].metadata.annotations && destinationRules.items[0].metadata.annotations[KIALI_RELATED_LABEL]) {\n    var related = destinationRules.items[0].metadata.annotations[KIALI_RELATED_LABEL].split('/');\n\n    if (related.length > 1) {\n      var peerAuthn = peerAuthentications.find(function (value) {\n        return value.metadata.name === related[1];\n      });\n\n      if (peerAuthn) {\n        paMode = peerAuthn.spec.mtls.mode;\n      }\n    }\n  }\n\n  return paMode;\n};\nexport var getInitConnectionPool = function getInitConnectionPool(destinationRules) {\n  var _destinationRules$ite;\n\n  if (destinationRules.items.length === 1 && destinationRules.items[0].spec.trafficPolicy && ((_destinationRules$ite = destinationRules.items[0].spec.trafficPolicy) === null || _destinationRules$ite === void 0 ? void 0 : _destinationRules$ite.connectionPool)) {\n    var _destinationRules$ite2;\n\n    return (_destinationRules$ite2 = destinationRules.items[0].spec.trafficPolicy) === null || _destinationRules$ite2 === void 0 ? void 0 : _destinationRules$ite2.connectionPool;\n  }\n\n  return undefined;\n};\nexport var getInitOutlierDetection = function getInitOutlierDetection(destinationRules) {\n  var _destinationRules$ite3;\n\n  if (destinationRules.items.length === 1 && destinationRules.items[0].spec.trafficPolicy && ((_destinationRules$ite3 = destinationRules.items[0].spec.trafficPolicy) === null || _destinationRules$ite3 === void 0 ? void 0 : _destinationRules$ite3.outlierDetection)) {\n    var _destinationRules$ite4;\n\n    return (_destinationRules$ite4 = destinationRules.items[0].spec.trafficPolicy) === null || _destinationRules$ite4 === void 0 ? void 0 : _destinationRules$ite4.outlierDetection;\n  }\n\n  return undefined;\n};\nexport var hasGateway = function hasGateway(virtualServices) {\n  // We need to if sentence, otherwise a potential undefined is not well handled\n  if (virtualServices.items.length === 1 && virtualServices.items[0] && virtualServices.items[0].spec.gateways && virtualServices.items[0].spec.gateways.length > 0) {\n    return true;\n  }\n\n  return false;\n};\nexport var getInitHosts = function getInitHosts(virtualServices) {\n  if (virtualServices.items.length === 1 && virtualServices.items[0] && virtualServices.items[0].spec.hosts) {\n    return virtualServices.items[0].spec.hosts;\n  }\n\n  return [];\n}; // VirtualServices added from the Kiali Wizard only support to add a single gateway\n// and optionally a mesh gateway.\n// This method returns a gateway selected by the user and if mesh is present\n\nexport var getInitGateway = function getInitGateway(virtualServices) {\n  if (virtualServices.items.length === 1 && virtualServices.items[0] && virtualServices.items[0].spec.gateways && virtualServices.items[0].spec.gateways.length > 0) {\n    var selectedGateway = virtualServices.items[0].spec.gateways[0];\n\n    if (selectedGateway === 'mesh') {\n      // In Kiali Wizard, the first gateway is reserved for user gateway\n      selectedGateway = '';\n    }\n\n    var meshPresent = false;\n\n    if (virtualServices.items[0].spec.gateways.includes('mesh')) {\n      meshPresent = true;\n    }\n\n    return [selectedGateway, meshPresent];\n  }\n\n  return ['', false];\n};\nexport var buildAuthorizationPolicy = function buildAuthorizationPolicy(name, namespace, state) {\n  var ap = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'AuthorizationPolicy')\n    },\n    spec: {}\n  }; // DENY_ALL and ALLOW_ALL are two specific cases\n\n  if (state.policy === 'DENY_ALL') {\n    ap.spec.action = undefined;\n    ap.spec.selector = undefined;\n    ap.spec.rules = undefined;\n    return ap;\n  }\n\n  if (state.policy === 'ALLOW_ALL') {\n    ap.spec.action = ALLOW;\n    ap.spec.selector = undefined;\n    ap.spec.rules = [{}];\n    return ap;\n  } // RULES use case\n\n\n  if (state.workloadSelector.length > 0) {\n    var workloadSelector = {\n      matchLabels: {}\n    };\n    state.workloadSelector.split(',').forEach(function (label) {\n      label = label.trim();\n      var labelDetails = label.split('=');\n\n      if (labelDetails.length === 2) {\n        workloadSelector.matchLabels[labelDetails[0]] = labelDetails[1];\n      }\n    });\n    ap.spec.selector = workloadSelector;\n  }\n\n  if (state.rules.length > 0) {\n    ap.spec.rules = [];\n    state.rules.forEach(function (rule) {\n      var appRule = {\n        from: undefined,\n        to: undefined,\n        when: undefined\n      };\n\n      if (rule.from.length > 0) {\n        appRule.from = rule.from.map(function (fromItem) {\n          var source = {};\n          Object.keys(fromItem).forEach(function (key) {\n            source[key] = fromItem[key];\n          });\n          return {\n            source: source\n          };\n        });\n      }\n\n      if (rule.to.length > 0) {\n        appRule.to = rule.to.map(function (toItem) {\n          var operation = {};\n          Object.keys(toItem).forEach(function (key) {\n            operation[key] = toItem[key];\n          });\n          return {\n            operation: operation\n          };\n        });\n      }\n\n      if (rule.when.length > 0) {\n        appRule.when = rule.when.map(function (condition) {\n          var cond = {\n            key: condition.key\n          };\n\n          if (condition.values && condition.values.length > 0) {\n            cond.values = condition.values;\n          }\n\n          if (condition.notValues && condition.notValues.length > 0) {\n            cond.notValues = condition.notValues;\n          }\n\n          return cond;\n        });\n      }\n\n      ap.spec.rules.push(appRule);\n    });\n  }\n\n  if (state.action.length > 0) {\n    ap.spec.action = state.action;\n  }\n\n  return ap;\n};\nexport var buildGraphAuthorizationPolicy = function buildGraphAuthorizationPolicy(namespace, graph) {\n  var denyAll = {\n    metadata: {\n      name: 'deny-all-' + namespace,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'AuthorizationPolicy')\n    },\n    spec: {}\n  };\n  var aps = [denyAll];\n\n  if (graph.elements.nodes) {\n    for (var i = 0; i < graph.elements.nodes.length; i++) {\n      var node = graph.elements.nodes[i];\n\n      if (node.data.namespace === namespace && node.data.nodeType === NodeType.WORKLOAD && node.data.workload && node.data.app && node.data.version) {\n        var ap = {\n          metadata: {\n            name: node.data.workload,\n            namespace: namespace,\n            labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'AuthorizationPolicy')\n          },\n          spec: {\n            selector: {\n              matchLabels: {\n                app: node.data.app,\n                version: node.data.version\n              }\n            },\n            rules: [{\n              from: [{\n                source: {\n                  principals: []\n                }\n              }]\n            }]\n          }\n        };\n        var principalsLen = 0;\n\n        if (graph.elements.edges) {\n          for (var j = 0; j < graph.elements.edges.length; j++) {\n            var edge = graph.elements.edges[j];\n\n            if (node.data.id === edge.data.target) {\n              if (ap.spec.rules && ap.spec.rules[0] && ap.spec.rules[0].from && ap.spec.rules[0].from[0] && ap.spec.rules[0].from[0].source && ap.spec.rules[0].from[0].source.principals && edge.data.sourcePrincipal) {\n                var principal = edge.data.sourcePrincipal.startsWith('spiffe://') ? edge.data.sourcePrincipal.substring(9) : edge.data.sourcePrincipal;\n                ap.spec.rules[0].from[0].source.principals.push(principal);\n                principalsLen++;\n              }\n            }\n          }\n        }\n\n        if (principalsLen > 0) {\n          aps.push(ap);\n        }\n      }\n    }\n  }\n\n  return aps;\n};\nexport var buildGateway = function buildGateway(name, namespace, state) {\n  var gw = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'Gateway')\n    },\n    spec: {\n      // Default for istio scenarios, user may change it editing YAML\n      selector: {},\n      servers: state.gatewayServers.map(function (s) {\n        return {\n          port: s.port,\n          hosts: s.hosts,\n          tls: s.tls\n        };\n      })\n    }\n  };\n  state.workloadSelectorLabels.trim().split(',').forEach(function (split) {\n    var labels = split.trim().split('='); // It should be already validated with workloadSelectorValid, but just to add extra safe check\n\n    if (gw.spec.selector && labels.length === 2) {\n      gw.spec.selector[labels[0].trim()] = labels[1].trim();\n    }\n  });\n  return gw;\n};\nexport var buildPeerAuthentication = function buildPeerAuthentication(name, namespace, state) {\n  var pa = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'PeerAuthentication')\n    },\n    spec: {}\n  };\n\n  if (state.workloadSelector.length > 0) {\n    var workloadSelector = {\n      matchLabels: {}\n    };\n    state.workloadSelector.split(',').forEach(function (label) {\n      label = label.trim();\n      var labelDetails = label.split('=');\n\n      if (labelDetails.length === 2) {\n        workloadSelector.matchLabels[labelDetails[0]] = labelDetails[1];\n      }\n    });\n    pa.spec.selector = workloadSelector;\n  } // Kiali is always adding this field\n\n\n  pa.spec.mtls = {\n    mode: PeerAuthenticationMutualTLSMode[state.mtls]\n  };\n\n  if (state.portLevelMtls.length > 0) {\n    pa.spec.portLevelMtls = {};\n    state.portLevelMtls.forEach(function (p) {\n      if (pa.spec.portLevelMtls) {\n        pa.spec.portLevelMtls[Number(p.port)] = {\n          mode: PeerAuthenticationMutualTLSMode[p.mtls]\n        };\n      }\n    });\n  }\n\n  return pa;\n};\nexport var buildRequestAuthentication = function buildRequestAuthentication(name, namespace, state) {\n  var ra = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'RequestAuthentication')\n    },\n    spec: {\n      jwtRules: []\n    }\n  };\n\n  if (state.workloadSelector.length > 0) {\n    var workloadSelector = {\n      matchLabels: {}\n    };\n    state.workloadSelector.split(',').forEach(function (label) {\n      label = label.trim();\n      var labelDetails = label.split('=');\n\n      if (labelDetails.length === 2) {\n        workloadSelector.matchLabels[labelDetails[0]] = labelDetails[1];\n      }\n    });\n    ra.spec.selector = workloadSelector;\n  }\n\n  if (state.jwtRules.length > 0) {\n    ra.spec.jwtRules = state.jwtRules;\n  }\n\n  return ra;\n};\nexport var buildServiceEntry = function buildServiceEntry(name, namespace, state) {\n  var se = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'ServiceEntry')\n    },\n    spec: state.serviceEntry\n  };\n  return se;\n};\nexport var buildSidecar = function buildSidecar(name, namespace, state) {\n  var sc = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: _defineProperty({}, KIALI_WIZARD_LABEL, 'Sidecar')\n    },\n    spec: {\n      egress: [{\n        hosts: state.egressHosts.map(function (eh) {\n          return eh.host;\n        })\n      }]\n    }\n  };\n\n  if (state.addWorkloadSelector && state.workloadSelectorValid) {\n    sc.spec.workloadSelector = {\n      labels: {}\n    };\n    state.workloadSelectorLabels.trim().split(',').forEach(function (split) {\n      var labels = split.trim().split('='); // It should be already validated with workloadSelectorValid, but just to add extra safe check\n\n      if (sc.spec.workloadSelector && labels.length === 2) {\n        sc.spec.workloadSelector.labels[labels[0].trim()] = labels[1].trim();\n      }\n    });\n  }\n\n  return sc;\n};\nexport var buildNamespaceInjectionPatch = function buildNamespaceInjectionPatch(enable, remove, revision) {\n  var labels = {};\n\n  if (revision) {\n    labels[serverConfig.istioLabels.injectionLabelName] = null;\n    labels[serverConfig.istioLabels.injectionLabelRev] = revision;\n  } else {\n    labels[serverConfig.istioLabels.injectionLabelName] = remove ? null : enable ? 'enabled' : 'disabled';\n    labels[serverConfig.istioLabels.injectionLabelRev] = null;\n  }\n\n  var patch = {\n    metadata: {\n      labels: labels\n    }\n  };\n  return JSON.stringify(patch);\n};\nexport var buildWorkloadInjectionPatch = function buildWorkloadInjectionPatch(workloadType, enable, remove, statusState) {\n  var patch = {};\n\n  if (statusState.istioEnvironment.isMaistra) {\n    // Maistra only supports pod annotations\n    var annotations = {};\n    annotations[serverConfig.istioAnnotations.istioInjectionAnnotation] = remove ? null : enable ? 'true' : 'false';\n\n    if (workloadType === 'Pod') {\n      patch['annotations'] = annotations;\n    } else {\n      patch['spec'] = {\n        template: {\n          metadata: {\n            annotations: annotations\n          }\n        }\n      };\n    }\n  } else {\n    // supported non-Maistra environments prefer to use the pod label over the annotation\n    var labels = {};\n    labels[serverConfig.istioAnnotations.istioInjectionAnnotation] = remove ? null : enable ? 'true' : 'false';\n\n    if (workloadType === 'Pod') {\n      patch['labels'] = labels;\n    } else {\n      patch['spec'] = {\n        template: {\n          metadata: {\n            labels: labels\n          }\n        }\n      };\n    }\n  }\n\n  return JSON.stringify(patch);\n};","map":{"version":3,"sources":["/root/GraduateProject/src/components/IstioWizards/WizardActions.ts"],"names":["PeerAuthenticationMutualTLSMode","serverConfig","ConsistentHashType","MUTUAL","UNSET","ALLOW","NodeType","WIZARD_TRAFFIC_SHIFTING","WIZARD_TCP_TRAFFIC_SHIFTING","WIZARD_REQUEST_ROUTING","WIZARD_FAULT_INJECTION","WIZARD_REQUEST_TIMEOUTS","WIZARD_ENABLE_AUTO_INJECTION","WIZARD_DISABLE_AUTO_INJECTION","WIZARD_REMOVE_AUTO_INJECTION","SERVICE_WIZARD_ACTIONS","WIZARD_TITLES","KIALI_WIZARD_LABEL","KIALI_RELATED_LABEL","fqdnServiceName","serviceName","namespace","istioIdentityDomain","buildHTTPMatchRequest","matches","matchRequests","matchHeaders","headers","filter","match","startsWith","forEach","i0","indexOf","j0","headerName","substring","trim","i1","j1","op","value","Object","keys","length","push","i","j","name","parseStringMatch","exact","prefix","regex","parseHttpMatchRequest","httpMatchRequest","uri","scheme","method","authority","getGatewayName","gatewayNames","gatewayName","goodName","includes","charAt","version","substr","buildIstioConfig","wProps","wState","wkdNameVersion","drName","destinationRules","items","metadata","wizardDR","labels","type","spec","host","subsets","workloads","workload","versionLabelName","istioLabels","map","versionValue","vsName","virtualServices","wizardVS","wizardPA","undefined","fullNewGatewayName","gateways","wizardGW","gateway","addGateway","newGateway","selector","istio","servers","port","number","protocol","hosts","gwHosts","split","http","route","mirrored","httpRouteDestination","destination","weight","subset","mirrorWorkload","pop","mirror","mirrorPercentage","tcp","routeDestination","rules","rule","httpRoute","workloadWeights","destW","delay","abort","fault","timeout","retries","faultInjectionRoute","delayed","aborted","timeoutRetryRoute","isTimeout","isRetry","console","log","vsHosts","trafficPolicy","tlsModified","mtlsMode","tls","mode","clientCertificate","privateKey","caCertificates","peerAuthnSelector","addPeerAuthentication","peerAuthnLabels","appLabelName","matchLabels","mtls","annotations","addLoadBalancer","simpleLB","loadBalancer","simple","consistentHash","httpHeaderName","httpCookie","useSourceIp","consistentHashType","HTTP_HEADER_NAME","HTTP_COOKIE","USE_SOURCE_IP","addConnectionPool","connectionPool","addOutlierDetection","outlierDetection","selectedGateway","addMesh","getWorkloadsByVersion","wkdVersionName","dr","ss","getDefaultWeights","wkTraffic","Math","floor","remainTraffic","wkWeights","locked","maxWeight","getInitWeights","wkdWeights","wkd","newWkd","wkdWeight","getInitRules","m","concat","r","getInitFaultInjectionRoute","initWeights","fiRoute","percentage","fixedDelay","isValidDelay","httpStatus","isValidAbort","getInitTimeoutRetryRoute","trRoute","isValidTimeout","attempts","perTryTimeout","retryOn","isValidRetry","getInitTlsMode","getInitLoadBalancer","getInitPeerAuthentication","peerAuthentications","paMode","related","peerAuthn","find","getInitConnectionPool","getInitOutlierDetection","hasGateway","getInitHosts","getInitGateway","meshPresent","buildAuthorizationPolicy","state","ap","policy","action","workloadSelector","label","labelDetails","appRule","from","to","when","fromItem","source","key","toItem","operation","condition","cond","values","notValues","buildGraphAuthorizationPolicy","graph","denyAll","aps","elements","nodes","node","data","nodeType","WORKLOAD","app","principals","principalsLen","edges","edge","id","target","sourcePrincipal","principal","buildGateway","gw","gatewayServers","s","workloadSelectorLabels","buildPeerAuthentication","pa","portLevelMtls","p","Number","buildRequestAuthentication","ra","jwtRules","buildServiceEntry","se","serviceEntry","buildSidecar","sc","egress","egressHosts","eh","addWorkloadSelector","workloadSelectorValid","buildNamespaceInjectionPatch","enable","remove","revision","injectionLabelName","injectionLabelRev","patch","JSON","stringify","buildWorkloadInjectionPatch","workloadType","statusState","istioEnvironment","isMaistra","istioAnnotations","istioInjectionAnnotation","template"],"mappings":"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","sourcesContent":["import { StatusState } from '../../types/StatusState';\nimport { TLSStatus } from '../../types/TLSStatus';\nimport { WorkloadOverview } from '../../types/ServiceInfo';\nimport { WorkloadWeight } from './TrafficShifting';\nimport { Rule } from './RequestRouting/Rules';\nimport {\n  AuthorizationPolicy,\n  AuthorizationPolicyRule,\n  AuthorizationPolicyWorkloadSelector,\n  Condition,\n  ConnectionPoolSettings,\n  DestinationRule,\n  DestinationRules,\n  Gateway,\n  HTTPMatchRequest,\n  HTTPRoute,\n  HTTPRouteDestination,\n  LoadBalancerSettings,\n  Operation,\n  OutlierDetection,\n  PeerAuthentication,\n  PeerAuthenticationMutualTLSMode,\n  PeerAuthenticationWorkloadSelector,\n  RequestAuthentication,\n  RouteDestination,\n  ServiceEntry,\n  Sidecar,\n  Source,\n  StringMatch,\n  TCPRoute,\n  TLSRoute,\n  VirtualService,\n  VirtualServices,\n  WorkloadMatchSelector\n} from '../../types/IstioObjects';\nimport { serverConfig } from '../../config';\nimport { GatewaySelectorState } from './GatewaySelector';\nimport { ConsistentHashType, MUTUAL, TrafficPolicyState, UNSET } from './TrafficPolicy';\nimport { GatewayState } from '../../pages/IstioConfigNew/GatewayForm';\nimport { SidecarState } from '../../pages/IstioConfigNew/SidecarForm';\nimport { ALLOW, AuthorizationPolicyState } from '../../pages/IstioConfigNew/AuthorizationPolicyForm';\nimport { PeerAuthenticationState } from '../../pages/IstioConfigNew/PeerAuthenticationForm';\nimport { RequestAuthenticationState } from '../../pages/IstioConfigNew/RequestAuthenticationForm';\nimport { Workload } from '../../types/Workload';\nimport { FaultInjectionRoute } from './FaultInjection';\nimport { TimeoutRetryRoute } from './RequestTimeouts';\nimport { GraphDefinition, NodeType } from '../../types/Graph';\nimport { ServiceEntryState } from '../../pages/IstioConfigNew/ServiceEntryForm';\n\nexport const WIZARD_TRAFFIC_SHIFTING = 'traffic_shifting';\nexport const WIZARD_TCP_TRAFFIC_SHIFTING = 'tcp_traffic_shifting';\nexport const WIZARD_REQUEST_ROUTING = 'request_routing';\nexport const WIZARD_FAULT_INJECTION = 'fault_injection';\nexport const WIZARD_REQUEST_TIMEOUTS = 'request_timeouts';\n\nexport const WIZARD_ENABLE_AUTO_INJECTION = 'enable_auto_injection';\nexport const WIZARD_DISABLE_AUTO_INJECTION = 'disable_auto_injection';\nexport const WIZARD_REMOVE_AUTO_INJECTION = 'remove_auto_injection';\n\nexport const SERVICE_WIZARD_ACTIONS = [\n  WIZARD_REQUEST_ROUTING,\n  WIZARD_FAULT_INJECTION,\n  WIZARD_TRAFFIC_SHIFTING,\n  WIZARD_TCP_TRAFFIC_SHIFTING,\n  WIZARD_REQUEST_TIMEOUTS\n];\n\nexport const WIZARD_TITLES = {\n  [WIZARD_REQUEST_ROUTING]: 'Request Routing',\n  [WIZARD_FAULT_INJECTION]: 'Fault Injection',\n  [WIZARD_TRAFFIC_SHIFTING]: 'Traffic Shifting',\n  [WIZARD_TCP_TRAFFIC_SHIFTING]: 'TCP Traffic Shifting',\n  [WIZARD_REQUEST_TIMEOUTS]: 'Request Timeouts'\n};\n\nexport type ServiceWizardProps = {\n  show: boolean;\n  type: string;\n  update: boolean;\n  namespace: string;\n  serviceName: string;\n  tlsStatus?: TLSStatus;\n  workloads: WorkloadOverview[];\n  virtualServices: VirtualServices;\n  destinationRules: DestinationRules;\n  gateways: string[];\n  peerAuthentications: PeerAuthentication[];\n  onClose: (changed: boolean) => void;\n};\n\nexport type ServiceWizardValid = {\n  mainWizard: boolean;\n  vsHosts: boolean;\n  tls: boolean;\n  lb: boolean;\n  gateway: boolean;\n  cp: boolean;\n  od: boolean;\n};\n\nexport type ServiceWizardState = {\n  showWizard: boolean;\n  showAdvanced: boolean;\n  advancedTabKey: number;\n  workloads: WorkloadWeight[];\n  rules: Rule[];\n  faultInjectionRoute: FaultInjectionRoute;\n  timeoutRetryRoute: TimeoutRetryRoute;\n  valid: ServiceWizardValid;\n  advancedOptionsValid: boolean;\n  vsHosts: string[];\n  trafficPolicy: TrafficPolicyState;\n  gateway?: GatewaySelectorState;\n};\n\nexport type WorkloadWizardValid = {};\n\nexport type WorkloadWizardProps = {\n  show: boolean;\n  type: string;\n  namespace: string;\n  workload: Workload;\n  onClose: (changed: boolean) => void;\n};\n\nexport type WorkloadWizardState = {\n  showWizard: boolean;\n  valid: WorkloadWizardValid;\n};\n\nexport const KIALI_WIZARD_LABEL = 'kiali_wizard';\nexport const KIALI_RELATED_LABEL = 'kiali_wizard_related';\n\nexport const fqdnServiceName = (serviceName: string, namespace: string): string => {\n  return serviceName + '.' + namespace + '.' + serverConfig.istioIdentityDomain;\n};\n\nconst buildHTTPMatchRequest = (matches: string[]): HTTPMatchRequest[] => {\n  const matchRequests: HTTPMatchRequest[] = [];\n  const matchHeaders: HTTPMatchRequest = { headers: {} };\n  // Headers are grouped\n  matches\n    .filter(match => match.startsWith('headers'))\n    .forEach(match => {\n      // match follows format:  headers [<header-name>] <op> <value>\n      const i0 = match.indexOf('[');\n      const j0 = match.indexOf(']');\n      const headerName = match.substring(i0 + 1, j0).trim();\n      const i1 = match.indexOf(' ', j0 + 1);\n      const j1 = match.indexOf(' ', i1 + 1);\n      const op = match.substring(i1 + 1, j1).trim();\n      const value = match.substring(j1 + 1).trim();\n      matchHeaders.headers![headerName] = { [op]: value };\n    });\n  if (Object.keys(matchHeaders.headers || {}).length > 0) {\n    matchRequests.push(matchHeaders);\n  }\n  // Rest of matches\n  matches\n    .filter(match => !match.startsWith('headers'))\n    .forEach(match => {\n      // match follows format: <name> <op> <value>\n      const i = match.indexOf(' ');\n      const j = match.indexOf(' ', i + 1);\n      const name = match.substring(0, i).trim();\n      const op = match.substring(i + 1, j).trim();\n      const value = match.substring(j + 1).trim();\n      matchRequests.push({\n        [name]: {\n          [op]: value\n        }\n      });\n    });\n  return matchRequests;\n};\n\nconst parseStringMatch = (value: StringMatch): string => {\n  if (value.exact) {\n    return 'exact ' + value.exact;\n  }\n  if (value.prefix) {\n    return 'prefix ' + value.prefix;\n  }\n  if (value.regex) {\n    return 'regex ' + value.regex;\n  }\n  return '';\n};\n\nconst parseHttpMatchRequest = (httpMatchRequest: HTTPMatchRequest): string[] => {\n  const matches: string[] = [];\n  // Headers\n  if (httpMatchRequest.headers) {\n    Object.keys(httpMatchRequest.headers).forEach(headerName => {\n      const value = httpMatchRequest.headers![headerName];\n      matches.push('headers [' + headerName + '] ' + parseStringMatch(value));\n    });\n  }\n  if (httpMatchRequest.uri) {\n    matches.push('uri ' + parseStringMatch(httpMatchRequest.uri));\n  }\n  if (httpMatchRequest.scheme) {\n    matches.push('scheme ' + parseStringMatch(httpMatchRequest.scheme));\n  }\n  if (httpMatchRequest.method) {\n    matches.push('method ' + parseStringMatch(httpMatchRequest.method));\n  }\n  if (httpMatchRequest.authority) {\n    matches.push('authority ' + parseStringMatch(httpMatchRequest.authority));\n  }\n  return matches;\n};\n\nexport const getGatewayName = (namespace: string, serviceName: string, gatewayNames: string[]): string => {\n  let gatewayName = namespace + '/' + serviceName + '-gateway';\n  if (gatewayNames.length === 0) {\n    return gatewayName;\n  }\n  let goodName = false;\n  while (!goodName) {\n    if (!gatewayNames.includes(gatewayName)) {\n      goodName = true;\n    } else {\n      // Iterate until we find a good gatewayName\n      if (gatewayName.charAt(gatewayName.length - 2) === '-') {\n        let version = +gatewayName.charAt(gatewayName.length - 1);\n        version = version + 1;\n        gatewayName = gatewayName.substr(0, gatewayName.length - 1) + version;\n      } else {\n        gatewayName = gatewayName + '-1';\n      }\n    }\n  }\n  return gatewayName;\n};\n\nexport const buildIstioConfig = (\n  wProps: ServiceWizardProps,\n  wState: ServiceWizardState\n): [DestinationRule, VirtualService, Gateway?, PeerAuthentication?] => {\n  const wkdNameVersion: { [key: string]: string } = {};\n\n  // DestinationRule from the labels\n  let drName = wProps.serviceName;\n  // In some limited scenarios DR may be created externally to Kiali (i.e. extensions)\n  if (wProps.destinationRules.items.length === 1 && wProps.destinationRules.items[0].metadata.name !== drName) {\n    drName = wProps.destinationRules.items[0].metadata.name;\n  }\n  const wizardDR: DestinationRule = {\n    metadata: {\n      namespace: wProps.namespace,\n      name: drName,\n      labels: {\n        [KIALI_WIZARD_LABEL]: wProps.type\n      }\n    },\n    spec: {\n      host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n    }\n  };\n\n  const subsets = wProps.workloads\n    .filter(workload => {\n      // Filter out workloads without version label\n      const versionLabelName = serverConfig.istioLabels.versionLabelName;\n      return workload.labels![versionLabelName];\n    })\n    .map(workload => {\n      // Using version\n      const versionLabelName = serverConfig.istioLabels.versionLabelName;\n      const versionValue = workload.labels![versionLabelName];\n      const labels: { [key: string]: string } = {};\n      labels[versionLabelName] = versionValue;\n      // Populate helper table workloadName -> version\n      wkdNameVersion[workload.name] = versionValue;\n      return {\n        name: versionValue,\n        labels: labels\n      };\n    });\n\n  if (subsets.length > 0) {\n    wizardDR.spec.subsets = subsets;\n  }\n\n  // In some limited scenarios VS may be created externally to Kiali (i.e. extensions)\n  let vsName = wProps.serviceName;\n  if (wProps.virtualServices.items.length === 1 && wProps.virtualServices.items[0].metadata.name !== vsName) {\n    vsName = wProps.virtualServices.items[0].metadata.name;\n  }\n  const wizardVS: VirtualService = {\n    metadata: {\n      namespace: wProps.namespace,\n      name: vsName,\n      labels: {\n        [KIALI_WIZARD_LABEL]: wProps.type\n      }\n    },\n    spec: {}\n  };\n\n  let wizardPA: PeerAuthentication | undefined = undefined;\n\n  // Wizard is optional, only when user has explicitly selected \"Create a Gateway\"\n  const fullNewGatewayName = getGatewayName(wProps.namespace, wProps.serviceName, wProps.gateways);\n  const wizardGW: Gateway | undefined =\n    wState.gateway && wState.gateway.addGateway && wState.gateway.newGateway\n      ? {\n          metadata: {\n            namespace: wProps.namespace,\n            name: fullNewGatewayName.substr(wProps.namespace.length + 1),\n            labels: {\n              [KIALI_WIZARD_LABEL]: wProps.type\n            }\n          },\n          spec: {\n            selector: {\n              istio: 'ingressgateway'\n            },\n            servers: [\n              {\n                port: {\n                  number: wState.gateway.port,\n                  name: 'http',\n                  protocol: 'HTTP'\n                },\n                hosts: wState.gateway.gwHosts.split(',')\n              }\n            ]\n          }\n        }\n      : undefined;\n\n  switch (wProps.type) {\n    case WIZARD_TRAFFIC_SHIFTING: {\n      // VirtualService from the weights\n      wizardVS.spec = {\n        http: [\n          {\n            route: wState.workloads\n              .filter(workload => !workload.mirrored)\n              .map(workload => {\n                const httpRouteDestination: HTTPRouteDestination = {\n                  destination: {\n                    host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                  },\n                  weight: workload.weight\n                };\n                if (wkdNameVersion[workload.name]) {\n                  httpRouteDestination.destination.subset = wkdNameVersion[workload.name];\n                }\n                return httpRouteDestination;\n              })\n          }\n        ]\n      };\n      // Update HTTP Route with mirror destination + percentage\n      const mirrorWorkload = wState.workloads.filter(workload => workload.mirrored).pop();\n      if (mirrorWorkload && wizardVS?.spec?.http?.length === 1) {\n        wizardVS.spec.http[0].mirror = {\n          host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n        };\n        if (wkdNameVersion[mirrorWorkload.name]) {\n          wizardVS.spec.http[0].mirror.subset = wkdNameVersion[mirrorWorkload.name];\n        }\n        wizardVS.spec.http[0].mirrorPercentage = {\n          value: mirrorWorkload.weight\n        };\n      }\n      break;\n    }\n    case WIZARD_TCP_TRAFFIC_SHIFTING: {\n      // VirtualService from the weights\n      wizardVS.spec = {\n        tcp: [\n          {\n            route: wState.workloads.map(workload => {\n              const routeDestination: RouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n              if (wkdNameVersion[workload.name]) {\n                routeDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n              return routeDestination;\n            })\n          }\n        ]\n      };\n      break;\n    }\n    case WIZARD_REQUEST_ROUTING: {\n      // VirtualService from the routes\n      wizardVS.spec = {\n        http: wState.rules.map(rule => {\n          const httpRoute: HTTPRoute = {};\n          httpRoute.route = [];\n          rule.workloadWeights\n            .filter(workload => !workload.mirrored)\n            .forEach(workload => {\n              const destW: HTTPRouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n              if (wkdNameVersion[workload.name]) {\n                destW.destination.subset = wkdNameVersion[workload.name];\n              }\n              httpRoute.route?.push(destW);\n            });\n\n          const mirrorWorkload = rule.workloadWeights.filter(workload => workload.mirrored).pop();\n          if (mirrorWorkload) {\n            httpRoute.mirror = {\n              host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n            };\n            if (wkdNameVersion[mirrorWorkload.name]) {\n              httpRoute.mirror.subset = wkdNameVersion[mirrorWorkload.name];\n            }\n            httpRoute.mirrorPercentage = {\n              value: mirrorWorkload.weight\n            };\n          }\n\n          if (rule.matches.length > 0) {\n            httpRoute.match = buildHTTPMatchRequest(rule.matches);\n          }\n\n          if (rule.delay || rule.abort) {\n            httpRoute.fault = {};\n            if (rule.delay) {\n              httpRoute.fault.delay = rule.delay;\n            }\n            if (rule.abort) {\n              httpRoute.fault.abort = rule.abort;\n            }\n          }\n          if (rule.timeout) {\n            httpRoute.timeout = rule.timeout;\n          }\n          if (rule.retries) {\n            httpRoute.retries = rule.retries;\n          }\n          return httpRoute;\n        })\n      };\n      break;\n    }\n    case WIZARD_FAULT_INJECTION: {\n      // VirtualService from the weights mapped in the FaultInjectionRoute\n      wizardVS.spec = {\n        http: [\n          {\n            route: wState.faultInjectionRoute.workloads.map(workload => {\n              const httpRouteDestination: HTTPRouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace)\n                },\n                weight: workload.weight\n              };\n              if (wkdNameVersion[workload.name]) {\n                httpRouteDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n              return httpRouteDestination;\n            })\n          }\n        ]\n      };\n      if (wizardVS.spec.http && wizardVS.spec.http[0]) {\n        if (wState.faultInjectionRoute.delayed || wState.faultInjectionRoute.aborted) {\n          wizardVS.spec.http[0].fault = {};\n          if (wState.faultInjectionRoute.delayed) {\n            wizardVS.spec.http[0].fault.delay = wState.faultInjectionRoute.delay;\n          }\n          if (wState.faultInjectionRoute.aborted) {\n            wizardVS.spec.http[0].fault.abort = wState.faultInjectionRoute.abort;\n          }\n        }\n      }\n      break;\n    }\n    case WIZARD_REQUEST_TIMEOUTS: {\n      // VirtualService from the weights mapped in the TimeoutRetryRoute\n      wizardVS.spec = {\n        http: [\n          {\n            route: wState.timeoutRetryRoute.workloads.map(workload => {\n              const httpRouteDestination: HTTPRouteDestination = {\n                destination: {\n                  host: fqdnServiceName(wProps.serviceName, wProps.namespace),\n                  subset: wkdNameVersion[workload.name]\n                },\n                weight: workload.weight\n              };\n              if (wkdNameVersion[workload.name]) {\n                httpRouteDestination.destination.subset = wkdNameVersion[workload.name];\n              }\n              return httpRouteDestination;\n            })\n          }\n        ]\n      };\n      if (wizardVS.spec.http && wizardVS.spec.http[0]) {\n        if (wState.timeoutRetryRoute.isTimeout) {\n          wizardVS.spec.http[0].timeout = wState.timeoutRetryRoute.timeout;\n        }\n        if (wState.timeoutRetryRoute.isRetry) {\n          wizardVS.spec.http[0].retries = wState.timeoutRetryRoute.retries;\n        }\n      }\n      break;\n    }\n    default:\n      console.log('Unrecognized type');\n  }\n\n  wizardVS.spec.hosts =\n    wState.vsHosts.length > 1 || (wState.vsHosts.length === 1 && wState.vsHosts[0].length > 0)\n      ? wState.vsHosts\n      : [wProps.serviceName];\n\n  if (wState.trafficPolicy.tlsModified && wState.trafficPolicy.mtlsMode !== UNSET) {\n    wizardDR.spec.trafficPolicy = {};\n    wizardDR.spec.trafficPolicy.tls = {\n      mode: wState.trafficPolicy.mtlsMode,\n      clientCertificate: null,\n      privateKey: null,\n      caCertificates: null\n    };\n    if (wState.trafficPolicy.mtlsMode === MUTUAL) {\n      wizardDR.spec.trafficPolicy.tls.clientCertificate = wState.trafficPolicy.clientCertificate;\n      wizardDR.spec.trafficPolicy.tls.privateKey = wState.trafficPolicy.privateKey;\n      wizardDR.spec.trafficPolicy.tls.caCertificates = wState.trafficPolicy.caCertificates;\n    }\n  }\n\n  if (wState.trafficPolicy.peerAuthnSelector.addPeerAuthentication) {\n    const peerAuthnLabels: { [key: string]: string } = {};\n    peerAuthnLabels[serverConfig.istioLabels.appLabelName] = wProps.workloads[0].labels![\n      serverConfig.istioLabels.appLabelName\n    ];\n\n    wizardPA = {\n      metadata: {\n        namespace: wProps.namespace,\n        name: wProps.serviceName,\n        labels: {\n          [KIALI_WIZARD_LABEL]: wProps.type\n        }\n      },\n      spec: {\n        selector: {\n          matchLabels: peerAuthnLabels\n        },\n        mtls: {\n          mode: wState.trafficPolicy.peerAuthnSelector.mode\n        }\n      }\n    };\n\n    wizardDR.metadata.annotations = {};\n    wizardDR.metadata.annotations[KIALI_RELATED_LABEL] = 'PeerAuthentication/' + wProps.serviceName;\n  }\n\n  if (wState.trafficPolicy.addLoadBalancer) {\n    if (!wizardDR.spec.trafficPolicy) {\n      wizardDR.spec.trafficPolicy = {};\n    }\n\n    if (wState.trafficPolicy.simpleLB) {\n      // Remember to put a null fields that need to be deleted on a JSON merge patch\n      wizardDR.spec.trafficPolicy.loadBalancer = {\n        simple: wState.trafficPolicy.loadBalancer.simple,\n        consistentHash: null\n      };\n    } else {\n      wizardDR.spec.trafficPolicy.loadBalancer = {\n        simple: null,\n        consistentHash: {}\n      };\n      wizardDR.spec.trafficPolicy.loadBalancer.consistentHash = {\n        httpHeaderName: null,\n        httpCookie: null,\n        useSourceIp: null\n      };\n      if (wState.trafficPolicy.loadBalancer.consistentHash) {\n        const consistentHash = wState.trafficPolicy.loadBalancer.consistentHash;\n        switch (wState.trafficPolicy.consistentHashType) {\n          case ConsistentHashType.HTTP_HEADER_NAME:\n            wizardDR.spec.trafficPolicy.loadBalancer.consistentHash.httpHeaderName = consistentHash.httpHeaderName;\n            break;\n          case ConsistentHashType.HTTP_COOKIE:\n            wizardDR.spec.trafficPolicy.loadBalancer.consistentHash.httpCookie = consistentHash.httpCookie;\n            break;\n          case ConsistentHashType.USE_SOURCE_IP:\n            wizardDR.spec.trafficPolicy.loadBalancer.consistentHash.useSourceIp = true;\n            break;\n          default:\n          /// No default action\n        }\n      }\n    }\n  }\n\n  if (wState.trafficPolicy.addConnectionPool) {\n    if (!wizardDR.spec.trafficPolicy) {\n      wizardDR.spec.trafficPolicy = {};\n    }\n    wizardDR.spec.trafficPolicy.connectionPool = wState.trafficPolicy.connectionPool;\n  }\n\n  if (wState.trafficPolicy.addOutlierDetection) {\n    if (!wizardDR.spec.trafficPolicy) {\n      wizardDR.spec.trafficPolicy = {};\n    }\n    wizardDR.spec.trafficPolicy.outlierDetection = wState.trafficPolicy.outlierDetection;\n  }\n\n  // If traffic policy has empty objects, it will be invalidated because galleys expects at least one non-empty field.\n  if (!wizardDR.spec.trafficPolicy) {\n    wizardDR.spec.trafficPolicy = null;\n  }\n\n  // If there isn't any PeerAuthn created/updated, remove the DR annotation\n  if (!wizardPA) {\n    // @ts-ignore\n    wizardDR.metadata.annotations = null;\n  }\n\n  if (wState.gateway && wState.gateway.addGateway) {\n    wizardVS.spec.gateways = [];\n    if (wState.gateway.newGateway) {\n      wizardVS.spec.gateways.push(fullNewGatewayName);\n    } else if (wState.gateway.selectedGateway.length > 0) {\n      wizardVS.spec.gateways.push(wState.gateway.selectedGateway);\n    }\n    if (wState.gateway.addMesh && !wizardVS.spec.gateways.includes('mesh')) {\n      wizardVS.spec.gateways.push('mesh');\n    }\n    // Don't leave empty gateways\n    if (wizardVS.spec.gateways.length === 0) {\n      wizardVS.spec.gateways = null;\n    }\n  } else {\n    wizardVS.spec.gateways = null;\n  }\n  return [wizardDR, wizardVS, wizardGW, wizardPA];\n};\n\nconst getWorkloadsByVersion = (\n  workloads: WorkloadOverview[],\n  destinationRules: DestinationRules\n): { [key: string]: string } => {\n  const versionLabelName = serverConfig.istioLabels.versionLabelName;\n  const wkdVersionName: { [key: string]: string } = {};\n  workloads.forEach(workload => (wkdVersionName[workload.labels![versionLabelName]] = workload.name));\n  if (destinationRules.items.length > 0) {\n    destinationRules.items.forEach(dr => {\n      dr.spec.subsets?.forEach(ss => {\n        const version = ss.labels![versionLabelName];\n        wkdVersionName[ss.name] = wkdVersionName[version];\n      });\n    });\n  }\n  return wkdVersionName;\n};\n\nexport const getDefaultWeights = (workloads: WorkloadOverview[]): WorkloadWeight[] => {\n  const wkTraffic = workloads.length < 100 ? Math.floor(100 / workloads.length) : 0;\n  const remainTraffic = workloads.length < 100 ? 100 % workloads.length : 0;\n  const wkWeights: WorkloadWeight[] = workloads.map(workload => ({\n    name: workload.name,\n    weight: wkTraffic,\n    locked: false,\n    maxWeight: 100,\n    mirrored: false\n  }));\n  if (remainTraffic > 0) {\n    wkWeights[wkWeights.length - 1].weight = wkWeights[wkWeights.length - 1].weight + remainTraffic;\n  }\n  return wkWeights;\n};\n\nexport const getInitWeights = (\n  workloads: WorkloadOverview[],\n  virtualServices: VirtualServices,\n  destinationRules: DestinationRules\n): WorkloadWeight[] => {\n  const wkdVersionName = getWorkloadsByVersion(workloads, destinationRules);\n  const wkdWeights: WorkloadWeight[] = [];\n  if (virtualServices.items.length === 1) {\n    let route: HTTPRoute | TCPRoute | TLSRoute | undefined;\n    if (virtualServices.items[0].spec.http && virtualServices.items[0].spec.http!.length === 1) {\n      route = virtualServices.items[0].spec.http![0];\n    }\n    if (virtualServices.items[0].spec.tcp && virtualServices.items[0].spec.tcp!.length === 1) {\n      route = virtualServices.items[0].spec.tcp![0];\n    }\n    if (route) {\n      // Populate WorkloadWeights from a VirtualService\n      route.route?.forEach(route => {\n        if (route.destination.subset && wkdVersionName[route.destination.subset]) {\n          wkdWeights.push({\n            name: wkdVersionName[route.destination.subset],\n            weight: route.weight || 0,\n            locked: false,\n            maxWeight: 100,\n            mirrored: false\n          });\n        }\n      });\n\n      // Convention: we place the mirror routes as last position\n      if ((route as HTTPRoute).mirror) {\n        const httpRoute = route as HTTPRoute;\n        // Check mirror on HTTP Route\n        if (httpRoute.mirror && httpRoute.mirror.subset && wkdVersionName[httpRoute.mirror.subset]) {\n          const mirrorPercentage = httpRoute.mirrorPercentage ? httpRoute.mirrorPercentage.value : 100;\n          wkdWeights.push({\n            name: wkdVersionName[httpRoute.mirror.subset],\n            weight: mirrorPercentage,\n            locked: false,\n            maxWeight: 100,\n            mirrored: true\n          });\n        }\n      }\n    }\n  }\n  // Add new workloads with 0 weight if there is missing workloads\n  if (wkdWeights.length > 0 && workloads.length !== wkdWeights.length) {\n    for (let i = 0; i < workloads.length; i++) {\n      const wkd = workloads[i];\n      let newWkd = true;\n      for (let j = 0; j < wkdWeights.length; j++) {\n        const wkdWeight = wkdWeights[j];\n        if (wkd.name === wkdWeight.name) {\n          newWkd = false;\n          break;\n        }\n      }\n      if (newWkd) {\n        wkdWeights.push({\n          name: wkd.name,\n          weight: 0,\n          locked: false,\n          maxWeight: 100,\n          mirrored: false\n        });\n      }\n    }\n  }\n  return wkdWeights;\n};\n\nexport const getInitRules = (\n  workloads: WorkloadOverview[],\n  virtualServices: VirtualServices,\n  destinationRules: DestinationRules\n): Rule[] => {\n  const wkdVersionName = getWorkloadsByVersion(workloads, destinationRules);\n  const rules: Rule[] = [];\n  if (virtualServices.items.length === 1) {\n    virtualServices.items[0].spec.http!.forEach(httpRoute => {\n      const rule: Rule = {\n        matches: [],\n        workloadWeights: []\n      };\n      if (httpRoute.match) {\n        httpRoute.match.forEach(m => (rule.matches = rule.matches.concat(parseHttpMatchRequest(m))));\n      }\n      if (httpRoute.route) {\n        httpRoute.route.forEach(r => {\n          const subset = r.destination.subset;\n          const workload = wkdVersionName[subset || ''];\n          // Not adding a route if a workload is not found with a destination subset\n          // That means that a workload has been deleted after a VS/DR has been generated\n          if (workload) {\n            rule.workloadWeights.push({\n              name: workload,\n              weight: r.weight ? r.weight : 0,\n              locked: false,\n              maxWeight: 100,\n              mirrored: false\n            });\n          }\n        });\n      }\n\n      if (httpRoute.mirror) {\n        const subset = httpRoute.mirror.subset;\n        const workload = wkdVersionName[subset || ''];\n        rule.workloadWeights.push({\n          name: workload,\n          weight: httpRoute.mirrorPercentage ? httpRoute.mirrorPercentage.value : 100,\n          locked: false,\n          maxWeight: 100,\n          mirrored: true\n        });\n      }\n\n      if (httpRoute.fault) {\n        if (httpRoute.fault.delay) {\n          rule.delay = httpRoute.fault.delay;\n        }\n        if (httpRoute.fault.abort) {\n          rule.abort = httpRoute.fault.abort;\n        }\n      }\n      if (httpRoute.timeout) {\n        rule.timeout = httpRoute.timeout;\n      }\n      if (httpRoute.retries) {\n        rule.retries = httpRoute.retries;\n      }\n      // Not adding a rule if it has empty routes, probably this means that an existing workload was removed\n      if (rule.workloadWeights.length > 0) {\n        rules.push(rule);\n      }\n    });\n  }\n  return rules;\n};\n\nexport const getInitFaultInjectionRoute = (\n  workloads: WorkloadOverview[],\n  virtualServices: VirtualServices,\n  destinationRules: DestinationRules\n): FaultInjectionRoute => {\n  // Read potential predefined weights\n  let initWeights = getInitWeights(workloads, virtualServices, destinationRules);\n  if (workloads.length > 0 && initWeights.length === 0) {\n    initWeights = getDefaultWeights(workloads);\n  }\n  const fiRoute = {\n    workloads: initWeights,\n    delayed: false,\n    delay: {\n      percentage: {\n        value: 100\n      },\n      fixedDelay: '5s'\n    },\n    isValidDelay: true,\n    aborted: false,\n    abort: {\n      percentage: {\n        value: 100\n      },\n      httpStatus: 503\n    },\n    isValidAbort: true\n  };\n  // This use case is intended for VS with single HTTP Route, others scenarios should use the Request Routing Wizard\n  if (\n    virtualServices.items.length === 1 &&\n    virtualServices.items[0].spec.http &&\n    virtualServices.items[0].spec.http.length === 1 &&\n    virtualServices.items[0].spec.http[0].fault\n  ) {\n    const fault = virtualServices.items[0].spec.http[0].fault;\n    if (fault.delay) {\n      fiRoute.delayed = true;\n      fiRoute.delay.percentage.value = fault.delay.percentage ? fault.delay.percentage.value : 100;\n      fiRoute.delay.fixedDelay = fault.delay.fixedDelay;\n    }\n    if (fault.abort) {\n      fiRoute.aborted = true;\n      fiRoute.abort.percentage.value = fault.abort.percentage ? fault.abort.percentage.value : 100;\n      fiRoute.abort.httpStatus = fault.abort.httpStatus;\n    }\n  }\n  return fiRoute;\n};\n\nexport const getInitTimeoutRetryRoute = (\n  workloads: WorkloadOverview[],\n  virtualServices: VirtualServices,\n  destinationRules: DestinationRules\n): TimeoutRetryRoute => {\n  // Read potential predefined weights\n  let initWeights = getInitWeights(workloads, virtualServices, destinationRules);\n  if (workloads.length > 0 && initWeights.length === 0) {\n    initWeights = getDefaultWeights(workloads);\n  }\n  const trRoute = {\n    workloads: initWeights,\n    isTimeout: false,\n    timeout: '2s',\n    isValidTimeout: true,\n    isRetry: false,\n    retries: {\n      attempts: 3,\n      perTryTimeout: '2s',\n      retryOn: 'gateway-error,connect-failure,refused-stream'\n    },\n    isValidRetry: true\n  };\n  // This use case is intended for VS with single HTTP Route, others scenarios should use the Request Routing Wizard\n  if (\n    virtualServices.items.length === 1 &&\n    virtualServices.items[0].spec.http &&\n    virtualServices.items[0].spec.http.length === 1\n  ) {\n    if (virtualServices.items[0].spec.http[0].timeout) {\n      trRoute.isTimeout = true;\n      trRoute.timeout = virtualServices.items[0].spec.http[0].timeout;\n    }\n    if (virtualServices.items[0].spec.http[0].retries) {\n      trRoute.isRetry = true;\n      trRoute.retries.attempts = virtualServices.items[0].spec.http[0].retries.attempts;\n      if (virtualServices.items[0].spec.http[0].retries.perTryTimeout) {\n        trRoute.retries.perTryTimeout = virtualServices.items[0].spec.http[0].retries.perTryTimeout;\n      }\n      if (virtualServices.items[0].spec.http[0].retries.retryOn) {\n      }\n    }\n  }\n  return trRoute;\n};\n\nexport const getInitTlsMode = (destinationRules: DestinationRules): [string, string, string, string] => {\n  if (\n    destinationRules.items.length === 1 &&\n    destinationRules.items[0].spec.trafficPolicy &&\n    destinationRules.items[0].spec.trafficPolicy.tls\n  ) {\n    return [\n      destinationRules.items[0].spec.trafficPolicy.tls.mode || '',\n      destinationRules.items[0].spec.trafficPolicy.tls.clientCertificate || '',\n      destinationRules.items[0].spec.trafficPolicy.tls.privateKey || '',\n      destinationRules.items[0].spec.trafficPolicy.tls.caCertificates || ''\n    ];\n  }\n  return ['', '', '', ''];\n};\n\nexport const getInitLoadBalancer = (destinationRules: DestinationRules): LoadBalancerSettings | undefined => {\n  if (\n    destinationRules.items.length === 1 &&\n    destinationRules.items[0].spec.trafficPolicy &&\n    destinationRules.items[0].spec.trafficPolicy.loadBalancer\n  ) {\n    return destinationRules.items[0].spec.trafficPolicy.loadBalancer;\n  }\n  return undefined;\n};\n\nexport const getInitPeerAuthentication = (\n  destinationRules: DestinationRules,\n  peerAuthentications: PeerAuthentication[]\n): PeerAuthenticationMutualTLSMode | undefined => {\n  let paMode: PeerAuthenticationMutualTLSMode | undefined;\n  if (\n    destinationRules.items.length === 1 &&\n    destinationRules.items[0].metadata.annotations &&\n    destinationRules.items[0].metadata.annotations[KIALI_RELATED_LABEL]\n  ) {\n    let related = destinationRules.items[0].metadata.annotations[KIALI_RELATED_LABEL].split('/');\n    if (related.length > 1) {\n      const peerAuthn = peerAuthentications.find(\n        (value: PeerAuthentication): boolean => value.metadata.name === related[1]\n      );\n      if (peerAuthn) {\n        paMode = peerAuthn.spec!.mtls!.mode;\n      }\n    }\n  }\n  return paMode;\n};\n\nexport const getInitConnectionPool = (destinationRules: DestinationRules): ConnectionPoolSettings | undefined => {\n  if (\n    destinationRules.items.length === 1 &&\n    destinationRules.items[0].spec.trafficPolicy &&\n    destinationRules.items[0].spec.trafficPolicy?.connectionPool\n  ) {\n    return destinationRules.items[0].spec.trafficPolicy?.connectionPool;\n  }\n  return undefined;\n};\n\nexport const getInitOutlierDetection = (destinationRules: DestinationRules): OutlierDetection | undefined => {\n  if (\n    destinationRules.items.length === 1 &&\n    destinationRules.items[0].spec.trafficPolicy &&\n    destinationRules.items[0].spec.trafficPolicy?.outlierDetection\n  ) {\n    return destinationRules.items[0].spec.trafficPolicy?.outlierDetection;\n  }\n  return undefined;\n};\n\nexport const hasGateway = (virtualServices: VirtualServices): boolean => {\n  // We need to if sentence, otherwise a potential undefined is not well handled\n  if (\n    virtualServices.items.length === 1 &&\n    virtualServices.items[0] &&\n    virtualServices.items[0].spec.gateways &&\n    virtualServices.items[0].spec.gateways.length > 0\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const getInitHosts = (virtualServices: VirtualServices): string[] => {\n  if (virtualServices.items.length === 1 && virtualServices.items[0] && virtualServices.items[0].spec.hosts) {\n    return virtualServices.items[0].spec.hosts;\n  }\n  return [];\n};\n\n// VirtualServices added from the Kiali Wizard only support to add a single gateway\n// and optionally a mesh gateway.\n// This method returns a gateway selected by the user and if mesh is present\nexport const getInitGateway = (virtualServices: VirtualServices): [string, boolean] => {\n  if (\n    virtualServices.items.length === 1 &&\n    virtualServices.items[0] &&\n    virtualServices.items[0].spec.gateways &&\n    virtualServices.items[0].spec.gateways.length > 0\n  ) {\n    let selectedGateway = virtualServices.items[0].spec.gateways[0];\n    if (selectedGateway === 'mesh') {\n      // In Kiali Wizard, the first gateway is reserved for user gateway\n      selectedGateway = '';\n    }\n    let meshPresent = false;\n    if (virtualServices.items[0].spec.gateways.includes('mesh')) {\n      meshPresent = true;\n    }\n    return [selectedGateway, meshPresent];\n  }\n  return ['', false];\n};\n\nexport const buildAuthorizationPolicy = (\n  name: string,\n  namespace: string,\n  state: AuthorizationPolicyState\n): AuthorizationPolicy => {\n  const ap: AuthorizationPolicy = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'AuthorizationPolicy'\n      }\n    },\n    spec: {}\n  };\n\n  // DENY_ALL and ALLOW_ALL are two specific cases\n  if (state.policy === 'DENY_ALL') {\n    ap.spec.action = undefined;\n    ap.spec.selector = undefined;\n    ap.spec.rules = undefined;\n    return ap;\n  }\n\n  if (state.policy === 'ALLOW_ALL') {\n    ap.spec.action = ALLOW;\n    ap.spec.selector = undefined;\n    ap.spec.rules = [{}];\n    return ap;\n  }\n\n  // RULES use case\n  if (state.workloadSelector.length > 0) {\n    const workloadSelector: AuthorizationPolicyWorkloadSelector = {\n      matchLabels: {}\n    };\n    state.workloadSelector.split(',').forEach(label => {\n      label = label.trim();\n      const labelDetails = label.split('=');\n      if (labelDetails.length === 2) {\n        workloadSelector.matchLabels[labelDetails[0]] = labelDetails[1];\n      }\n    });\n    ap.spec.selector = workloadSelector;\n  }\n\n  if (state.rules.length > 0) {\n    ap.spec.rules = [];\n    state.rules.forEach(rule => {\n      const appRule: AuthorizationPolicyRule = {\n        from: undefined,\n        to: undefined,\n        when: undefined\n      };\n      if (rule.from.length > 0) {\n        appRule.from = rule.from.map(fromItem => {\n          const source: Source = {};\n          Object.keys(fromItem).forEach(key => {\n            source[key] = fromItem[key];\n          });\n          return {\n            source: source\n          };\n        });\n      }\n      if (rule.to.length > 0) {\n        appRule.to = rule.to.map(toItem => {\n          const operation: Operation = {};\n          Object.keys(toItem).forEach(key => {\n            operation[key] = toItem[key];\n          });\n          return {\n            operation: operation\n          };\n        });\n      }\n      if (rule.when.length > 0) {\n        appRule.when = rule.when.map(condition => {\n          const cond: Condition = {\n            key: condition.key\n          };\n          if (condition.values && condition.values.length > 0) {\n            cond.values = condition.values;\n          }\n          if (condition.notValues && condition.notValues.length > 0) {\n            cond.notValues = condition.notValues;\n          }\n          return cond;\n        });\n      }\n      ap.spec.rules!.push(appRule);\n    });\n  }\n  if (state.action.length > 0) {\n    ap.spec.action = state.action;\n  }\n  return ap;\n};\n\nexport const buildGraphAuthorizationPolicy = (namespace: string, graph: GraphDefinition): AuthorizationPolicy[] => {\n  const denyAll: AuthorizationPolicy = {\n    metadata: {\n      name: 'deny-all-' + namespace,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'AuthorizationPolicy'\n      }\n    },\n    spec: {}\n  };\n  const aps: AuthorizationPolicy[] = [denyAll];\n\n  if (graph.elements.nodes) {\n    for (let i = 0; i < graph.elements.nodes.length; i++) {\n      const node = graph.elements.nodes[i];\n      if (\n        node.data.namespace === namespace &&\n        node.data.nodeType === NodeType.WORKLOAD &&\n        node.data.workload &&\n        node.data.app &&\n        node.data.version\n      ) {\n        const ap: AuthorizationPolicy = {\n          metadata: {\n            name: node.data.workload,\n            namespace: namespace,\n            labels: {\n              [KIALI_WIZARD_LABEL]: 'AuthorizationPolicy'\n            }\n          },\n          spec: {\n            selector: {\n              matchLabels: {\n                app: node.data.app,\n                version: node.data.version\n              }\n            },\n            rules: [\n              {\n                from: [\n                  {\n                    source: {\n                      principals: []\n                    }\n                  }\n                ]\n              }\n            ]\n          }\n        };\n        let principalsLen = 0;\n        if (graph.elements.edges) {\n          for (let j = 0; j < graph.elements.edges.length; j++) {\n            const edge = graph.elements.edges[j];\n            if (node.data.id === edge.data.target) {\n              if (\n                ap.spec.rules &&\n                ap.spec.rules[0] &&\n                ap.spec.rules[0].from &&\n                ap.spec.rules[0].from[0] &&\n                ap.spec.rules[0].from[0].source &&\n                ap.spec.rules[0].from[0].source.principals &&\n                edge.data.sourcePrincipal\n              ) {\n                const principal = edge.data.sourcePrincipal.startsWith('spiffe://')\n                  ? edge.data.sourcePrincipal.substring(9)\n                  : edge.data.sourcePrincipal;\n                ap.spec.rules[0].from[0].source.principals.push(principal);\n                principalsLen++;\n              }\n            }\n          }\n        }\n        if (principalsLen > 0) {\n          aps.push(ap);\n        }\n      }\n    }\n  }\n  return aps;\n};\n\nexport const buildGateway = (name: string, namespace: string, state: GatewayState): Gateway => {\n  const gw: Gateway = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'Gateway'\n      }\n    },\n    spec: {\n      // Default for istio scenarios, user may change it editing YAML\n      selector: {},\n      servers: state.gatewayServers.map(s => ({\n        port: s.port,\n        hosts: s.hosts,\n        tls: s.tls\n      }))\n    }\n  };\n  state.workloadSelectorLabels\n    .trim()\n    .split(',')\n    .forEach(split => {\n      const labels = split.trim().split('=');\n      // It should be already validated with workloadSelectorValid, but just to add extra safe check\n      if (gw.spec.selector && labels.length === 2) {\n        gw.spec.selector[labels[0].trim()] = labels[1].trim();\n      }\n    });\n  return gw;\n};\n\nexport const buildPeerAuthentication = (\n  name: string,\n  namespace: string,\n  state: PeerAuthenticationState\n): PeerAuthentication => {\n  const pa: PeerAuthentication = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'PeerAuthentication'\n      }\n    },\n    spec: {}\n  };\n\n  if (state.workloadSelector.length > 0) {\n    const workloadSelector: PeerAuthenticationWorkloadSelector = {\n      matchLabels: {}\n    };\n    state.workloadSelector.split(',').forEach(label => {\n      label = label.trim();\n      const labelDetails = label.split('=');\n      if (labelDetails.length === 2) {\n        workloadSelector.matchLabels[labelDetails[0]] = labelDetails[1];\n      }\n    });\n    pa.spec.selector = workloadSelector;\n  }\n\n  // Kiali is always adding this field\n  pa.spec.mtls = {\n    mode: PeerAuthenticationMutualTLSMode[state.mtls]\n  };\n\n  if (state.portLevelMtls.length > 0) {\n    pa.spec.portLevelMtls = {};\n    state.portLevelMtls.forEach(p => {\n      if (pa.spec.portLevelMtls) {\n        pa.spec.portLevelMtls[Number(p.port)] = {\n          mode: PeerAuthenticationMutualTLSMode[p.mtls]\n        };\n      }\n    });\n  }\n\n  return pa;\n};\n\nexport const buildRequestAuthentication = (\n  name: string,\n  namespace: string,\n  state: RequestAuthenticationState\n): RequestAuthentication => {\n  const ra: RequestAuthentication = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'RequestAuthentication'\n      }\n    },\n    spec: {\n      jwtRules: []\n    }\n  };\n\n  if (state.workloadSelector.length > 0) {\n    const workloadSelector: WorkloadMatchSelector = {\n      matchLabels: {}\n    };\n    state.workloadSelector.split(',').forEach(label => {\n      label = label.trim();\n      const labelDetails = label.split('=');\n      if (labelDetails.length === 2) {\n        workloadSelector.matchLabels[labelDetails[0]] = labelDetails[1];\n      }\n    });\n    ra.spec.selector = workloadSelector;\n  }\n\n  if (state.jwtRules.length > 0) {\n    ra.spec.jwtRules = state.jwtRules;\n  }\n  return ra;\n};\n\nexport const buildServiceEntry = (name: string, namespace: string, state: ServiceEntryState): ServiceEntry => {\n  const se: ServiceEntry = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'ServiceEntry'\n      }\n    },\n    spec: state.serviceEntry\n  };\n  return se;\n};\n\nexport const buildSidecar = (name: string, namespace: string, state: SidecarState): Sidecar => {\n  const sc: Sidecar = {\n    metadata: {\n      name: name,\n      namespace: namespace,\n      labels: {\n        [KIALI_WIZARD_LABEL]: 'Sidecar'\n      }\n    },\n    spec: {\n      egress: [\n        {\n          hosts: state.egressHosts.map(eh => eh.host)\n        }\n      ]\n    }\n  };\n  if (state.addWorkloadSelector && state.workloadSelectorValid) {\n    sc.spec.workloadSelector = {\n      labels: {}\n    };\n    state.workloadSelectorLabels\n      .trim()\n      .split(',')\n      .forEach(split => {\n        const labels = split.trim().split('=');\n        // It should be already validated with workloadSelectorValid, but just to add extra safe check\n        if (sc.spec.workloadSelector && labels.length === 2) {\n          sc.spec.workloadSelector.labels[labels[0].trim()] = labels[1].trim();\n        }\n      });\n  }\n  return sc;\n};\n\nexport const buildNamespaceInjectionPatch = (enable: boolean, remove: boolean, revision: string | null): string => {\n  const labels = {};\n  if (revision) {\n    labels[serverConfig.istioLabels.injectionLabelName] = null;\n    labels[serverConfig.istioLabels.injectionLabelRev] = revision;\n  } else {\n    labels[serverConfig.istioLabels.injectionLabelName] = remove ? null : enable ? 'enabled' : 'disabled';\n    labels[serverConfig.istioLabels.injectionLabelRev] = null;\n  }\n  const patch = {\n    metadata: {\n      labels: labels\n    }\n  };\n  return JSON.stringify(patch);\n};\n\nexport const buildWorkloadInjectionPatch = (\n  workloadType: string,\n  enable: boolean,\n  remove: boolean,\n  statusState: StatusState\n): string => {\n  const patch = {};\n\n  if (statusState.istioEnvironment.isMaistra) {\n    // Maistra only supports pod annotations\n    const annotations = {};\n    annotations[serverConfig.istioAnnotations.istioInjectionAnnotation] = remove ? null : enable ? 'true' : 'false';\n    if (workloadType === 'Pod') {\n      patch['annotations'] = annotations;\n    } else {\n      patch['spec'] = {\n        template: {\n          metadata: {\n            annotations: annotations\n          }\n        }\n      };\n    }\n  } else {\n    // supported non-Maistra environments prefer to use the pod label over the annotation\n    const labels = {};\n    labels[serverConfig.istioAnnotations.istioInjectionAnnotation] = remove ? null : enable ? 'true' : 'false';\n    if (workloadType === 'Pod') {\n      patch['labels'] = labels;\n    } else {\n      patch['spec'] = {\n        template: {\n          metadata: {\n            labels: labels\n          }\n        }\n      };\n    }\n  }\n  return JSON.stringify(patch);\n};\n"]},"metadata":{},"sourceType":"module"}