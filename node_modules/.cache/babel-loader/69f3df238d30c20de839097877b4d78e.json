{"ast":null,"code":"import _round from 'lodash/round';\nimport moment from 'moment';\nimport { retrieveTimeRange } from 'components/Time/TimeRangeHelper';\nimport { guardTimeRange, durationToBounds } from 'types/Common';\nimport { spansSort } from './TraceTransform';\nexport var defaultTracingDuration = 600;\nexport var isErrorTag = function isErrorTag(_ref) {\n  var key = _ref.key,\n      value = _ref.value;\n  return key === 'error' && (value === true || value === 'true');\n};\nexport var getTimeRangeMicros = function getTimeRangeMicros() {\n  var range = retrieveTimeRange(); // Convert any time range (like duration) to bounded from/to\n\n  var boundsMillis = guardTimeRange(range, durationToBounds, function (b) {\n    return b;\n  }); // Not necessary, we know that guardTimeRange will always send a default\n\n  var defaultFrom = new Date().getTime() - defaultTracingDuration * 1000; // Convert to microseconds\n\n  return {\n    from: boundsMillis.from ? boundsMillis.from * 1000 : defaultFrom * 1000,\n    to: boundsMillis.to ? boundsMillis.to * 1000 : undefined\n  };\n};\nexport var getWorkloadFromSpan = function getWorkloadFromSpan(span) {\n  var nodeKV = span.tags.find(function (tag) {\n    return tag.key === 'node_id';\n  });\n\n  if (nodeKV) {\n    // Example of node value:\n    // sidecar~172.17.0.20~ai-locals-6d8996bff-ztg6z.default~default.svc.cluster.local\n    var parts = nodeKV.value.split('~');\n\n    if (parts.length < 3) {\n      return undefined;\n    }\n\n    var podWithNamespace = parts[2];\n    var nsIdx = podWithNamespace.lastIndexOf('.');\n\n    if (nsIdx >= 0) {\n      return extractWorkloadFromPod(podWithNamespace.substring(0, nsIdx), podWithNamespace.substring(nsIdx + 1));\n    }\n\n    return undefined;\n  } // Tag not found => try with 'hostname' in process' tags\n\n\n  var hostnameKV = span.process.tags.find(function (tag) {\n    return tag.key === 'hostname';\n  });\n\n  if (hostnameKV) {\n    var svcNs = span.process.serviceName.split('.');\n    return extractWorkloadFromPod(hostnameKV.value, svcNs.length > 1 ? svcNs[1] : '');\n  }\n\n  return undefined;\n};\nvar replicasetFromPodRegex = /^([a-z0-9-.]+)-[a-z0-9]+$/;\n\nvar extractWorkloadFromPod = function extractWorkloadFromPod(pod, ns) {\n  var result = replicasetFromPodRegex.exec(pod);\n\n  if (result && result.length === 2) {\n    return {\n      pod: pod,\n      workload: adjustWorkloadNameFromReplicaset(result[1]),\n      namespace: ns\n    };\n  }\n\n  return undefined;\n}; // Pod template hash should be made of alphanum without vowels, '0', '1' and '3'\n// (see https://github.com/kubernetes/kubernetes/blob/release-1.17/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83)\n\n\nvar templateHashRegex = /^[bcdfghjklmnpqrstvwxz2456789]{6,16}$/;\n\nvar adjustWorkloadNameFromReplicaset = function adjustWorkloadNameFromReplicaset(replicaset) {\n  // This is a best effort to try to disambiguate deployment-like workloads versus replicaset-like workloads\n  // Workloads can be:\n  // - foo-fg65h9p7qj (deployment)\n  // - bar-replicaset (replicaset)\n  // In the first case, we want to keep \"foo\", but in the second case we need the whole \"bar-replicaset\" string.\n  // This is not 100% guaranteed, there's still a small chance that a replica set is wrongly seen as a deployment-like workload.\n  // That happens when:\n  // - it contains at least one dash '-'\n  // - AND the part after the last dash is:\n  //   . between 6 and 16 characters long\n  //   . AND compound exclusively of alphanums characters except vowels, '0', '1' and '3'\n  var parts = replicaset.split('-');\n\n  if (parts.length < 2) {\n    return replicaset;\n  }\n\n  var templateHashCandidate = parts[parts.length - 1];\n\n  if (templateHashRegex.test(templateHashCandidate)) {\n    return replicaset.substring(0, replicaset.length - templateHashCandidate.length - 1);\n  }\n\n  return replicaset;\n};\n\nexport var findParent = function findParent(span) {\n  if (Array.isArray(span.references)) {\n    var ref = span.references.find(function (s) {\n      return s.refType === 'CHILD_OF' || s.refType === 'FOLLOWS_FROM';\n    });\n    return (ref === null || ref === void 0 ? void 0 : ref.span) || undefined;\n  }\n\n  return undefined;\n};\nexport var findChildren = function findChildren(span, trace) {\n  return trace.spans.filter(function (s) {\n    var _findParent;\n\n    return ((_findParent = findParent(s)) === null || _findParent === void 0 ? void 0 : _findParent.spanID) === span.spanID;\n  }).sort(spansSort);\n};\nexport var searchParentWorkload = function searchParentWorkload(span) {\n  var parent = findParent(span);\n  return parent ? getWorkloadFromSpan(parent) : undefined;\n};\nexport var getAppFromSpan = function getAppFromSpan(span) {\n  var split = span.process.serviceName.split('.');\n  return {\n    app: split[0],\n    namespace: split.length > 1 ? split[1] : ''\n  };\n};\nexport var searchParentApp = function searchParentApp(span) {\n  var parent = findParent(span);\n  return parent ? getAppFromSpan(parent) : undefined;\n};\nexport var getSpanType = function getSpanType(span) {\n  var component = span.tags.find(function (tag) {\n    return tag.key === 'component';\n  });\n\n  if ((component === null || component === void 0 ? void 0 : component.value) === 'proxy') {\n    return 'envoy';\n  }\n\n  if (span.tags.some(function (t) {\n    return t.key.startsWith('http.');\n  })) {\n    return 'http';\n  }\n\n  if (span.tags.some(function (t) {\n    return t.key.startsWith('peer.');\n  })) {\n    return 'tcp';\n  }\n\n  return 'unknown';\n};\nexport var extractOpenTracingBaseInfo = function extractOpenTracingBaseInfo(span) {\n  var info = {\n    hasError: false\n  };\n  span.tags.forEach(function (t) {\n    if (t.key === 'component') {\n      info.component = t.value;\n    }\n\n    if (isErrorTag(t)) {\n      info.hasError = true;\n    }\n  });\n  return info;\n};\nexport var extractOpenTracingHTTPInfo = function extractOpenTracingHTTPInfo(span) {\n  // See https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  var info = extractOpenTracingBaseInfo(span);\n  span.tags.forEach(function (t) {\n    if (t.key === 'http.status_code') {\n      var val = parseInt(t.value, 10);\n\n      if (!isNaN(val) && val > 0) {\n        info.statusCode = val;\n      }\n    } else if (t.key === 'http.url') {\n      info.url = t.value;\n    } else if (t.key === 'http.method') {\n      info.method = t.value;\n    } else if (t.key === 'span.kind') {\n      if (t.value === 'client') {\n        info.direction = 'outbound';\n      } else if (t.value === 'server') {\n        info.direction = 'inbound';\n      }\n    }\n  });\n  return info;\n};\nexport var extractOpenTracingTCPInfo = function extractOpenTracingTCPInfo(span) {\n  // See https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  var info = extractOpenTracingBaseInfo(span);\n  span.tags.forEach(function (t) {\n    if (t.key === 'message_bus.destination') {\n      info.topic = t.value;\n    } else if (t.key === 'peer.address') {\n      info.peerAddress = t.value;\n    } else if (t.key === 'peer.hostname') {\n      info.peerHostname = t.value;\n    } else if (t.key === 'span.kind') {\n      if (t.value === 'producer' || t.value === 'client') {\n        info.direction = 'outbound';\n      } else if (t.value === 'consumer' || t.value === 'server') {\n        info.direction = 'inbound';\n      }\n    }\n  });\n  return info;\n};\nexport var extractEnvoySpanInfo = function extractEnvoySpanInfo(span) {\n  var info = extractOpenTracingHTTPInfo(span);\n  span.tags.forEach(function (t) {\n    if (t.key === 'response_flags') {\n      if (t.value !== '-') {\n        info.responseFlags = t.value;\n      }\n    } else if (t.key === 'upstream_cluster') {\n      var parts = t.value.split('|');\n\n      if (parts.length === 4) {\n        if (parts[0] === 'outbound') {\n          var svcParts = parts[3].split('.');\n\n          if (svcParts.length === 5) {\n            info.direction = 'outbound';\n            info.peer = {\n              name: svcParts[0],\n              namespace: svcParts[1],\n              kind: 'service'\n            };\n          }\n        } else if (parts[0] === 'inbound') {\n          var wkdNs = searchParentWorkload(span);\n\n          if (wkdNs) {\n            info.direction = 'inbound';\n            info.peer = {\n              name: wkdNs.workload,\n              namespace: wkdNs.namespace,\n              kind: 'workload'\n            };\n          }\n        }\n      }\n    }\n  });\n  return info;\n};\nexport var extractSpanInfo = function extractSpanInfo(span) {\n  var type = getSpanType(span);\n  var info = type === 'envoy' ? extractEnvoySpanInfo(span) : type === 'http' ? extractOpenTracingHTTPInfo(span) : type === 'tcp' ? extractOpenTracingTCPInfo(span) : extractOpenTracingBaseInfo(span);\n  return {\n    type: type,\n    info: info\n  };\n};\nexport var sameSpans = function sameSpans(a, b) {\n  return a.map(function (s) {\n    return s.spanID;\n  }).join() === b.map(function (s) {\n    return s.spanID;\n  }).join();\n};\nexport function formatDuration(micros) {\n  var d = micros / 1000;\n  var unit = 'ms';\n\n  if (d >= 1000) {\n    unit = 's';\n    d /= 1000;\n  }\n\n  return _round(d, 2) + unit;\n}\nvar TODAY = 'Today';\nvar YESTERDAY = 'Yesterday';\nexport function formatRelativeDate(value) {\n  var fullMonthName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var m = moment.isMoment(value) ? value : moment(value);\n  var monthFormat = fullMonthName ? 'MMMM' : 'MMM';\n  var dt = new Date();\n\n  if (dt.getFullYear() !== m.year()) {\n    return m.format(\"\".concat(monthFormat, \" D, YYYY\"));\n  }\n\n  var mMonth = m.month();\n  var mDate = m.date();\n  var date = dt.getDate();\n\n  if (mMonth === dt.getMonth() && mDate === date) {\n    return TODAY;\n  }\n\n  dt.setDate(date - 1);\n\n  if (mMonth === dt.getMonth() && mDate === dt.getDate()) {\n    return YESTERDAY;\n  }\n\n  return m.format(\"\".concat(monthFormat, \" D\"));\n}","map":{"version":3,"sources":["/root/kiali-ui/src/utils/tracing/TracingHelper.ts"],"names":["_round","moment","retrieveTimeRange","guardTimeRange","durationToBounds","spansSort","defaultTracingDuration","isErrorTag","key","value","getTimeRangeMicros","range","boundsMillis","b","defaultFrom","Date","getTime","from","to","undefined","getWorkloadFromSpan","span","nodeKV","tags","find","tag","parts","split","length","podWithNamespace","nsIdx","lastIndexOf","extractWorkloadFromPod","substring","hostnameKV","process","svcNs","serviceName","replicasetFromPodRegex","pod","ns","result","exec","workload","adjustWorkloadNameFromReplicaset","namespace","templateHashRegex","replicaset","templateHashCandidate","test","findParent","Array","isArray","references","ref","s","refType","findChildren","trace","spans","filter","spanID","sort","searchParentWorkload","parent","getAppFromSpan","app","searchParentApp","getSpanType","component","some","t","startsWith","extractOpenTracingBaseInfo","info","hasError","forEach","extractOpenTracingHTTPInfo","val","parseInt","isNaN","statusCode","url","method","direction","extractOpenTracingTCPInfo","topic","peerAddress","peerHostname","extractEnvoySpanInfo","responseFlags","svcParts","peer","name","kind","wkdNs","extractSpanInfo","type","sameSpans","a","map","join","formatDuration","micros","d","unit","TODAY","YESTERDAY","formatRelativeDate","fullMonthName","m","isMoment","monthFormat","dt","getFullYear","year","format","mMonth","month","mDate","date","getDate","getMonth","setDate"],"mappings":"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","sourcesContent":["import _round from 'lodash/round';\nimport moment from 'moment';\nimport {\n  EnvoySpanInfo,\n  JaegerTrace,\n  KeyValuePair,\n  OpenTracingBaseInfo,\n  OpenTracingHTTPInfo,\n  OpenTracingTCPInfo,\n  Span\n} from 'types/JaegerInfo';\nimport { retrieveTimeRange } from 'components/Time/TimeRangeHelper';\nimport { guardTimeRange, durationToBounds, DurationInSeconds } from 'types/Common';\nimport { spansSort } from './TraceTransform';\n\nexport const defaultTracingDuration: DurationInSeconds = 600;\n\nexport const isErrorTag = ({ key, value }: KeyValuePair) => key === 'error' && (value === true || value === 'true');\n\nexport const getTimeRangeMicros = () => {\n  const range = retrieveTimeRange();\n  // Convert any time range (like duration) to bounded from/to\n  const boundsMillis = guardTimeRange(range, durationToBounds, b => b);\n  // Not necessary, we know that guardTimeRange will always send a default\n  const defaultFrom = new Date().getTime() - defaultTracingDuration * 1000;\n  // Convert to microseconds\n  return {\n    from: boundsMillis.from ? boundsMillis.from * 1000 : defaultFrom * 1000,\n    to: boundsMillis.to ? boundsMillis.to * 1000 : undefined\n  };\n};\n\ntype WorkloadAndNamespace = { pod: string; workload: string; namespace: string };\nexport const getWorkloadFromSpan = (span: Span): WorkloadAndNamespace | undefined => {\n  const nodeKV = span.tags.find(tag => tag.key === 'node_id');\n  if (nodeKV) {\n    // Example of node value:\n    // sidecar~172.17.0.20~ai-locals-6d8996bff-ztg6z.default~default.svc.cluster.local\n    const parts = nodeKV.value.split('~');\n    if (parts.length < 3) {\n      return undefined;\n    }\n    const podWithNamespace = parts[2];\n    const nsIdx = podWithNamespace.lastIndexOf('.');\n    if (nsIdx >= 0) {\n      return extractWorkloadFromPod(podWithNamespace.substring(0, nsIdx), podWithNamespace.substring(nsIdx + 1));\n    }\n    return undefined;\n  }\n  // Tag not found => try with 'hostname' in process' tags\n  const hostnameKV = span.process.tags.find(tag => tag.key === 'hostname');\n  if (hostnameKV) {\n    const svcNs = span.process.serviceName.split('.');\n    return extractWorkloadFromPod(hostnameKV.value, svcNs.length > 1 ? svcNs[1] : '');\n  }\n  return undefined;\n};\n\nconst replicasetFromPodRegex = /^([a-z0-9-.]+)-[a-z0-9]+$/;\nconst extractWorkloadFromPod = (pod: string, ns: string): WorkloadAndNamespace | undefined => {\n  const result = replicasetFromPodRegex.exec(pod);\n  if (result && result.length === 2) {\n    return {\n      pod: pod,\n      workload: adjustWorkloadNameFromReplicaset(result[1]),\n      namespace: ns\n    };\n  }\n  return undefined;\n};\n\n// Pod template hash should be made of alphanum without vowels, '0', '1' and '3'\n// (see https://github.com/kubernetes/kubernetes/blob/release-1.17/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83)\nconst templateHashRegex = /^[bcdfghjklmnpqrstvwxz2456789]{6,16}$/;\nconst adjustWorkloadNameFromReplicaset = (replicaset: string): string => {\n  // This is a best effort to try to disambiguate deployment-like workloads versus replicaset-like workloads\n  // Workloads can be:\n  // - foo-fg65h9p7qj (deployment)\n  // - bar-replicaset (replicaset)\n  // In the first case, we want to keep \"foo\", but in the second case we need the whole \"bar-replicaset\" string.\n  // This is not 100% guaranteed, there's still a small chance that a replica set is wrongly seen as a deployment-like workload.\n  // That happens when:\n  // - it contains at least one dash '-'\n  // - AND the part after the last dash is:\n  //   . between 6 and 16 characters long\n  //   . AND compound exclusively of alphanums characters except vowels, '0', '1' and '3'\n  const parts = replicaset.split('-');\n  if (parts.length < 2) {\n    return replicaset;\n  }\n  const templateHashCandidate = parts[parts.length - 1];\n  if (templateHashRegex.test(templateHashCandidate)) {\n    return replicaset.substring(0, replicaset.length - templateHashCandidate.length - 1);\n  }\n  return replicaset;\n};\n\nexport const findParent = (span: Span): Span | undefined => {\n  if (Array.isArray(span.references)) {\n    const ref = span.references.find(s => s.refType === 'CHILD_OF' || s.refType === 'FOLLOWS_FROM');\n    return ref?.span || undefined;\n  }\n  return undefined;\n};\n\nexport const findChildren = (span: Span, trace: JaegerTrace): Span[] => {\n  return trace.spans.filter(s => findParent(s)?.spanID === span.spanID).sort(spansSort);\n};\n\nexport const searchParentWorkload = (span: Span): WorkloadAndNamespace | undefined => {\n  const parent = findParent(span);\n  return parent ? getWorkloadFromSpan(parent) : undefined;\n};\n\ntype AppAndNamespace = { app: string; namespace: string };\nexport const getAppFromSpan = (span: Span): AppAndNamespace | undefined => {\n  const split = span.process.serviceName.split('.');\n  return { app: split[0], namespace: split.length > 1 ? split[1] : '' };\n};\n\nexport const searchParentApp = (span: Span): AppAndNamespace | undefined => {\n  const parent = findParent(span);\n  return parent ? getAppFromSpan(parent) : undefined;\n};\n\nexport const getSpanType = (span: Span): 'envoy' | 'http' | 'tcp' | 'unknown' => {\n  const component = span.tags.find(tag => tag.key === 'component');\n  if (component?.value === 'proxy') {\n    return 'envoy';\n  }\n  if (span.tags.some(t => t.key.startsWith('http.'))) {\n    return 'http';\n  }\n  if (span.tags.some(t => t.key.startsWith('peer.'))) {\n    return 'tcp';\n  }\n  return 'unknown';\n};\n\nexport const extractOpenTracingBaseInfo = (span: Span): OpenTracingBaseInfo => {\n  const info: OpenTracingBaseInfo = { hasError: false };\n  span.tags.forEach(t => {\n    if (t.key === 'component') {\n      info.component = t.value;\n    }\n    if (isErrorTag(t)) {\n      info.hasError = true;\n    }\n  });\n  return info;\n};\n\nexport const extractOpenTracingHTTPInfo = (span: Span): OpenTracingHTTPInfo => {\n  // See https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  const info: OpenTracingHTTPInfo = extractOpenTracingBaseInfo(span);\n  span.tags.forEach(t => {\n    if (t.key === 'http.status_code') {\n      const val = parseInt(t.value, 10);\n      if (!isNaN(val) && val > 0) {\n        info.statusCode = val;\n      }\n    } else if (t.key === 'http.url') {\n      info.url = t.value;\n    } else if (t.key === 'http.method') {\n      info.method = t.value;\n    } else if (t.key === 'span.kind') {\n      if (t.value === 'client') {\n        info.direction = 'outbound';\n      } else if (t.value === 'server') {\n        info.direction = 'inbound';\n      }\n    }\n  });\n  return info;\n};\n\nexport const extractOpenTracingTCPInfo = (span: Span): OpenTracingTCPInfo => {\n  // See https://github.com/opentracing/specification/blob/master/semantic_conventions.md\n  const info: OpenTracingTCPInfo = extractOpenTracingBaseInfo(span);\n  span.tags.forEach(t => {\n    if (t.key === 'message_bus.destination') {\n      info.topic = t.value;\n    } else if (t.key === 'peer.address') {\n      info.peerAddress = t.value;\n    } else if (t.key === 'peer.hostname') {\n      info.peerHostname = t.value;\n    } else if (t.key === 'span.kind') {\n      if (t.value === 'producer' || t.value === 'client') {\n        info.direction = 'outbound';\n      } else if (t.value === 'consumer' || t.value === 'server') {\n        info.direction = 'inbound';\n      }\n    }\n  });\n  return info;\n};\n\nexport const extractEnvoySpanInfo = (span: Span): EnvoySpanInfo => {\n  const info: EnvoySpanInfo = extractOpenTracingHTTPInfo(span);\n  span.tags.forEach(t => {\n    if (t.key === 'response_flags') {\n      if (t.value !== '-') {\n        info.responseFlags = t.value;\n      }\n    } else if (t.key === 'upstream_cluster') {\n      const parts = (t.value as string).split('|');\n      if (parts.length === 4) {\n        if (parts[0] === 'outbound') {\n          const svcParts = parts[3].split('.');\n          if (svcParts.length === 5) {\n            info.direction = 'outbound';\n            info.peer = {\n              name: svcParts[0],\n              namespace: svcParts[1],\n              kind: 'service'\n            };\n          }\n        } else if (parts[0] === 'inbound') {\n          const wkdNs = searchParentWorkload(span);\n          if (wkdNs) {\n            info.direction = 'inbound';\n            info.peer = {\n              name: wkdNs.workload,\n              namespace: wkdNs.namespace,\n              kind: 'workload'\n            };\n          }\n        }\n      }\n    }\n  });\n  return info;\n};\n\nexport const extractSpanInfo = (span: Span) => {\n  const type = getSpanType(span);\n  const info =\n    type === 'envoy'\n      ? extractEnvoySpanInfo(span)\n      : type === 'http'\n      ? extractOpenTracingHTTPInfo(span)\n      : type === 'tcp'\n      ? extractOpenTracingTCPInfo(span)\n      : extractOpenTracingBaseInfo(span);\n  return { type: type, info: info };\n};\n\nexport const sameSpans = (a: Span[], b: Span[]): boolean => {\n  return a.map(s => s.spanID).join() === b.map(s => s.spanID).join();\n};\n\nexport function formatDuration(micros: number): string {\n  let d = micros / 1000;\n  let unit = 'ms';\n  if (d >= 1000) {\n    unit = 's';\n    d /= 1000;\n  }\n  return _round(d, 2) + unit;\n}\n\nconst TODAY = 'Today';\nconst YESTERDAY = 'Yesterday';\n\nexport function formatRelativeDate(value: any, fullMonthName: boolean = false) {\n  const m = moment.isMoment(value) ? value : moment(value);\n  const monthFormat = fullMonthName ? 'MMMM' : 'MMM';\n  const dt = new Date();\n  if (dt.getFullYear() !== m.year()) {\n    return m.format(`${monthFormat} D, YYYY`);\n  }\n  const mMonth = m.month();\n  const mDate = m.date();\n  const date = dt.getDate();\n  if (mMonth === dt.getMonth() && mDate === date) {\n    return TODAY;\n  }\n  dt.setDate(date - 1);\n  if (mMonth === dt.getMonth() && mDate === dt.getDate()) {\n    return YESTERDAY;\n  }\n  return m.format(`${monthFormat} D`);\n}\n"]},"metadata":{},"sourceType":"module"}