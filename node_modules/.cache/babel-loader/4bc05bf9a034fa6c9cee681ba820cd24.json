{"ast":null,"code":"export var jsYaml = require('js-yaml');\n\nvar numRows = function numRows(yaml) {\n  var rows = 0;\n\n  for (var i = 0; i < yaml.length; i++) {\n    if (yaml.charAt(i) === '\\n') {\n      rows++;\n    }\n  }\n\n  return rows;\n};\n\nvar posToRowCol = function posToRowCol(yaml, pos) {\n  var rowCol = {\n    position: pos,\n    row: 0,\n    col: 0\n  };\n  var lastNL = -1;\n\n  for (var i = 0; i < pos; i++) {\n    if (yaml.charAt(i) === '\\n') {\n      rowCol.row++;\n      lastNL = i;\n    }\n  }\n\n  rowCol.col = lastNL > -1 ? pos - (lastNL + 1) : pos;\n  return rowCol;\n};\n\nvar rowColToPos = function rowColToPos(yaml, row, col) {\n  var currentRow = 0;\n  var currentCol = 0;\n  var pos = -1;\n\n  for (var i = 0; i < yaml.length; i++) {\n    if (yaml.charAt(i) === '\\n') {\n      currentRow++;\n      currentCol = -1;\n    } else {\n      currentCol++;\n    }\n\n    if (currentRow === row && currentCol === col) {\n      // If col == 0, pos is NL char, so returned pos should be first char after NL\n      return col === 0 ? i + 1 : i;\n    }\n  }\n\n  return pos;\n};\n/*\n  Find a token inside a yaml based string.\n  Returns the row/col coordinates of the token.\n  It manages special cases where a token is an array.\n */\n\n\nvar parseMarker = function parseMarker(yaml, startsFrom, token, isArray, arrayIndex) {\n  var aceMarker = {\n    startRow: 0,\n    startCol: 0,\n    endRow: 0,\n    endCol: 0,\n    position: -1\n  };\n  var tokenPos = startsFrom; // Find start of the spec part first, this should skip the whole metadata part\n\n  if (startsFrom < 0) {\n    tokenPos = yaml.indexOf('spec:', tokenPos);\n  } // Find initial token position\n\n\n  tokenPos = yaml.indexOf(token, tokenPos);\n\n  if (tokenPos < 0) {\n    return aceMarker;\n  }\n\n  var maxRows = numRows(yaml); // Array should find first '-' token to situate pos\n\n  if (isArray && arrayIndex !== undefined) {\n    tokenPos = yaml.indexOf('-', tokenPos); // We should find the right '-' under the same col of the yaml\n\n    var firstArrayRowCol = posToRowCol(yaml, tokenPos);\n    var row = firstArrayRowCol.row;\n    var col = firstArrayRowCol.col;\n    var arrayIndexPos = tokenPos;\n    var indexRow = 0; // Iterate to find next '-' token according arrayIndex\n\n    while (row < maxRows && indexRow < arrayIndex) {\n      row++;\n      var checkPos = rowColToPos(yaml, row, col);\n\n      if (yaml.charAt(checkPos) === '-') {\n        arrayIndexPos = checkPos;\n        indexRow++;\n      }\n    }\n\n    var arrayRowCol = posToRowCol(yaml, arrayIndexPos);\n    aceMarker.position = arrayIndexPos + 1; // Increase the index to not repeat same finding on next iteration\n\n    aceMarker.startRow = arrayRowCol.row;\n    aceMarker.startCol = arrayRowCol.col;\n  } else {\n    var tokenRowCol = posToRowCol(yaml, tokenPos);\n    aceMarker.position = tokenPos + token.length; // Increase the index to not repeat same finding on next iteration\n\n    aceMarker.startRow = tokenRowCol.row;\n    aceMarker.startCol = tokenRowCol.col;\n  } // Once start is calculated, we should calculate the end of the element iterating by rows\n\n\n  for (var _row = aceMarker.startRow + 1; _row < maxRows + 1; _row++) {\n    // It searches by row and column, starting from the beginning of the line\n    for (var _col = 0; _col <= aceMarker.startCol; _col++) {\n      var endTokenPos = rowColToPos(yaml, _row, _col); // We need to differentiate if token is an array or not to mark the end of the mark\n\n      if (yaml.charAt(endTokenPos) !== ' ' && (isArray || yaml.charAt(endTokenPos) !== '-')) {\n        aceMarker.endRow = _row;\n        aceMarker.endCol = 0;\n        return aceMarker;\n      }\n    }\n  }\n\n  return aceMarker;\n};\n\nvar parseCheck = function parseCheck(yaml, check) {\n  var severity = check.severity === 'error' || check.severity === 'warning' ? check.severity : 'info';\n  var marker = {\n    startRow: 0,\n    startCol: 0,\n    endRow: 0,\n    endCol: 0,\n    className: 'istio-validation-' + severity,\n    type: 'fullLine'\n  };\n  var annotation = {\n    row: 0,\n    column: 0,\n    type: severity,\n    text: (check.code ? check.code + ' ' : '') + check.message\n  };\n  var aceMarker = {\n    startRow: 0,\n    startCol: 0,\n    endRow: 0,\n    endCol: 0,\n    position: -1\n  };\n  /*\n    Potential paths:\n      - <empty, no path>\n      - spec/hosts\n      - spec/host\n      - spec/<protocol: http|tcp>[<nRoute>]/route\n      - spec/<protocol: http|tcp>[<nRoute>]/route[nDestination]\n      - spec/<protocol: http|tcp>[<nRoute>]/route[<nDestination>]/weight/<value>\n      - spec/<protocol: http|tcp>[nRoute]/route[nDestination]/destination\n   */\n\n  if (check.path.length > 0) {\n    var tokens = check.path.split('/'); // It skips the first 'spec' token\n\n    if (tokens.length > 1) {\n      for (var i = 1; i < tokens.length; i++) {\n        var token = tokens[i]; // Check if token has an array or not\n\n        if (token.indexOf('[') > -1 && token.indexOf(']') > -1) {\n          var startPos = token.indexOf('[');\n          var endPos = token.indexOf(']');\n          var arrayIndex = +token.substr(startPos + 1, endPos - startPos - 1);\n          var subtoken = token.substr(0, startPos);\n          aceMarker = parseMarker(yaml, aceMarker.position, subtoken, true, arrayIndex);\n        } else {\n          aceMarker = parseMarker(yaml, aceMarker.position, token, false);\n        }\n      }\n    }\n  }\n\n  marker.startRow = aceMarker.startRow;\n  marker.startCol = aceMarker.startCol; // React Ace editor has a flip in the marker indexes\n\n  marker.endRow = aceMarker.endRow > 0 ? aceMarker.endRow - 1 : 0;\n  marker.endCol = aceMarker.endCol;\n  annotation.row = marker.startRow;\n  return {\n    marker: marker,\n    annotation: annotation\n  };\n};\n\nexport var parseKialiValidations = function parseKialiValidations(yamlInput, kialiValidations) {\n  var aceValidations = {\n    markers: [],\n    annotations: []\n  };\n\n  if (!kialiValidations || yamlInput.length === 0 || Object.keys(kialiValidations).length === 0) {\n    return aceValidations;\n  }\n\n  kialiValidations.checks.forEach(function (check) {\n    var aceCheck = parseCheck(yamlInput, check);\n    aceValidations.markers.push(aceCheck.marker);\n    aceValidations.annotations.push(aceCheck.annotation);\n  });\n  return aceValidations;\n};\nexport var parseYamlValidations = function parseYamlValidations(yamlInput) {\n  var parsedValidations = {\n    markers: [],\n    annotations: []\n  };\n\n  try {\n    jsYaml.safeLoadAll(yamlInput);\n  } catch (e) {\n    var row = e.mark && e.mark.line ? e.mark.line : 0;\n    var col = e.mark && e.mark.column ? e.mark.column : 0;\n    var message = e.message ? e.message : '';\n    parsedValidations.markers.push({\n      startRow: row,\n      startCol: 0,\n      endRow: row + 1,\n      endCol: 0,\n      className: 'istio-validation-error',\n      type: 'fullLine'\n    });\n    parsedValidations.annotations.push({\n      row: row,\n      column: col,\n      type: 'error',\n      text: message\n    });\n  }\n\n  return parsedValidations;\n};","map":{"version":3,"sources":["/root/kiali-ui/src/types/AceValidations.ts"],"names":["jsYaml","require","numRows","yaml","rows","i","length","charAt","posToRowCol","pos","rowCol","position","row","col","lastNL","rowColToPos","currentRow","currentCol","parseMarker","startsFrom","token","isArray","arrayIndex","aceMarker","startRow","startCol","endRow","endCol","tokenPos","indexOf","maxRows","undefined","firstArrayRowCol","arrayIndexPos","indexRow","checkPos","arrayRowCol","tokenRowCol","endTokenPos","parseCheck","check","severity","marker","className","type","annotation","column","text","code","message","path","tokens","split","startPos","endPos","substr","subtoken","parseKialiValidations","yamlInput","kialiValidations","aceValidations","markers","annotations","Object","keys","checks","forEach","aceCheck","push","parseYamlValidations","parsedValidations","safeLoadAll","e","mark","line"],"mappings":"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","sourcesContent":["import { ObjectCheck, ObjectValidation } from './IstioObjects';\nimport { Annotation } from 'react-ace/types';\nimport { IMarker } from 'react-ace';\n\nexport const jsYaml = require('js-yaml');\n\nexport interface AceValidations {\n  markers: Array<IMarker>;\n  annotations: Array<Annotation>;\n}\n\ninterface AceCheck {\n  marker: IMarker;\n  annotation: Annotation;\n}\n\ninterface AceMarker {\n  startRow: number;\n  startCol: number;\n  endRow: number;\n  endCol: number;\n  position: number;\n}\n\ninterface YamlPosition {\n  position: number;\n  row: number;\n  col: number;\n}\n\nconst numRows = (yaml: string): number => {\n  let rows = 0;\n  for (let i = 0; i < yaml.length; i++) {\n    if (yaml.charAt(i) === '\\n') {\n      rows++;\n    }\n  }\n  return rows;\n};\n\nconst posToRowCol = (yaml: string, pos: number): YamlPosition => {\n  const rowCol: YamlPosition = {\n    position: pos,\n    row: 0,\n    col: 0\n  };\n  let lastNL = -1;\n  for (let i = 0; i < pos; i++) {\n    if (yaml.charAt(i) === '\\n') {\n      rowCol.row++;\n      lastNL = i;\n    }\n  }\n  rowCol.col = lastNL > -1 ? pos - (lastNL + 1) : pos;\n  return rowCol;\n};\n\nconst rowColToPos = (yaml: string, row: number, col: number): number => {\n  let currentRow = 0;\n  let currentCol = 0;\n  const pos = -1;\n  for (let i = 0; i < yaml.length; i++) {\n    if (yaml.charAt(i) === '\\n') {\n      currentRow++;\n      currentCol = -1;\n    } else {\n      currentCol++;\n    }\n    if (currentRow === row && currentCol === col) {\n      // If col == 0, pos is NL char, so returned pos should be first char after NL\n      return col === 0 ? i + 1 : i;\n    }\n  }\n  return pos;\n};\n\n/*\n  Find a token inside a yaml based string.\n  Returns the row/col coordinates of the token.\n  It manages special cases where a token is an array.\n */\nconst parseMarker = (\n  yaml: string,\n  startsFrom: number,\n  token: string,\n  isArray: boolean,\n  arrayIndex?: number\n): AceMarker => {\n  const aceMarker: AceMarker = {\n    startRow: 0,\n    startCol: 0,\n    endRow: 0,\n    endCol: 0,\n    position: -1\n  };\n\n  let tokenPos = startsFrom;\n\n  // Find start of the spec part first, this should skip the whole metadata part\n  if (startsFrom < 0) {\n    tokenPos = yaml.indexOf('spec:', tokenPos);\n  }\n\n  // Find initial token position\n  tokenPos = yaml.indexOf(token, tokenPos);\n  if (tokenPos < 0) {\n    return aceMarker;\n  }\n\n  const maxRows = numRows(yaml);\n\n  // Array should find first '-' token to situate pos\n  if (isArray && arrayIndex !== undefined) {\n    tokenPos = yaml.indexOf('-', tokenPos);\n    // We should find the right '-' under the same col of the yaml\n    const firstArrayRowCol = posToRowCol(yaml, tokenPos);\n    let row = firstArrayRowCol.row;\n    const col = firstArrayRowCol.col;\n    let arrayIndexPos = tokenPos;\n    let indexRow = 0;\n    // Iterate to find next '-' token according arrayIndex\n    while (row < maxRows && indexRow < arrayIndex) {\n      row++;\n      const checkPos = rowColToPos(yaml, row, col);\n      if (yaml.charAt(checkPos) === '-') {\n        arrayIndexPos = checkPos;\n        indexRow++;\n      }\n    }\n    const arrayRowCol = posToRowCol(yaml, arrayIndexPos);\n    aceMarker.position = arrayIndexPos + 1; // Increase the index to not repeat same finding on next iteration\n    aceMarker.startRow = arrayRowCol.row;\n    aceMarker.startCol = arrayRowCol.col;\n  } else {\n    const tokenRowCol = posToRowCol(yaml, tokenPos);\n    aceMarker.position = tokenPos + token.length; // Increase the index to not repeat same finding on next iteration\n    aceMarker.startRow = tokenRowCol.row;\n    aceMarker.startCol = tokenRowCol.col;\n  }\n\n  // Once start is calculated, we should calculate the end of the element iterating by rows\n  for (let row = aceMarker.startRow + 1; row < maxRows + 1; row++) {\n    // It searches by row and column, starting from the beginning of the line\n    for (let col = 0; col <= aceMarker.startCol; col++) {\n      const endTokenPos = rowColToPos(yaml, row, col);\n      // We need to differentiate if token is an array or not to mark the end of the mark\n      if (yaml.charAt(endTokenPos) !== ' ' && (isArray || yaml.charAt(endTokenPos) !== '-')) {\n        aceMarker.endRow = row;\n        aceMarker.endCol = 0;\n        return aceMarker;\n      }\n    }\n  }\n  return aceMarker;\n};\n\nconst parseCheck = (yaml: string, check: ObjectCheck): AceCheck => {\n  const severity = check.severity === 'error' || check.severity === 'warning' ? check.severity : 'info';\n  const marker: IMarker = {\n    startRow: 0,\n    startCol: 0,\n    endRow: 0,\n    endCol: 0,\n    className: 'istio-validation-' + severity,\n    type: 'fullLine'\n  };\n  const annotation = {\n    row: 0,\n    column: 0,\n    type: severity,\n    text: (check.code ? check.code + ' ' : '') + check.message\n  };\n  let aceMarker = {\n    startRow: 0,\n    startCol: 0,\n    endRow: 0,\n    endCol: 0,\n    position: -1\n  };\n  /*\n    Potential paths:\n      - <empty, no path>\n      - spec/hosts\n      - spec/host\n      - spec/<protocol: http|tcp>[<nRoute>]/route\n      - spec/<protocol: http|tcp>[<nRoute>]/route[nDestination]\n      - spec/<protocol: http|tcp>[<nRoute>]/route[<nDestination>]/weight/<value>\n      - spec/<protocol: http|tcp>[nRoute]/route[nDestination]/destination\n   */\n  if (check.path.length > 0) {\n    const tokens: string[] = check.path.split('/');\n    // It skips the first 'spec' token\n    if (tokens.length > 1) {\n      for (let i = 1; i < tokens.length; i++) {\n        const token = tokens[i];\n        // Check if token has an array or not\n        if (token.indexOf('[') > -1 && token.indexOf(']') > -1) {\n          const startPos = token.indexOf('[');\n          const endPos = token.indexOf(']');\n          const arrayIndex = +token.substr(startPos + 1, endPos - startPos - 1);\n          const subtoken = token.substr(0, startPos);\n          aceMarker = parseMarker(yaml, aceMarker.position, subtoken, true, arrayIndex);\n        } else {\n          aceMarker = parseMarker(yaml, aceMarker.position, token, false);\n        }\n      }\n    }\n  }\n\n  marker.startRow = aceMarker.startRow;\n  marker.startCol = aceMarker.startCol;\n  // React Ace editor has a flip in the marker indexes\n  marker.endRow = aceMarker.endRow > 0 ? aceMarker.endRow - 1 : 0;\n  marker.endCol = aceMarker.endCol;\n  annotation.row = marker.startRow;\n  return { marker: marker, annotation: annotation };\n};\n\nexport const parseKialiValidations = (yamlInput: string, kialiValidations?: ObjectValidation): AceValidations => {\n  const aceValidations: AceValidations = {\n    markers: [],\n    annotations: []\n  };\n\n  if (!kialiValidations || yamlInput.length === 0 || Object.keys(kialiValidations).length === 0) {\n    return aceValidations;\n  }\n\n  kialiValidations.checks.forEach(check => {\n    const aceCheck = parseCheck(yamlInput, check);\n    aceValidations.markers.push(aceCheck.marker);\n    aceValidations.annotations.push(aceCheck.annotation);\n  });\n  return aceValidations;\n};\n\nexport const parseYamlValidations = (yamlInput: string): AceValidations => {\n  const parsedValidations: AceValidations = {\n    markers: [],\n    annotations: []\n  };\n  try {\n    jsYaml.safeLoadAll(yamlInput);\n  } catch (e) {\n    const row = e.mark && e.mark.line ? e.mark.line : 0;\n    const col = e.mark && e.mark.column ? e.mark.column : 0;\n    const message = e.message ? e.message : '';\n    parsedValidations.markers.push({\n      startRow: row,\n      startCol: 0,\n      endRow: row + 1,\n      endCol: 0,\n      className: 'istio-validation-error',\n      type: 'fullLine'\n    });\n    parsedValidations.annotations.push({\n      row: row,\n      column: col,\n      type: 'error',\n      text: message\n    });\n  }\n  return parsedValidations;\n};\n"]},"metadata":{},"sourceType":"module"}