{"ast":null,"code":"import _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { clamp, quadraticBezier, linearInterpolation, distance, bezierLength } from '../../../utils/MathUtils';\nimport { DimClass, HoveredClass } from '../graphs/GraphStyles';\nimport { PFColorVals } from '../../Pf/PfColors';\nimport { TrafficPointCircleRenderer, TrafficPointConcentricDiamondRenderer, Diamond } from './TrafficPointRenderer';\nimport { decoratedEdgeData } from '../CytoscapeGraphUtils';\nimport { Protocol } from '../../../types/Graph';\nimport { timerConfig, tcpTimerConfig } from './AnimationTimerConfig'; // Clamp response time from min to max\n\nvar SPEED_RESPONSE_TIME_MIN = 0;\nvar SPEED_RESPONSE_TIME_MAX = 10000; // Speed to travel trough an edge\n\nvar SPEED_RATE_MIN = 0.1;\nvar SPEED_RATE_MAX = 2.0;\nvar TCP_SPEED = 1;\nvar BASE_LENGTH = 50; // How often paint a frame\n\nvar FRAME_RATE = 1 / 60;\nvar EdgeConnectionType;\n\n(function (EdgeConnectionType) {\n  EdgeConnectionType[EdgeConnectionType[\"LINEAR\"] = 0] = \"LINEAR\";\n  EdgeConnectionType[EdgeConnectionType[\"CURVE\"] = 1] = \"CURVE\";\n  EdgeConnectionType[EdgeConnectionType[\"LOOP\"] = 2] = \"LOOP\";\n})(EdgeConnectionType || (EdgeConnectionType = {}));\n\nvar TrafficEdgeType;\n/**\n * Returns a TrafficPointRenderer for an RPS error point\n * @param edge\n * @returns {TrafficPointRenderer}\n */\n\n(function (TrafficEdgeType) {\n  TrafficEdgeType[TrafficEdgeType[\"RPS\"] = 0] = \"RPS\";\n  TrafficEdgeType[TrafficEdgeType[\"TCP\"] = 1] = \"TCP\";\n  TrafficEdgeType[TrafficEdgeType[\"NONE\"] = 2] = \"NONE\";\n})(TrafficEdgeType || (TrafficEdgeType = {}));\n\nvar getTrafficPointRendererForRpsError = function getTrafficPointRendererForRpsError(_edge) {\n  return new TrafficPointConcentricDiamondRenderer(new Diamond(5, PFColorVals.White, PFColorVals.Danger, 1.0), new Diamond(2, PFColorVals.Danger, PFColorVals.Danger, 1.0));\n};\n/**\n * Returns a TrafficPointRenderer for a RPS success point\n * @param edge\n * @returns {TrafficPointRenderer}\n */\n\n\nvar getTrafficPointRendererForRpsSuccess = function getTrafficPointRendererForRpsSuccess(edge) {\n  return new TrafficPointCircleRenderer(2, PFColorVals.White, edge.style('line-color'), 2);\n};\n/**\n * Returns a TrafficPointRenderer for a Tcp point\n * @param edge\n * @returns {TrafficPointCircleRenderer}\n */\n\n\nvar getTrafficPointRendererForTcp = function getTrafficPointRendererForTcp(_edge) {\n  return new TrafficPointCircleRenderer(1.6, PFColorVals.Black100, PFColorVals.Black500, 1);\n};\n/**\n * Traffic Point, it defines in an edge\n * speed - defines how fast the point is going to travel from the start to the end\n *  of the edge. Is a rate of the edge length traveled by second.\n *  1 means that the edge is traveled in exactly 1 second.\n *  0.5 is 2 seconds, 2 is half a second, etc.\n * delta - defines in what part of the edge is the point,  is a normalized number\n *  from 0 to 1, 0 means at the start of the path, and 1 is the end. The position\n *  is interpolated.\n * offset - Offset to add to the rendered point position.\n * renderer - Renderer used to draw the shape at a given position.\n */\n\n\n/**\n * Helps generate traffic points\n * timer - defines how fast to generate a new point, its in milliseconds.\n * timerForNextPoint - keeps track of how many milliseconds to generate the next point.\n * speed - defines the speed of the next point (see TrafficPoint.speed)\n */\nvar TrafficPointGenerator = /*#__PURE__*/function () {\n  function TrafficPointGenerator() {\n    _classCallCheck(this, TrafficPointGenerator);\n\n    this.timer = void 0;\n    this.timerForNextPoint = void 0;\n    this.speed = 0;\n    this.errorRate = 0;\n    this.type = TrafficEdgeType.NONE;\n  }\n\n  _createClass(TrafficPointGenerator, [{\n    key: \"processStep\",\n    value:\n    /**\n     * Process a render step for the generator, decrements the timerForNextPoint and\n     * returns a new point if it reaches zero (or is close).\n     * This method adds some randomness to avoid the \"flat\" look that all the points\n     * are synchronized.\n     */\n    function processStep(step, edge) {\n      if (this.timerForNextPoint !== undefined) {\n        this.timerForNextPoint -= step; // Add some random-ness to make it less \"flat\"\n\n        if (this.timerForNextPoint <= Math.random() * 200) {\n          this.timerForNextPoint = this.timer;\n          return this.nextPoint(edge);\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"setTimer\",\n    value: function setTimer(timer) {\n      this.timer = timer; // Start as soon as posible, unless we have no traffic\n\n      if (this.timerForNextPoint === undefined) {\n        this.timerForNextPoint = timer;\n      }\n    }\n  }, {\n    key: \"setSpeed\",\n    value: function setSpeed(speed) {\n      this.speed = speed;\n    }\n  }, {\n    key: \"setErrorRate\",\n    value: function setErrorRate(errorRate) {\n      this.errorRate = errorRate;\n    }\n  }, {\n    key: \"setType\",\n    value: function setType(type) {\n      this.type = type;\n    }\n  }, {\n    key: \"nextPoint\",\n    value: function nextPoint(edge) {\n      var renderer;\n      var offset;\n      var isErrorPoint = Math.random() <= this.errorRate;\n\n      if (this.type === TrafficEdgeType.RPS) {\n        renderer = isErrorPoint ? getTrafficPointRendererForRpsError(edge) : getTrafficPointRendererForRpsSuccess(edge);\n      } else if (this.type === TrafficEdgeType.TCP) {\n        renderer = getTrafficPointRendererForTcp(edge); // Cheap way to put some offset around the edge, I think this is enough unless we want more accuracy\n        // More accuracy would need to identify the slope of current segment of the edgge (for curves and loops) to only do\n        // offsets perpendicular to it, instead of it, we are moving around a circle area\n        // Random offset (x,y); 'x' in [-1.5, 1.5] and 'y' in [-1.5, 1.5]\n\n        offset = {\n          x: Math.random() * 3 - 1.5,\n          y: Math.random() * 3 - 1.5\n        };\n      }\n\n      return {\n        speed: this.speed,\n        delta: 0,\n        // at the beginning of the edge\n        renderer: renderer,\n        offset: offset\n      };\n    }\n  }]);\n\n  return TrafficPointGenerator;\n}();\n/**\n * Holds the list of points an edge has.\n * points - list of active points the edge has, points are discarded when they\n *  reach their target.\n * generator - Generates the next point\n * edge - Edge where the traffic is tracked\n */\n\n\nvar TrafficEdge = /*#__PURE__*/function () {\n  function TrafficEdge() {\n    _classCallCheck(this, TrafficEdge);\n\n    this.points = [];\n    this.generator = void 0;\n    this.edge = void 0;\n    this.type = TrafficEdgeType.NONE;\n    this.generator = new TrafficPointGenerator();\n  }\n  /**\n   * Process a step for the Traffic Edge, increments the delta of the points\n   * Calls `processStep` for the generator and adds a new point if any.\n   */\n\n\n  _createClass(TrafficEdge, [{\n    key: \"processStep\",\n    value: function processStep(step) {\n      this.points = this.points.map(function (p) {\n        p.delta += step * p.speed / 1000;\n        return p;\n      });\n      var point = this.generator.processStep(step, this.edge);\n\n      if (point) {\n        this.points.push(point);\n      }\n    }\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      return this.points;\n    }\n  }, {\n    key: \"getEdge\",\n    value: function getEdge() {\n      return this.edge;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this.type;\n    }\n  }, {\n    key: \"setTimer\",\n    value: function setTimer(timer) {\n      this.generator.setTimer(timer);\n    }\n    /**\n     * When a point is 1 or over it, is time to discard it.\n     */\n\n  }, {\n    key: \"removeFinishedPoints\",\n    value: function removeFinishedPoints() {\n      this.points = this.points.filter(function (p) {\n        return p.delta <= 1;\n      });\n    }\n  }, {\n    key: \"setSpeed\",\n    value: function setSpeed(speed) {\n      this.generator.setSpeed(speed);\n    }\n  }, {\n    key: \"setErrorRate\",\n    value: function setErrorRate(errorRate) {\n      this.generator.setErrorRate(errorRate);\n    }\n  }, {\n    key: \"setEdge\",\n    value: function setEdge(edge) {\n      this.edge = edge;\n    }\n  }, {\n    key: \"setType\",\n    value: function setType(type) {\n      this.type = type;\n      this.generator.setType(type);\n    }\n  }]);\n\n  return TrafficEdge;\n}();\n\n/**\n * Renders the traffic going from edges using the edge information to compute\n * their rate and speed\n *\n * rate determines how often to put a TrafficPoint in the edge.\n * responseTime determines how fast the TrafficPoint should travel from the start to the end of the edge.\n * percentErr determine if the next TrafficPoint is error or not.\n */\nvar TrafficRenderer = /*#__PURE__*/function () {\n  function TrafficRenderer(cy) {\n    var _this = this;\n\n    _classCallCheck(this, TrafficRenderer);\n\n    this.animationTimer = void 0;\n    this.previousTimestamp = void 0;\n    this.trafficEdges = {};\n    this.layer = void 0;\n    this.context = void 0;\n\n    this.processStep = function () {\n      try {\n        var nextTimestamp = Date.now();\n\n        if (!_this.previousTimestamp) {\n          _this.previousTimestamp = nextTimestamp;\n        }\n\n        var step = _this.currentStep(nextTimestamp);\n\n        _this.layer.clear(_this.context);\n\n        _this.layer.setTransform(_this.context);\n\n        Object.keys(_this.trafficEdges).forEach(function (edgeId) {\n          var trafficEdge = _this.trafficEdges[edgeId];\n          var edge = trafficEdge.getEdge(); // Skip if edge is currently hidden or removed\n\n          if (edge.visible() && edge.inside()) {\n            trafficEdge.processStep(step);\n            trafficEdge.removeFinishedPoints();\n\n            _this.render(trafficEdge);\n          }\n        });\n        _this.previousTimestamp = nextTimestamp;\n      } catch (exception) {\n        // If a step failed, the next step is likely to fail.\n        // Stop the rendering and throw the exception\n        _this.stop();\n\n        throw exception;\n      }\n    };\n\n    this.layer = cy.cyCanvas();\n    var canvas = this.layer.getCanvas();\n    canvas.style['pointer-events'] = 'none';\n    this.context = canvas.getContext('2d');\n  }\n  /**\n   * Starts the rendering loop, discards any other rendering loop that was started\n   */\n\n\n  _createClass(TrafficRenderer, [{\n    key: \"start\",\n    value: function start(edges) {\n      this.pause();\n      this.trafficEdges = this.processEdges(edges);\n      this.animationTimer = window.setInterval(this.processStep, FRAME_RATE * 1000);\n    }\n    /**\n     * Stops the rendering loop if any\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.animationTimer !== undefined) {\n        window.clearInterval(this.animationTimer);\n        this.layer.clear(this.context);\n        this.animationTimer = undefined;\n        this.previousTimestamp = undefined;\n      }\n    }\n    /**\n     * Stops the rendering loop if any\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.pause();\n      this.trafficEdges = {};\n    }\n    /**\n     * Process a step, clears the canvas, sets the graph transformation to render\n     * every dot.\n     */\n\n  }, {\n    key: \"render\",\n    value:\n    /**\n     * Renders the points inside the TrafficEdge (unless is dimmed)\n     *\n     */\n    function render(trafficEdge) {\n      var _this2 = this;\n\n      var edge = trafficEdge.getEdge();\n\n      if (edge.hasClass(DimClass) || edge.hasClass(HoveredClass)) {\n        return;\n      }\n\n      trafficEdge.getPoints().forEach(function (point) {\n        var controlPoints = _this2.edgeControlPoints(edge);\n\n        try {\n          var pointInGraph = _this2.pointWithOffset(_this2.pointInGraph(controlPoints, point.delta), point.offset);\n\n          if (pointInGraph) {\n            point.renderer.render(_this2.context, pointInGraph);\n          }\n        } catch (error) {\n          console.log(\"Error rendering TrafficEdge, it won't be rendered: \".concat(error.message));\n        }\n      });\n    }\n  }, {\n    key: \"pointInGraph\",\n    value: function pointInGraph(controlPoints, t) {\n      /*\n       * Control points are build so that if you have p0, p1, p2, p3, p4 points, you need to build 2 quadratic bezier:\n       * 1) p0 (t=0), p1 (t=0.5) and p2 (t=1) and 2) p2 (t=0), p3 (t=0.5) and p4 (t=1)\n       * p0 and p4 (or pn) are always the source and target of an edge.\n       * Commonly there is only 2 points for straight lines, 3  points for curves and 5 points for loops.\n       * Not going to generalize them now to avoid having a more complex code that is needed.\n       * https://github.com/cytoscape/cytoscape.js/issues/2139#issuecomment-398473432\n       */\n      var edgeConnectionType = this.edgeConnectionTypeFromControlPoints(controlPoints);\n\n      switch (edgeConnectionType) {\n        case EdgeConnectionType.LINEAR:\n          return linearInterpolation(controlPoints[0], controlPoints[1], t);\n\n        case EdgeConnectionType.CURVE:\n          return quadraticBezier(controlPoints[0], controlPoints[1], controlPoints[2], t);\n\n        case EdgeConnectionType.LOOP:\n          // Find the local t depending the current step\n          if (t < 0.5) {\n            // Normalize [0, 0.5)\n            return quadraticBezier(controlPoints[0], controlPoints[1], controlPoints[2], t / 0.5);\n          } else {\n            // Normalize [0.5, 1]\n            return quadraticBezier(controlPoints[2], controlPoints[3], controlPoints[4], (t - 0.5) * 2);\n          }\n\n        default:\n          throw Error('Unhandled EdgeConnectionType:' + edgeConnectionType);\n      }\n    }\n  }, {\n    key: \"pointWithOffset\",\n    value: function pointWithOffset(point, offset) {\n      return offset === undefined ? point : {\n        x: point.x + offset.x,\n        y: point.y + offset.y\n      };\n    }\n  }, {\n    key: \"currentStep\",\n    value: function currentStep(currentTime) {\n      var step = currentTime - this.previousTimestamp;\n      return step === 0 ? FRAME_RATE * 1000 : step;\n    }\n  }, {\n    key: \"getTrafficEdgeType\",\n    value: function getTrafficEdgeType(edge) {\n      switch (decoratedEdgeData(edge).protocol) {\n        case Protocol.GRPC:\n        case Protocol.HTTP:\n          return TrafficEdgeType.RPS;\n\n        case Protocol.TCP:\n          return TrafficEdgeType.TCP;\n\n        default:\n          return TrafficEdgeType.NONE;\n      }\n    }\n  }, {\n    key: \"processEdges\",\n    value: function processEdges(edges) {\n      var _this3 = this;\n\n      timerConfig.resetCalibration();\n      tcpTimerConfig.resetCalibration(); // Calibrate animation amplitude\n\n      edges.forEach(function (edge) {\n        var edgeData = decoratedEdgeData(edge);\n\n        switch (edgeData.protocol) {\n          case Protocol.GRPC:\n            timerConfig.calibrate(edgeData.grpc);\n            break;\n\n          case Protocol.HTTP:\n            timerConfig.calibrate(edgeData.http);\n            break;\n\n          case Protocol.TCP:\n            tcpTimerConfig.calibrate(edgeData.tcp);\n            break;\n        }\n      }); // Process edges\n\n      return edges.reduce(function (trafficEdges, edge) {\n        var type = _this3.getTrafficEdgeType(edge);\n\n        if (type !== TrafficEdgeType.NONE) {\n          var _edgeId = decoratedEdgeData(edge).id;\n\n          if (_edgeId in _this3.trafficEdges) {\n            trafficEdges[_edgeId] = _this3.trafficEdges[_edgeId];\n          } else {\n            trafficEdges[_edgeId] = new TrafficEdge();\n          }\n\n          trafficEdges[_edgeId].setType(type);\n\n          _this3.fillTrafficEdge(edge, trafficEdges[_edgeId]);\n        }\n\n        return trafficEdges;\n      }, {});\n    }\n  }, {\n    key: \"fillTrafficEdge\",\n    value: function fillTrafficEdge(edge, trafficEdge) {\n      // Need to identify if we are going to fill an RPS or TCP traffic edge\n      // RPS traffic has rate, responseTime, percentErr (among others) where TCP traffic only has: tcpSentRate\n      var edgeLengthFactor = 1;\n\n      try {\n        var edgeLength = this.edgeLength(edge);\n        edgeLengthFactor = BASE_LENGTH / Math.max(edgeLength, 1);\n      } catch (error) {\n        console.error(\"Error when finding the length of the edge for the traffic animation, this TrafficEdge won't be rendered: \".concat(error.message));\n      }\n\n      var edgeData = decoratedEdgeData(edge);\n\n      if (trafficEdge.getType() === TrafficEdgeType.RPS) {\n        var isHttp = edgeData.protocol === Protocol.HTTP;\n        var rate = isHttp ? edgeData.http : edgeData.grpc;\n        var pErr = isHttp ? edgeData.httpPercentErr : edgeData.grpcPercentErr;\n        var timer = timerConfig.computeDelay(rate); // The edge of the length also affects the speed, include a factor in the speed to even visual speed for\n        // long and short edges.\n\n        var speed = this.speedFromResponseTime(edgeData.responseTime) * edgeLengthFactor;\n        var errorRate = isNaN(pErr) ? 0 : pErr / 100;\n        trafficEdge.setSpeed(speed);\n        trafficEdge.setTimer(timer);\n        trafficEdge.setEdge(edge);\n        trafficEdge.setErrorRate(errorRate);\n      } else if (trafficEdge.getType() === TrafficEdgeType.TCP) {\n        trafficEdge.setSpeed(TCP_SPEED * edgeLengthFactor);\n        trafficEdge.setErrorRate(0);\n        trafficEdge.setTimer(tcpTimerConfig.computeDelay(edgeData.tcp));\n        trafficEdge.setEdge(edge);\n      }\n    }\n  }, {\n    key: \"speedFromResponseTime\",\n    value: function speedFromResponseTime(responseTime) {\n      // Consider NaN response time as \"everything is going as fast as possible\"\n      if (isNaN(responseTime)) {\n        return SPEED_RATE_MAX;\n      } // Normalize\n\n\n      var delta = clamp(responseTime, SPEED_RESPONSE_TIME_MIN, SPEED_RESPONSE_TIME_MAX) / SPEED_RESPONSE_TIME_MAX; // Scale\n\n      return SPEED_RATE_MIN + (1 - delta) * (SPEED_RATE_MAX - SPEED_RATE_MIN);\n    }\n  }, {\n    key: \"edgeLength\",\n    value: function edgeLength(edge) {\n      var controlPoints = this.edgeControlPoints(edge);\n      var edgeConnectionType = this.edgeConnectionTypeFromControlPoints(controlPoints);\n\n      switch (edgeConnectionType) {\n        case EdgeConnectionType.LINEAR:\n          return distance(controlPoints[0], controlPoints[1]);\n\n        case EdgeConnectionType.CURVE:\n          return bezierLength(controlPoints[0], controlPoints[1], controlPoints[2]);\n\n        case EdgeConnectionType.LOOP:\n          return bezierLength(controlPoints[0], controlPoints[1], controlPoints[2]) + bezierLength(controlPoints[2], controlPoints[3], controlPoints[4]);\n\n        default:\n          throw Error('Unhandled EdgeConnectionType:' + edgeConnectionType);\n      }\n    }\n  }, {\n    key: \"edgeControlPoints\",\n    value: function edgeControlPoints(edge) {\n      var controlPoints = [edge.sourceEndpoint()];\n      var rawControlPoints = edge.controlPoints();\n\n      if (rawControlPoints) {\n        for (var i = 0; i < rawControlPoints.length; ++i) {\n          controlPoints.push(rawControlPoints[i]); // If there is a next point, we are going to use the midpoint for the next point\n\n          if (i + 1 < rawControlPoints.length) {\n            controlPoints.push({\n              x: (rawControlPoints[i].x + rawControlPoints[i + 1].x) / 2,\n              y: (rawControlPoints[i].y + rawControlPoints[i + 1].y) / 2\n            });\n          }\n        }\n      }\n\n      controlPoints.push(edge.targetEndpoint());\n      return controlPoints;\n    }\n  }, {\n    key: \"edgeConnectionTypeFromControlPoints\",\n    value: function edgeConnectionTypeFromControlPoints(controlPoints) {\n      if (controlPoints.length === 2) {\n        return EdgeConnectionType.LINEAR;\n      } else if (controlPoints.length === 3) {\n        return EdgeConnectionType.CURVE;\n      } else if (controlPoints.length === 5) {\n        return EdgeConnectionType.LOOP;\n      } else {\n        throw Error('Unknown EdgeConnectionType, ControlPoint.length=' + controlPoints.length);\n      }\n    }\n  }]);\n\n  return TrafficRenderer;\n}();\n\nexport { TrafficRenderer as default };","map":{"version":3,"sources":["/root/GraduateProject/src/components/CytoscapeGraph/TrafficAnimation/TrafficRenderer.ts"],"names":["clamp","quadraticBezier","linearInterpolation","distance","bezierLength","DimClass","HoveredClass","PFColorVals","TrafficPointCircleRenderer","TrafficPointConcentricDiamondRenderer","Diamond","decoratedEdgeData","Protocol","timerConfig","tcpTimerConfig","SPEED_RESPONSE_TIME_MIN","SPEED_RESPONSE_TIME_MAX","SPEED_RATE_MIN","SPEED_RATE_MAX","TCP_SPEED","BASE_LENGTH","FRAME_RATE","EdgeConnectionType","TrafficEdgeType","getTrafficPointRendererForRpsError","_edge","White","Danger","getTrafficPointRendererForRpsSuccess","edge","style","getTrafficPointRendererForTcp","Black100","Black500","TrafficPointGenerator","timer","timerForNextPoint","speed","errorRate","type","NONE","step","undefined","Math","random","nextPoint","renderer","offset","isErrorPoint","RPS","TCP","x","y","delta","TrafficEdge","points","generator","map","p","point","processStep","push","setTimer","filter","setSpeed","setErrorRate","setType","TrafficRenderer","cy","animationTimer","previousTimestamp","trafficEdges","layer","context","nextTimestamp","Date","now","currentStep","clear","setTransform","Object","keys","forEach","edgeId","trafficEdge","getEdge","visible","inside","removeFinishedPoints","render","exception","stop","cyCanvas","canvas","getCanvas","getContext","edges","pause","processEdges","window","setInterval","clearInterval","hasClass","getPoints","controlPoints","edgeControlPoints","pointInGraph","pointWithOffset","error","console","log","message","t","edgeConnectionType","edgeConnectionTypeFromControlPoints","LINEAR","CURVE","LOOP","Error","currentTime","protocol","GRPC","HTTP","resetCalibration","edgeData","calibrate","grpc","http","tcp","reduce","getTrafficEdgeType","id","fillTrafficEdge","edgeLengthFactor","edgeLength","max","getType","isHttp","rate","pErr","httpPercentErr","grpcPercentErr","computeDelay","speedFromResponseTime","responseTime","isNaN","setEdge","sourceEndpoint","rawControlPoints","i","length","targetEndpoint"],"mappings":"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","sourcesContent":["import { Point, clamp, quadraticBezier, linearInterpolation, distance, bezierLength } from '../../../utils/MathUtils';\nimport { DimClass, HoveredClass } from '../graphs/GraphStyles';\nimport { PFColorVals } from '../../Pf/PfColors';\nimport {\n  TrafficPointCircleRenderer,\n  TrafficPointConcentricDiamondRenderer,\n  TrafficPointRenderer,\n  Diamond\n} from './TrafficPointRenderer';\nimport { decoratedEdgeData } from '../CytoscapeGraphUtils';\nimport { Protocol } from '../../../types/Graph';\nimport { timerConfig, tcpTimerConfig } from './AnimationTimerConfig';\n\n// Clamp response time from min to max\nconst SPEED_RESPONSE_TIME_MIN = 0;\nconst SPEED_RESPONSE_TIME_MAX = 10000;\n\n// Speed to travel trough an edge\nconst SPEED_RATE_MIN = 0.1;\nconst SPEED_RATE_MAX = 2.0;\n\nconst TCP_SPEED = 1;\n\nconst BASE_LENGTH = 50;\n\n// How often paint a frame\nconst FRAME_RATE = 1 / 60;\n\nenum EdgeConnectionType {\n  LINEAR,\n  CURVE,\n  LOOP\n}\n\nenum TrafficEdgeType {\n  RPS, // requests-per-second (includes http, grpc)\n  TCP, // bytes-per-second\n  NONE\n}\n\n/**\n * Returns a TrafficPointRenderer for an RPS error point\n * @param edge\n * @returns {TrafficPointRenderer}\n */\nconst getTrafficPointRendererForRpsError: (edge: any) => TrafficPointRenderer = (_edge: any) => {\n  return new TrafficPointConcentricDiamondRenderer(\n    new Diamond(5, PFColorVals.White, PFColorVals.Danger, 1.0),\n    new Diamond(2, PFColorVals.Danger, PFColorVals.Danger, 1.0)\n  );\n};\n\n/**\n * Returns a TrafficPointRenderer for a RPS success point\n * @param edge\n * @returns {TrafficPointRenderer}\n */\nconst getTrafficPointRendererForRpsSuccess: (edge: any) => TrafficPointRenderer = (edge: any) => {\n  return new TrafficPointCircleRenderer(2, PFColorVals.White, edge.style('line-color'), 2);\n};\n\n/**\n * Returns a TrafficPointRenderer for a Tcp point\n * @param edge\n * @returns {TrafficPointCircleRenderer}\n */\nconst getTrafficPointRendererForTcp: (edge: any) => TrafficPointRenderer = (_edge: any) => {\n  return new TrafficPointCircleRenderer(1.6, PFColorVals.Black100, PFColorVals.Black500, 1);\n};\n\n/**\n * Traffic Point, it defines in an edge\n * speed - defines how fast the point is going to travel from the start to the end\n *  of the edge. Is a rate of the edge length traveled by second.\n *  1 means that the edge is traveled in exactly 1 second.\n *  0.5 is 2 seconds, 2 is half a second, etc.\n * delta - defines in what part of the edge is the point,  is a normalized number\n *  from 0 to 1, 0 means at the start of the path, and 1 is the end. The position\n *  is interpolated.\n * offset - Offset to add to the rendered point position.\n * renderer - Renderer used to draw the shape at a given position.\n */\ntype TrafficPoint = {\n  speed: number;\n  delta: number;\n  offset: Point;\n  renderer: TrafficPointRenderer;\n};\n\n/**\n * Helps generate traffic points\n * timer - defines how fast to generate a new point, its in milliseconds.\n * timerForNextPoint - keeps track of how many milliseconds to generate the next point.\n * speed - defines the speed of the next point (see TrafficPoint.speed)\n */\nclass TrafficPointGenerator {\n  private timer?: number;\n  private timerForNextPoint?: number;\n  private speed: number = 0;\n  private errorRate: number = 0;\n  private type: TrafficEdgeType = TrafficEdgeType.NONE;\n\n  /**\n   * Process a render step for the generator, decrements the timerForNextPoint and\n   * returns a new point if it reaches zero (or is close).\n   * This method adds some randomness to avoid the \"flat\" look that all the points\n   * are synchronized.\n   */\n  processStep(step: number, edge: any): TrafficPoint | undefined {\n    if (this.timerForNextPoint !== undefined) {\n      this.timerForNextPoint -= step;\n      // Add some random-ness to make it less \"flat\"\n      if (this.timerForNextPoint <= Math.random() * 200) {\n        this.timerForNextPoint = this.timer;\n        return this.nextPoint(edge);\n      }\n    }\n    return undefined;\n  }\n\n  setTimer(timer: number | undefined) {\n    this.timer = timer;\n    // Start as soon as posible, unless we have no traffic\n    if (this.timerForNextPoint === undefined) {\n      this.timerForNextPoint = timer;\n    }\n  }\n\n  setSpeed(speed: number) {\n    this.speed = speed;\n  }\n\n  setErrorRate(errorRate: number) {\n    this.errorRate = errorRate;\n  }\n\n  setType(type: TrafficEdgeType) {\n    this.type = type;\n  }\n\n  private nextPoint(edge: any): TrafficPoint {\n    let renderer;\n    let offset;\n    const isErrorPoint = Math.random() <= this.errorRate;\n    if (this.type === TrafficEdgeType.RPS) {\n      renderer = isErrorPoint ? getTrafficPointRendererForRpsError(edge) : getTrafficPointRendererForRpsSuccess(edge);\n    } else if (this.type === TrafficEdgeType.TCP) {\n      renderer = getTrafficPointRendererForTcp(edge);\n      // Cheap way to put some offset around the edge, I think this is enough unless we want more accuracy\n      // More accuracy would need to identify the slope of current segment of the edgge (for curves and loops) to only do\n      // offsets perpendicular to it, instead of it, we are moving around a circle area\n      // Random offset (x,y); 'x' in [-1.5, 1.5] and 'y' in [-1.5, 1.5]\n      offset = { x: Math.random() * 3 - 1.5, y: Math.random() * 3 - 1.5 };\n    }\n\n    return {\n      speed: this.speed,\n      delta: 0, // at the beginning of the edge\n      renderer: renderer,\n      offset: offset\n    };\n  }\n}\n\n/**\n * Holds the list of points an edge has.\n * points - list of active points the edge has, points are discarded when they\n *  reach their target.\n * generator - Generates the next point\n * edge - Edge where the traffic is tracked\n */\nclass TrafficEdge {\n  private points: Array<TrafficPoint> = [];\n  private generator: TrafficPointGenerator;\n  private edge: any;\n  private type: TrafficEdgeType = TrafficEdgeType.NONE;\n\n  constructor() {\n    this.generator = new TrafficPointGenerator();\n  }\n\n  /**\n   * Process a step for the Traffic Edge, increments the delta of the points\n   * Calls `processStep` for the generator and adds a new point if any.\n   */\n  processStep(step: number) {\n    this.points = this.points.map(p => {\n      p.delta += (step * p.speed) / 1000;\n      return p;\n    });\n    const point = this.generator.processStep(step, this.edge);\n    if (point) {\n      this.points.push(point);\n    }\n  }\n\n  getPoints() {\n    return this.points;\n  }\n\n  getEdge() {\n    return this.edge;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  setTimer(timer: number | undefined) {\n    this.generator.setTimer(timer);\n  }\n\n  /**\n   * When a point is 1 or over it, is time to discard it.\n   */\n  removeFinishedPoints() {\n    this.points = this.points.filter(p => p.delta <= 1);\n  }\n\n  setSpeed(speed: number) {\n    this.generator.setSpeed(speed);\n  }\n\n  setErrorRate(errorRate: number) {\n    this.generator.setErrorRate(errorRate);\n  }\n\n  setEdge(edge: any) {\n    this.edge = edge;\n  }\n\n  setType(type: TrafficEdgeType) {\n    this.type = type;\n    this.generator.setType(type);\n  }\n}\n\ntype TrafficEdgeHash = {\n  [edgeId: string]: TrafficEdge;\n};\n\n/**\n * Renders the traffic going from edges using the edge information to compute\n * their rate and speed\n *\n * rate determines how often to put a TrafficPoint in the edge.\n * responseTime determines how fast the TrafficPoint should travel from the start to the end of the edge.\n * percentErr determine if the next TrafficPoint is error or not.\n */\nexport default class TrafficRenderer {\n  private animationTimer;\n  private previousTimestamp;\n  private trafficEdges: TrafficEdgeHash = {};\n\n  private readonly layer;\n  private readonly context;\n\n  constructor(cy: any) {\n    this.layer = cy.cyCanvas();\n    const canvas = this.layer.getCanvas();\n    canvas.style['pointer-events'] = 'none';\n    this.context = canvas.getContext('2d');\n  }\n\n  /**\n   * Starts the rendering loop, discards any other rendering loop that was started\n   */\n  start(edges: any) {\n    this.pause();\n    this.trafficEdges = this.processEdges(edges);\n    this.animationTimer = window.setInterval(this.processStep, FRAME_RATE * 1000);\n  }\n\n  /**\n   * Stops the rendering loop if any\n   */\n  pause() {\n    if (this.animationTimer !== undefined) {\n      window.clearInterval(this.animationTimer);\n      this.layer.clear(this.context);\n      this.animationTimer = undefined;\n      this.previousTimestamp = undefined;\n    }\n  }\n\n  /**\n   * Stops the rendering loop if any\n   */\n  stop() {\n    this.pause();\n    this.trafficEdges = {};\n  }\n\n  /**\n   * Process a step, clears the canvas, sets the graph transformation to render\n   * every dot.\n   */\n  processStep = () => {\n    try {\n      const nextTimestamp = Date.now();\n      if (!this.previousTimestamp) {\n        this.previousTimestamp = nextTimestamp;\n      }\n      const step = this.currentStep(nextTimestamp);\n      this.layer.clear(this.context);\n      this.layer.setTransform(this.context);\n      Object.keys(this.trafficEdges).forEach(edgeId => {\n        const trafficEdge = this.trafficEdges[edgeId];\n        const edge = trafficEdge.getEdge();\n        // Skip if edge is currently hidden or removed\n        if (edge.visible() && edge.inside()) {\n          trafficEdge.processStep(step);\n          trafficEdge.removeFinishedPoints();\n          this.render(trafficEdge);\n        }\n      });\n      this.previousTimestamp = nextTimestamp;\n    } catch (exception) {\n      // If a step failed, the next step is likely to fail.\n      // Stop the rendering and throw the exception\n      this.stop();\n      throw exception;\n    }\n  };\n\n  /**\n   * Renders the points inside the TrafficEdge (unless is dimmed)\n   *\n   */\n  private render(trafficEdge: TrafficEdge) {\n    const edge = trafficEdge.getEdge();\n    if (edge.hasClass(DimClass) || edge.hasClass(HoveredClass)) {\n      return;\n    }\n    trafficEdge.getPoints().forEach((point: TrafficPoint) => {\n      const controlPoints = this.edgeControlPoints(edge);\n      try {\n        const pointInGraph = this.pointWithOffset(this.pointInGraph(controlPoints, point.delta), point.offset);\n\n        if (pointInGraph) {\n          point.renderer.render(this.context, pointInGraph);\n        }\n      } catch (error) {\n        console.log(`Error rendering TrafficEdge, it won't be rendered: ${error.message}`);\n      }\n    });\n  }\n\n  private pointInGraph(controlPoints: Array<Point>, t: number) {\n    /*\n     * Control points are build so that if you have p0, p1, p2, p3, p4 points, you need to build 2 quadratic bezier:\n     * 1) p0 (t=0), p1 (t=0.5) and p2 (t=1) and 2) p2 (t=0), p3 (t=0.5) and p4 (t=1)\n     * p0 and p4 (or pn) are always the source and target of an edge.\n     * Commonly there is only 2 points for straight lines, 3  points for curves and 5 points for loops.\n     * Not going to generalize them now to avoid having a more complex code that is needed.\n     * https://github.com/cytoscape/cytoscape.js/issues/2139#issuecomment-398473432\n     */\n    const edgeConnectionType = this.edgeConnectionTypeFromControlPoints(controlPoints);\n    switch (edgeConnectionType) {\n      case EdgeConnectionType.LINEAR:\n        return linearInterpolation(controlPoints[0], controlPoints[1], t);\n      case EdgeConnectionType.CURVE:\n        return quadraticBezier(controlPoints[0], controlPoints[1], controlPoints[2], t);\n      case EdgeConnectionType.LOOP:\n        // Find the local t depending the current step\n        if (t < 0.5) {\n          // Normalize [0, 0.5)\n          return quadraticBezier(controlPoints[0], controlPoints[1], controlPoints[2], t / 0.5);\n        } else {\n          // Normalize [0.5, 1]\n          return quadraticBezier(controlPoints[2], controlPoints[3], controlPoints[4], (t - 0.5) * 2);\n        }\n      default:\n        throw Error('Unhandled EdgeConnectionType:' + edgeConnectionType);\n    }\n  }\n\n  private pointWithOffset(point: Point, offset: Point) {\n    return offset === undefined ? point : { x: point.x + offset.x, y: point.y + offset.y };\n  }\n\n  private currentStep(currentTime: number): number {\n    const step = currentTime - this.previousTimestamp;\n    return step === 0 ? FRAME_RATE * 1000 : step;\n  }\n\n  private getTrafficEdgeType(edge: any) {\n    switch (decoratedEdgeData(edge).protocol) {\n      case Protocol.GRPC:\n      case Protocol.HTTP:\n        return TrafficEdgeType.RPS;\n      case Protocol.TCP:\n        return TrafficEdgeType.TCP;\n      default:\n        return TrafficEdgeType.NONE;\n    }\n  }\n\n  private processEdges(edges: any): TrafficEdgeHash {\n    timerConfig.resetCalibration();\n    tcpTimerConfig.resetCalibration();\n    // Calibrate animation amplitude\n    edges.forEach(edge => {\n      const edgeData = decoratedEdgeData(edge);\n      switch (edgeData.protocol) {\n        case Protocol.GRPC:\n          timerConfig.calibrate(edgeData.grpc);\n          break;\n        case Protocol.HTTP:\n          timerConfig.calibrate(edgeData.http);\n          break;\n        case Protocol.TCP:\n          tcpTimerConfig.calibrate(edgeData.tcp);\n          break;\n      }\n    });\n    // Process edges\n    return edges.reduce((trafficEdges: TrafficEdgeHash, edge: any) => {\n      const type = this.getTrafficEdgeType(edge);\n      if (type !== TrafficEdgeType.NONE) {\n        const edgeId = decoratedEdgeData(edge).id;\n        if (edgeId in this.trafficEdges) {\n          trafficEdges[edgeId] = this.trafficEdges[edgeId];\n        } else {\n          trafficEdges[edgeId] = new TrafficEdge();\n        }\n        trafficEdges[edgeId].setType(type);\n        this.fillTrafficEdge(edge, trafficEdges[edgeId]);\n      }\n      return trafficEdges;\n    }, {});\n  }\n\n  private fillTrafficEdge(edge: any, trafficEdge: TrafficEdge) {\n    // Need to identify if we are going to fill an RPS or TCP traffic edge\n    // RPS traffic has rate, responseTime, percentErr (among others) where TCP traffic only has: tcpSentRate\n\n    let edgeLengthFactor = 1;\n    try {\n      const edgeLength = this.edgeLength(edge);\n      edgeLengthFactor = BASE_LENGTH / Math.max(edgeLength, 1);\n    } catch (error) {\n      console.error(\n        `Error when finding the length of the edge for the traffic animation, this TrafficEdge won't be rendered: ${error.message}`\n      );\n    }\n\n    const edgeData = decoratedEdgeData(edge);\n    if (trafficEdge.getType() === TrafficEdgeType.RPS) {\n      const isHttp = edgeData.protocol === Protocol.HTTP;\n      const rate = isHttp ? edgeData.http : edgeData.grpc;\n      const pErr = isHttp ? edgeData.httpPercentErr : edgeData.grpcPercentErr;\n\n      const timer = timerConfig.computeDelay(rate);\n      // The edge of the length also affects the speed, include a factor in the speed to even visual speed for\n      // long and short edges.\n      const speed = this.speedFromResponseTime(edgeData.responseTime) * edgeLengthFactor;\n      const errorRate = isNaN(pErr) ? 0 : pErr / 100;\n      trafficEdge.setSpeed(speed);\n      trafficEdge.setTimer(timer);\n      trafficEdge.setEdge(edge);\n      trafficEdge.setErrorRate(errorRate);\n    } else if (trafficEdge.getType() === TrafficEdgeType.TCP) {\n      trafficEdge.setSpeed(TCP_SPEED * edgeLengthFactor);\n      trafficEdge.setErrorRate(0);\n      trafficEdge.setTimer(tcpTimerConfig.computeDelay(edgeData.tcp));\n      trafficEdge.setEdge(edge);\n    }\n  }\n\n  private speedFromResponseTime(responseTime: number) {\n    // Consider NaN response time as \"everything is going as fast as possible\"\n    if (isNaN(responseTime)) {\n      return SPEED_RATE_MAX;\n    }\n    // Normalize\n    const delta = clamp(responseTime, SPEED_RESPONSE_TIME_MIN, SPEED_RESPONSE_TIME_MAX) / SPEED_RESPONSE_TIME_MAX;\n    // Scale\n    return SPEED_RATE_MIN + (1 - delta) * (SPEED_RATE_MAX - SPEED_RATE_MIN);\n  }\n\n  private edgeLength(edge: any) {\n    const controlPoints = this.edgeControlPoints(edge);\n    const edgeConnectionType = this.edgeConnectionTypeFromControlPoints(controlPoints);\n    switch (edgeConnectionType) {\n      case EdgeConnectionType.LINEAR:\n        return distance(controlPoints[0], controlPoints[1]);\n      case EdgeConnectionType.CURVE:\n        return bezierLength(controlPoints[0], controlPoints[1], controlPoints[2]);\n      case EdgeConnectionType.LOOP:\n        return (\n          bezierLength(controlPoints[0], controlPoints[1], controlPoints[2]) +\n          bezierLength(controlPoints[2], controlPoints[3], controlPoints[4])\n        );\n      default:\n        throw Error('Unhandled EdgeConnectionType:' + edgeConnectionType);\n    }\n  }\n\n  private edgeControlPoints(edge: any) {\n    const controlPoints: Array<Point> = [edge.sourceEndpoint()];\n    const rawControlPoints = edge.controlPoints();\n    if (rawControlPoints) {\n      for (let i = 0; i < rawControlPoints.length; ++i) {\n        controlPoints.push(rawControlPoints[i]);\n        // If there is a next point, we are going to use the midpoint for the next point\n        if (i + 1 < rawControlPoints.length) {\n          controlPoints.push({\n            x: (rawControlPoints[i].x + rawControlPoints[i + 1].x) / 2,\n            y: (rawControlPoints[i].y + rawControlPoints[i + 1].y) / 2\n          });\n        }\n      }\n    }\n    controlPoints.push(edge.targetEndpoint());\n    return controlPoints;\n  }\n\n  private edgeConnectionTypeFromControlPoints(controlPoints: Array<Point>) {\n    if (controlPoints.length === 2) {\n      return EdgeConnectionType.LINEAR;\n    } else if (controlPoints.length === 3) {\n      return EdgeConnectionType.CURVE;\n    } else if (controlPoints.length === 5) {\n      return EdgeConnectionType.LOOP;\n    } else {\n      throw Error('Unknown EdgeConnectionType, ControlPoint.length=' + controlPoints.length);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}