{"ast":null,"code":"import _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BoxByType } from '../../../types/Graph';\nimport { CyNode } from '../CytoscapeGraphUtils';\nimport { DimClass, HoveredClass, HighlightClass } from './GraphStyles'; // When a node or edge is selected we highlight the end-to-end paths (nodes and edges) for which the\n// element participates.  Other nodes and edges are dimmed.\n//\n// When no node or edge is selected, hovering on a node or edge will highlight it and its neighborhood. Other\n// nodes and edges are dimmed.\n//\n// When a box is selected, we will highlight the contained nodes and their related nodes (including edges).\n\nexport var GraphHighlighter = /*#__PURE__*/function () {\n  function GraphHighlighter(cy) {\n    var _this = this;\n\n    _classCallCheck(this, GraphHighlighter);\n\n    this.cy = void 0;\n    this.selected = void 0;\n    this.hovered = void 0;\n\n    this.onClick = function (event) {\n      // ignore clicks on the currently selected element\n      if (_this.selected.summaryTarget === event.summaryTarget) {\n        return;\n      }\n\n      _this.selected = event;\n\n      _this.clearHover();\n\n      _this.unhighlight(); // only highlight when selecting something other than the graph background\n\n\n      if (_this.selected.summaryType !== 'graph') {\n        _this.refresh();\n      }\n    };\n\n    this.clearHover = function () {\n      if (_this.hovered) {\n        _this.hovered.summaryTarget.removeClass(HoveredClass);\n\n        _this.hovered = undefined;\n      }\n    };\n\n    this.onMouseIn = function (event) {\n      // only highlight on hover when the graph is currently selected, otherwise leave the\n      // selected element highlighted\n      if (_this.selected.summaryType === 'graph' && ['node', 'edge', 'box'].indexOf(event.summaryType) !== -1) {\n        _this.hovered = event;\n\n        _this.hovered.summaryTarget.addClass(HoveredClass);\n\n        _this.refresh();\n      }\n    };\n\n    this.onMouseOut = function (event) {\n      if (_this.hovered && _this.hovered.summaryTarget === event.summaryTarget) {\n        _this.clearHover();\n\n        _this.unhighlight();\n      }\n    };\n\n    this.unhighlight = function () {\n      _this.cy.elements(\".\".concat(DimClass)).removeClass(DimClass);\n\n      _this.cy.elements(\".\".concat(HighlightClass)).removeClass(HighlightClass);\n    };\n\n    this.refresh = function () {\n      var highlighted = _this.getHighlighted();\n\n      if (!highlighted.toHighlight) {\n        return;\n      }\n\n      highlighted.toHighlight.addClass(HighlightClass);\n\n      if (highlighted.dimOthers) {\n        _this.cy.elements().difference(highlighted.toHighlight).addClass(DimClass);\n      }\n    };\n\n    this.cy = cy;\n    this.selected = {\n      summaryType: 'graph',\n      summaryTarget: this.cy\n    };\n  } // Need to define these methods using the \"public class fields syntax\", to be able to keep\n  // *this* binded when passing it to events handlers (or use the annoying syntax)\n  // https://reactjs.org/docs/handling-events.html\n\n\n  _createClass(GraphHighlighter, [{\n    key: \"getHighlighted\",\n    value: // Returns the nodes to highlight. Highlighting for a hovered element\n    // is limited to its neighborhood.  Highlighting for a selected element\n    // is extended to full inbound and outbound paths.\n    function getHighlighted() {\n      var isHover = this.selected.summaryType === 'graph';\n      var event = isHover ? this.hovered : this.selected;\n\n      if (event) {\n        switch (event.summaryType) {\n          case 'node':\n            return {\n              toHighlight: this.getNodeHighlight(event.summaryTarget, isHover),\n              dimOthers: true\n            };\n\n          case 'edge':\n            return {\n              toHighlight: this.getEdgeHighlight(event.summaryTarget, isHover),\n              dimOthers: true\n            };\n\n          case 'box':\n            return this.getBoxHighlight(event.summaryTarget, isHover);\n\n          default: // fall through\n\n        }\n      }\n\n      return {\n        toHighlight: undefined,\n        dimOthers: false\n      };\n    }\n  }, {\n    key: \"includeAncestorNodes\",\n    value: function includeAncestorNodes(nodes) {\n      return nodes.reduce(function (all, current) {\n        all = all.add(current);\n\n        if (current.isChild()) {\n          all = all.add(current.ancestors());\n        }\n\n        return all;\n      }, this.cy.collection());\n    }\n  }, {\n    key: \"getNodeHighlight\",\n    value: function getNodeHighlight(node, isHover) {\n      var elems = isHover ? node.closedNeighborhood() : node.predecessors().add(node.successors());\n      return this.includeAncestorNodes(elems.add(node));\n    }\n  }, {\n    key: \"getEdgeHighlight\",\n    value: function getEdgeHighlight(edge, isHover) {\n      var elems;\n\n      if (isHover) {\n        elems = edge.connectedNodes();\n      } else {\n        var source = edge.source();\n        var target = edge.target();\n        elems = source.add(target).add(source.predecessors()).add(target.successors());\n      }\n\n      return this.includeAncestorNodes(elems.add(edge));\n    }\n  }, {\n    key: \"getBoxHighlight\",\n    value: function getBoxHighlight(box, isHover) {\n      // treat App boxes in a typical way, but to reduce \"flashing\", Namespace and Cluster\n      // boxes highlight themselves and there anscestors.\n      if (box.data(CyNode.isBox) === BoxByType.APP) {\n        var elems;\n\n        if (isHover) {\n          elems = box.descendants().reduce(function (prev, child) {\n            return prev.add(child.closedNeighborhood());\n          }, this.cy.collection());\n        } else {\n          var children = box.descendants();\n          elems = children.add(children.predecessors()).add(children.successors());\n        }\n\n        return {\n          toHighlight: this.includeAncestorNodes(elems),\n          dimOthers: true\n        };\n      }\n\n      return {\n        toHighlight: this.includeAncestorNodes(box),\n        dimOthers: false\n      };\n    }\n  }]);\n\n  return GraphHighlighter;\n}();","map":{"version":3,"sources":["/root/GraduateProject/src/components/CytoscapeGraph/graphs/GraphHighlighter.ts"],"names":["BoxByType","CyNode","DimClass","HoveredClass","HighlightClass","GraphHighlighter","cy","selected","hovered","onClick","event","summaryTarget","clearHover","unhighlight","summaryType","refresh","removeClass","undefined","onMouseIn","indexOf","addClass","onMouseOut","elements","highlighted","getHighlighted","toHighlight","dimOthers","difference","isHover","getNodeHighlight","getEdgeHighlight","getBoxHighlight","nodes","reduce","all","current","add","isChild","ancestors","collection","node","elems","closedNeighborhood","predecessors","successors","includeAncestorNodes","edge","connectedNodes","source","target","box","data","isBox","APP","descendants","prev","child","children"],"mappings":"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","sourcesContent":["import { BoxByType, CytoscapeClickEvent, CytoscapeMouseInEvent, CytoscapeMouseOutEvent } from '../../../types/Graph';\nimport { CyNode } from '../CytoscapeGraphUtils';\nimport { DimClass, HoveredClass, HighlightClass } from './GraphStyles';\n\n// When a node or edge is selected we highlight the end-to-end paths (nodes and edges) for which the\n// element participates.  Other nodes and edges are dimmed.\n//\n// When no node or edge is selected, hovering on a node or edge will highlight it and its neighborhood. Other\n// nodes and edges are dimmed.\n//\n// When a box is selected, we will highlight the contained nodes and their related nodes (including edges).\nexport class GraphHighlighter {\n  cy: any;\n  selected: CytoscapeClickEvent;\n  hovered?: CytoscapeMouseInEvent;\n\n  constructor(cy: any) {\n    this.cy = cy;\n    this.selected = {\n      summaryType: 'graph',\n      summaryTarget: this.cy\n    };\n  }\n\n  // Need to define these methods using the \"public class fields syntax\", to be able to keep\n  // *this* binded when passing it to events handlers (or use the annoying syntax)\n  // https://reactjs.org/docs/handling-events.html\n  onClick = (event: CytoscapeClickEvent) => {\n    // ignore clicks on the currently selected element\n    if (this.selected.summaryTarget === event.summaryTarget) {\n      return;\n    }\n\n    this.selected = event;\n    this.clearHover();\n    this.unhighlight();\n\n    // only highlight when selecting something other than the graph background\n    if (this.selected.summaryType !== 'graph') {\n      this.refresh();\n    }\n  };\n\n  clearHover = () => {\n    if (this.hovered) {\n      this.hovered.summaryTarget.removeClass(HoveredClass);\n      this.hovered = undefined;\n    }\n  };\n\n  onMouseIn = (event: CytoscapeMouseInEvent) => {\n    // only highlight on hover when the graph is currently selected, otherwise leave the\n    // selected element highlighted\n    if (this.selected.summaryType === 'graph' && ['node', 'edge', 'box'].indexOf(event.summaryType) !== -1) {\n      this.hovered = event;\n      this.hovered.summaryTarget.addClass(HoveredClass);\n      this.refresh();\n    }\n  };\n\n  onMouseOut = (event: CytoscapeMouseOutEvent) => {\n    if (this.hovered && this.hovered.summaryTarget === event.summaryTarget) {\n      this.clearHover();\n      this.unhighlight();\n    }\n  };\n\n  unhighlight = () => {\n    this.cy.elements(`.${DimClass}`).removeClass(DimClass);\n    this.cy.elements(`.${HighlightClass}`).removeClass(HighlightClass);\n  };\n\n  refresh = () => {\n    const highlighted = this.getHighlighted();\n    if (!highlighted.toHighlight) {\n      return;\n    }\n\n    highlighted.toHighlight.addClass(HighlightClass);\n\n    if (highlighted.dimOthers) {\n      this.cy.elements().difference(highlighted.toHighlight).addClass(DimClass);\n    }\n  };\n\n  // Returns the nodes to highlight. Highlighting for a hovered element\n  // is limited to its neighborhood.  Highlighting for a selected element\n  // is extended to full inbound and outbound paths.\n  getHighlighted(): { toHighlight: any; dimOthers: boolean } {\n    const isHover = this.selected.summaryType === 'graph';\n    const event = isHover ? this.hovered : this.selected;\n    if (event) {\n      switch (event.summaryType) {\n        case 'node':\n          return { toHighlight: this.getNodeHighlight(event.summaryTarget, isHover), dimOthers: true };\n        case 'edge':\n          return { toHighlight: this.getEdgeHighlight(event.summaryTarget, isHover), dimOthers: true };\n        case 'box':\n          return this.getBoxHighlight(event.summaryTarget, isHover);\n        default:\n        // fall through\n      }\n    }\n    return { toHighlight: undefined, dimOthers: false };\n  }\n\n  includeAncestorNodes(nodes: any) {\n    return nodes.reduce((all, current) => {\n      all = all.add(current);\n      if (current.isChild()) {\n        all = all.add(current.ancestors());\n      }\n      return all;\n    }, this.cy.collection());\n  }\n\n  getNodeHighlight(node: any, isHover: boolean) {\n    const elems = isHover ? node.closedNeighborhood() : node.predecessors().add(node.successors());\n    return this.includeAncestorNodes(elems.add(node));\n  }\n\n  getEdgeHighlight(edge: any, isHover: boolean) {\n    let elems;\n    if (isHover) {\n      elems = edge.connectedNodes();\n    } else {\n      const source = edge.source();\n      const target = edge.target();\n      elems = source.add(target).add(source.predecessors()).add(target.successors());\n    }\n    return this.includeAncestorNodes(elems.add(edge));\n  }\n\n  getBoxHighlight(box: any, isHover: boolean): { toHighlight: any; dimOthers: boolean } {\n    // treat App boxes in a typical way, but to reduce \"flashing\", Namespace and Cluster\n    // boxes highlight themselves and there anscestors.\n    if (box.data(CyNode.isBox) === BoxByType.APP) {\n      let elems;\n      if (isHover) {\n        elems = box.descendants().reduce((prev, child) => {\n          return prev.add(child.closedNeighborhood());\n        }, this.cy.collection());\n      } else {\n        const children = box.descendants();\n        elems = children.add(children.predecessors()).add(children.successors());\n      }\n      return { toHighlight: this.includeAncestorNodes(elems), dimOthers: true };\n    }\n    return { toHighlight: this.includeAncestorNodes(box), dimOthers: false };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}