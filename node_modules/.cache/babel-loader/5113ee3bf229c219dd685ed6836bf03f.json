{"ast":null,"code":"import _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { PFColorVals } from '../Pf/PfColors'; // How fast refresh (frame rate)\n\nvar FRAME_RATE = 1 / 30; // Radio of the biggest circle (i.e. when it starts)\n\nvar MAX_RADIO = 60;\nvar LINE_WIDTH = 1; // Time the animation will take in ms\n\nvar ANIMATION_DURATION = 2000;\n\nvar FocusAnimation = /*#__PURE__*/function () {\n  function FocusAnimation(cy) {\n    var _this = this;\n\n    _classCallCheck(this, FocusAnimation);\n\n    this.animationTimer = void 0;\n    this.startTimestamp = void 0;\n    this.elements = void 0;\n    this.onFinishedCallback = void 0;\n    this.layer = void 0;\n    this.context = void 0;\n\n    this.processStep = function () {\n      try {\n        var current = Date.now();\n\n        if (_this.startTimestamp === undefined) {\n          _this.startTimestamp = current;\n        }\n\n        var step = (current - _this.startTimestamp) / ANIMATION_DURATION;\n\n        _this.layer.clear(_this.context);\n\n        _this.layer.setTransform(_this.context);\n\n        if (step >= 1) {\n          _this.stop();\n\n          if (_this.onFinishedCallback) {\n            _this.onFinishedCallback();\n          }\n\n          return;\n        }\n\n        _this.elements.forEach(function (element) {\n          return _this.render(element, _this.easingFunction(step) * MAX_RADIO);\n        });\n      } catch (exception) {\n        // If a step failed, the next step is likely to fail.\n        // Stop the rendering and throw the exception\n        _this.stop();\n\n        throw exception;\n      }\n    };\n\n    this.layer = cy.cyCanvas();\n    this.context = this.layer.getCanvas().getContext('2d');\n    cy.one('destroy', function () {\n      return _this.stop();\n    });\n  }\n\n  _createClass(FocusAnimation, [{\n    key: \"onFinished\",\n    value: function onFinished(onFinishedCallback) {\n      this.onFinishedCallback = onFinishedCallback;\n    }\n  }, {\n    key: \"start\",\n    value: function start(elements) {\n      this.stop();\n      this.elements = elements;\n      this.animationTimer = window.setInterval(this.processStep, FRAME_RATE * 1000);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.animationTimer) {\n        window.clearInterval(this.animationTimer);\n        this.animationTimer = undefined;\n        this.clear();\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.layer.clear(this.context);\n    } // This methods needs to be an arrow function.\n    // the reason is that we call this method from a window.setInterval and having an arrow function is a way to preserve\n    // \"this\".\n\n  }, {\n    key: \"easingFunction\",\n    value: function easingFunction(t) {\n      // Do a focus animation in, out and in again.\n      // Make the first focus slower and the subsequent bit faster\n      if (t < 0.5) {\n        // %50 of the time is spent on the first in\n        return 1 - t * 2;\n      } else if (t < 0.75) {\n        // 25% is spent in the out animation\n        return (t - 0.5) * 4;\n      }\n\n      return 1 - (t - 0.75) * 4; // 25% is spent in the second in\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(element) {\n      if (element.isNode()) {\n        return element.position();\n      } else {\n        return element.midpoint();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(element, radio) {\n      var _this$getCenter = this.getCenter(element),\n          x = _this$getCenter.x,\n          y = _this$getCenter.y;\n\n      this.context.strokeStyle = PFColorVals.Blue300;\n      this.context.lineWidth = LINE_WIDTH;\n      this.context.beginPath();\n      this.context.arc(x, y, radio, 0, 2 * Math.PI, true);\n      this.context.stroke();\n    }\n  }]);\n\n  return FocusAnimation;\n}();\n\nexport { FocusAnimation as default };","map":{"version":3,"sources":["/root/kiali-ui/src/components/CytoscapeGraph/FocusAnimation.ts"],"names":["PFColorVals","FRAME_RATE","MAX_RADIO","LINE_WIDTH","ANIMATION_DURATION","FocusAnimation","cy","animationTimer","startTimestamp","elements","onFinishedCallback","layer","context","processStep","current","Date","now","undefined","step","clear","setTransform","stop","forEach","element","render","easingFunction","exception","cyCanvas","getCanvas","getContext","one","window","setInterval","clearInterval","t","isNode","position","midpoint","radio","getCenter","x","y","strokeStyle","Blue300","lineWidth","beginPath","arc","Math","PI","stroke"],"mappings":"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","sourcesContent":["import { PFColorVals } from '../Pf/PfColors';\n\n// How fast refresh (frame rate)\nconst FRAME_RATE = 1 / 30;\n// Radio of the biggest circle (i.e. when it starts)\nconst MAX_RADIO = 60;\nconst LINE_WIDTH = 1;\n\n// Time the animation will take in ms\nconst ANIMATION_DURATION = 2000;\n\ntype OnFinishedCallback = () => void;\n\nexport default class FocusAnimation {\n  private animationTimer;\n  private startTimestamp;\n  private elements;\n  private onFinishedCallback?: OnFinishedCallback;\n\n  private readonly layer;\n  private readonly context;\n\n  constructor(cy: any) {\n    this.layer = cy.cyCanvas();\n    this.context = this.layer.getCanvas().getContext('2d');\n\n    cy.one('destroy', () => this.stop());\n  }\n\n  onFinished(onFinishedCallback: OnFinishedCallback) {\n    this.onFinishedCallback = onFinishedCallback;\n  }\n\n  start(elements: any) {\n    this.stop();\n    this.elements = elements;\n    this.animationTimer = window.setInterval(this.processStep, FRAME_RATE * 1000);\n  }\n\n  stop() {\n    if (this.animationTimer) {\n      window.clearInterval(this.animationTimer);\n      this.animationTimer = undefined;\n      this.clear();\n    }\n  }\n\n  clear() {\n    this.layer.clear(this.context);\n  }\n\n  // This methods needs to be an arrow function.\n  // the reason is that we call this method from a window.setInterval and having an arrow function is a way to preserve\n  // \"this\".\n  processStep = () => {\n    try {\n      const current = Date.now();\n      if (this.startTimestamp === undefined) {\n        this.startTimestamp = current;\n      }\n      const step = (current - this.startTimestamp) / ANIMATION_DURATION;\n      this.layer.clear(this.context);\n      this.layer.setTransform(this.context);\n\n      if (step >= 1) {\n        this.stop();\n        if (this.onFinishedCallback) {\n          this.onFinishedCallback();\n        }\n        return;\n      }\n\n      this.elements.forEach(element => this.render(element, this.easingFunction(step) * MAX_RADIO));\n    } catch (exception) {\n      // If a step failed, the next step is likely to fail.\n      // Stop the rendering and throw the exception\n      this.stop();\n      throw exception;\n    }\n  };\n\n  private easingFunction(t: number) {\n    // Do a focus animation in, out and in again.\n    // Make the first focus slower and the subsequent bit faster\n    if (t < 0.5) {\n      // %50 of the time is spent on the first in\n      return 1 - t * 2;\n    } else if (t < 0.75) {\n      // 25% is spent in the out animation\n      return (t - 0.5) * 4;\n    }\n    return 1 - (t - 0.75) * 4; // 25% is spent in the second in\n  }\n\n  private getCenter(element: any) {\n    if (element.isNode()) {\n      return element.position();\n    } else {\n      return element.midpoint();\n    }\n  }\n\n  private render(element: any, radio: number) {\n    const { x, y } = this.getCenter(element);\n    this.context.strokeStyle = PFColorVals.Blue300;\n    this.context.lineWidth = LINE_WIDTH;\n    this.context.beginPath();\n    this.context.arc(x, y, radio, 0, 2 * Math.PI, true);\n    this.context.stroke();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}