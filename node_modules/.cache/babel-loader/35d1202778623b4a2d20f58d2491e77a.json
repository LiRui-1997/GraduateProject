{"ast":null,"code":"import _createForOfIteratorHelper from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _objectSpread from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nvar _jsxFileName = \"/root/GraduateProject/src/pages/Graph/SummaryPanelNodeTraffic.tsx\";\nimport * as React from 'react';\nimport { getAccumulatedTrafficRateGrpc, getAccumulatedTrafficRateHttp, getTrafficRateGrpc, getTrafficRateHttp } from '../../utils/TrafficRate';\nimport { InOutRateTableGrpc, InOutRateTableHttp } from '../../components/SummaryPanel/InOutRateTable';\nimport { RequestChart, StreamChart } from '../../components/SummaryPanel/RpsChart';\nimport { GraphType, NodeType, Protocol, UNKNOWN, TrafficRate } from '../../types/Graph';\nimport { shouldRefreshData, NodeMetricType, getDatapoints, getNodeMetrics, getNodeMetricType, renderNoTraffic, mergeMetricsResponses, hr } from './SummaryPanelCommon';\nimport { makeCancelablePromise } from '../../utils/CancelablePromises';\nimport { CyNode, decoratedNodeData } from '../../components/CytoscapeGraph/CytoscapeGraphUtils';\nimport { KialiIcon } from 'config/KialiIcon';\nvar defaultMetricsState = {\n  grpcRequestCountIn: [],\n  grpcRequestCountOut: [],\n  grpcErrorCountIn: [],\n  grpcErrorCountOut: [],\n  grpcSentIn: [],\n  grpcSentOut: [],\n  grpcReceivedIn: [],\n  grpcReceivedOut: [],\n  httpRequestCountIn: [],\n  httpRequestCountOut: [],\n  httpErrorCountIn: [],\n  httpErrorCountOut: [],\n  tcpSentIn: [],\n  tcpSentOut: [],\n  tcpReceivedIn: [],\n  tcpReceivedOut: []\n};\n\nvar defaultState = _objectSpread({\n  node: null,\n  loading: false,\n  metricsLoadError: null\n}, defaultMetricsState);\n\nexport var SummaryPanelNodeTraffic = /*#__PURE__*/function (_React$Component) {\n  _inherits(SummaryPanelNodeTraffic, _React$Component);\n\n  var _super = _createSuper(SummaryPanelNodeTraffic);\n\n  function SummaryPanelNodeTraffic(props) {\n    var _this;\n\n    _classCallCheck(this, SummaryPanelNodeTraffic);\n\n    _this = _super.call(this, props);\n    _this.metricsPromise = void 0;\n\n    _this.isActiveNamespace = function (namespace) {\n      if (!namespace) {\n        return false;\n      }\n\n      var _iterator = _createForOfIteratorHelper(_this.props.namespaces),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ns = _step.value;\n\n          if (ns.name === namespace) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    };\n\n    _this.renderGrpcRates = function (node) {\n      var inbound = getTrafficRateGrpc(node);\n      var outbound = getAccumulatedTrafficRateGrpc(_this.props.data.summaryTarget.edgesTo('*'));\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InOutRateTableGrpc, {\n        title: \"gRPC Traffic (requests per second):\",\n        inRate: inbound.rate,\n        inRateGrpcErr: inbound.rateGrpcErr,\n        inRateNR: inbound.rateNoResponse,\n        outRate: outbound.rate,\n        outRateGrpcErr: outbound.rateGrpcErr,\n        outRateNR: outbound.rateNoResponse,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 396,\n          columnNumber: 9\n        }\n      }));\n    };\n\n    _this.renderHttpRates = function (node) {\n      var inbound = getTrafficRateHttp(node);\n      var outbound = getAccumulatedTrafficRateHttp(_this.props.data.summaryTarget.edgesTo('*'));\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InOutRateTableHttp, {\n        title: \"HTTP (requests per second):\",\n        inRate: inbound.rate,\n        inRate3xx: inbound.rate3xx,\n        inRate4xx: inbound.rate4xx,\n        inRate5xx: inbound.rate5xx,\n        inRateNR: inbound.rateNoResponse,\n        outRate: outbound.rate,\n        outRate3xx: outbound.rate3xx,\n        outRate4xx: outbound.rate4xx,\n        outRate5xx: outbound.rate5xx,\n        outRateNR: outbound.rateNoResponse,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 415,\n          columnNumber: 9\n        }\n      }));\n    };\n\n    _this.renderSparklines = function (node) {\n      var nodeData = decoratedNodeData(node);\n\n      if (NodeType.UNKNOWN === nodeData.nodeType) {\n        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 438,\n            columnNumber: 11\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 439,\n            columnNumber: 13\n          }\n        }), \" Sparkline charts not supported for unknown node. Use edge for details.\"));\n      } else if (nodeData.isInaccessible) {\n        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 446,\n            columnNumber: 11\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 447,\n            columnNumber: 13\n          }\n        }), \" Sparkline charts cannot be shown because the selected node is inaccessible.\"));\n      } else if (nodeData.isServiceEntry) {\n        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 454,\n            columnNumber: 11\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 455,\n            columnNumber: 13\n          }\n        }), \" Sparkline charts cannot be shown because the selected node is a serviceEntry.\"));\n      }\n\n      if (_this.state.loading) {\n        return /*#__PURE__*/React.createElement(\"strong\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 461,\n            columnNumber: 14\n          }\n        }, \"Loading charts...\");\n      }\n\n      if (_this.state.metricsLoadError) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 465,\n            columnNumber: 9\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Warning, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 466,\n            columnNumber: 11\n          }\n        }), \" \", /*#__PURE__*/React.createElement(\"strong\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 466,\n            columnNumber: 33\n          }\n        }, \"Error loading metrics: \"), _this.state.metricsLoadError);\n      }\n\n      var isServiceNode = nodeData.nodeType === NodeType.SERVICE;\n      var isInOutSameNode = isServiceNode || nodeData.nodeType === NodeType.AGGREGATE;\n      var serviceWithUnknownSource = false;\n\n      if (isServiceNode) {\n        node.incomers().forEach(function (n) {\n          if (NodeType.UNKNOWN === n.data(CyNode.nodeType)) {\n            serviceWithUnknownSource = true;\n            return false; // Equivalent of break for cytoscapejs forEach API\n          }\n\n          return undefined; // Every code paths needs to return something to avoid the wrath of the linter.\n        });\n      }\n\n      var grpcCharts, httpCharts, tcpCharts;\n\n      if (_this.hasGrpcTraffic(nodeData)) {\n        grpcCharts = _this.isGrpcRequests() ? /*#__PURE__*/React.createElement(React.Fragment, null, _this.hasGrpcIn(nodeData) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RequestChart, {\n          label: isInOutSameNode ? 'gRPC - Request Traffic' : 'gRPC - Inbound Request Traffic',\n          dataRps: _this.state.grpcRequestCountIn,\n          dataErrors: _this.state.grpcErrorCountIn,\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 492,\n            columnNumber: 15\n          }\n        }), serviceWithUnknownSource && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 499,\n            columnNumber: 19\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 500,\n            columnNumber: 21\n          }\n        }), \" Traffic from unknown not included. Use edge for details.\"))), _this.hasGrpcIn(nodeData) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RequestChart, {\n          label: \"gRPC - Outbound Request Traffic\",\n          dataRps: _this.state.grpcRequestCountOut,\n          dataErrors: _this.state.grpcErrorCountOut,\n          hide: isInOutSameNode,\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 508,\n            columnNumber: 15\n          }\n        }), _this.isIstioOutboundCornerCase(node) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 516,\n            columnNumber: 19\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 517,\n            columnNumber: 21\n          }\n        }), \" Traffic to Istio namespaces not included. Use edge for details.\")))) : /*#__PURE__*/React.createElement(React.Fragment, null, _this.hasGrpcIn(nodeData) && /*#__PURE__*/React.createElement(StreamChart, {\n          label: isInOutSameNode ? 'gRPC - Traffic' : 'gRPC - Inbound Traffic',\n          receivedRates: _this.state.grpcReceivedIn,\n          sentRates: _this.state.grpcSentIn,\n          unit: \"messages\",\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 527,\n            columnNumber: 13\n          }\n        }), _this.hasGrpcOut(nodeData) && /*#__PURE__*/React.createElement(StreamChart, {\n          label: \"gRPC - Outbound Traffic\",\n          receivedRates: _this.state.grpcReceivedOut,\n          sentRates: _this.state.grpcSentOut,\n          hide: isInOutSameNode,\n          unit: \"messages\",\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 535,\n            columnNumber: 13\n          }\n        }));\n      }\n\n      if (_this.hasHttpTraffic(nodeData)) {\n        httpCharts = /*#__PURE__*/React.createElement(React.Fragment, null, _this.hasHttpIn(nodeData) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RequestChart, {\n          label: isInOutSameNode ? 'HTTP - Request Traffic' : 'HTTP - Inbound Request Traffic',\n          dataRps: _this.state.httpRequestCountIn,\n          dataErrors: _this.state.httpErrorCountIn,\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 552,\n            columnNumber: 15\n          }\n        }), serviceWithUnknownSource && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 559,\n            columnNumber: 19\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 560,\n            columnNumber: 21\n          }\n        }), \" Traffic from unknown not included. Use edge for details.\"))), _this.hasHttpOut(nodeData) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RequestChart, {\n          label: \"HTTP - Outbound Request Traffic\",\n          dataRps: _this.state.httpRequestCountOut,\n          dataErrors: _this.state.httpErrorCountOut,\n          hide: isInOutSameNode,\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 568,\n            columnNumber: 15\n          }\n        }), _this.isIstioOutboundCornerCase(node) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 576,\n            columnNumber: 19\n          }\n        }, /*#__PURE__*/React.createElement(KialiIcon.Info, {\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 577,\n            columnNumber: 21\n          }\n        }), \"\\\" Traffic to Istio namespaces not included. Use edge for details.\"))));\n      }\n\n      if (_this.hasTcpTraffic(nodeData)) {\n        tcpCharts = /*#__PURE__*/React.createElement(React.Fragment, null, _this.hasTcpIn(nodeData) && /*#__PURE__*/React.createElement(StreamChart, {\n          label: isInOutSameNode ? 'TCP - Traffic' : 'TCP - Inbound Traffic',\n          receivedRates: _this.state.tcpReceivedIn,\n          sentRates: _this.state.tcpSentIn,\n          unit: \"bytes\",\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 591,\n            columnNumber: 13\n          }\n        }), _this.hasTcpOut(nodeData) && /*#__PURE__*/React.createElement(StreamChart, {\n          label: \"TCP - Outbound Traffic\",\n          receivedRates: _this.state.tcpReceivedOut,\n          sentRates: _this.state.tcpSentOut,\n          hide: isInOutSameNode,\n          unit: \"bytes\",\n          __self: _assertThisInitialized(_this),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 599,\n            columnNumber: 13\n          }\n        }));\n      }\n\n      return /*#__PURE__*/React.createElement(React.Fragment, null, grpcCharts, httpCharts, tcpCharts);\n    };\n\n    _this.isServiceDestCornerCase = function (nodeMetricType) {\n      return nodeMetricType === NodeMetricType.SERVICE && !_this.props.injectServiceNodes && _this.props.graphType !== GraphType.SERVICE;\n    };\n\n    _this.isIstioOutboundCornerCase = function (node) {\n      var nodeData = decoratedNodeData(node);\n\n      if (nodeData.nodeType === NodeType.UNKNOWN || nodeData.isIstio) {\n        return false;\n      }\n\n      return node.edgesTo(\"node[?\".concat(CyNode.isIstio, \"]\")).size() > 0;\n    };\n\n    _this.hasGrpcTraffic = function (data) {\n      return _this.hasGrpcIn(data) || _this.hasGrpcOut(data);\n    };\n\n    _this.isGrpcRequests = function () {\n      return _this.props.trafficRates.includes(TrafficRate.GRPC_REQUEST);\n    };\n\n    _this.hasHttpTraffic = function (data) {\n      return _this.hasHttpIn(data) || _this.hasHttpOut(data);\n    };\n\n    _this.hasTcpTraffic = function (data) {\n      return _this.hasTcpIn(data) || _this.hasTcpOut(data);\n    };\n\n    _this.hasGrpcIn = function (data) {\n      return data.grpcIn > 0;\n    };\n\n    _this.hasHttpIn = function (data) {\n      return data.httpIn > 0;\n    };\n\n    _this.hasTcpIn = function (data) {\n      return data.tcpIn > 0;\n    };\n\n    _this.hasGrpcOut = function (data) {\n      return data.grpcOut > 0;\n    };\n\n    _this.hasHttpOut = function (data) {\n      return data.httpOut > 0;\n    };\n\n    _this.hasTcpOut = function (data) {\n      return data.tcpOut > 0;\n    };\n\n    _this.showTrafficMetrics = _this.showTrafficMetrics.bind(_assertThisInitialized(_this));\n    _this.state = _objectSpread({}, defaultState);\n    return _this;\n  }\n\n  _createClass(SummaryPanelNodeTraffic, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.updateCharts(this.props);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (shouldRefreshData(prevProps, this.props)) {\n        this.updateCharts(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.metricsPromise) {\n        this.metricsPromise.cancel();\n      }\n    }\n  }, {\n    key: \"updateCharts\",\n    value: function updateCharts(props) {\n      var _this2 = this;\n\n      var target = props.data.summaryTarget;\n      var nodeData = decoratedNodeData(target);\n      var nodeMetricType = getNodeMetricType(nodeData);\n      var isGrpcRequests = this.isGrpcRequests();\n\n      if (this.metricsPromise) {\n        this.metricsPromise.cancel();\n        this.metricsPromise = undefined;\n      }\n\n      if (!this.hasGrpcTraffic(nodeData) && !this.hasHttpTraffic(nodeData) && !this.hasTcpTraffic(nodeData)) {\n        this.setState({\n          loading: false\n        });\n        return;\n      } // If destination node is inaccessible, we cannot query the data.\n\n\n      if (nodeData.isInaccessible) {\n        this.setState({\n          loading: false\n        });\n        return;\n      }\n\n      var promiseIn = Promise.resolve({\n        data: {}\n      });\n      var promiseOut = Promise.resolve({\n        data: {}\n      }); // set inbound unless it is a root (because they have no inbound edges)\n\n      if (!nodeData.isRoot) {\n        var isServiceDestCornerCase = this.isServiceDestCornerCase(nodeMetricType);\n        var promiseRps = Promise.resolve({\n          data: {}\n        });\n        var promiseStream = Promise.resolve({\n          data: {}\n        });\n\n        if (this.hasHttpIn(nodeData) || this.hasGrpcIn(nodeData) && isGrpcRequests) {\n          var filtersRps = ['request_count', 'request_error_count']; // use dest metrics for inbound, except for service nodes which need source metrics to capture source errors\n\n          var reporter = nodeData.nodeType === NodeType.SERVICE && nodeData.isIstio ? 'source' : 'destination'; // For special service dest nodes we want to narrow the data to only TS with 'unknown' workloads (see the related\n          // comparator in getNodeDatapoints).\n\n          var byLabelsRps = isServiceDestCornerCase ? ['destination_workload', 'request_protocol'] : ['request_protocol'];\n\n          if (nodeData.isOutside) {\n            byLabelsRps.push('source_workload_namespace');\n          }\n\n          promiseRps = getNodeMetrics(nodeMetricType, target, props, filtersRps, 'inbound', reporter, undefined, undefined, byLabelsRps);\n        } // Aggregate nodes currently only deal with request traffic\n\n\n        if (nodeData.nodeType !== NodeType.AGGREGATE) {\n          var filtersStream = [];\n\n          if (this.hasGrpcIn(nodeData)) {\n            filtersStream.push('grpc_sent', 'grpc_received');\n          }\n\n          if (this.hasTcpIn(nodeData)) {\n            filtersStream.push('tcp_sent', 'tcp_received');\n          }\n\n          if (filtersStream.length > 0) {\n            var byLabelsStream = isServiceDestCornerCase ? ['destination_workload'] : [];\n\n            if (nodeData.isOutside) {\n              byLabelsStream.push('source_workload_namespace');\n            }\n\n            promiseStream = getNodeMetrics(nodeMetricType, target, props, filtersStream, 'inbound', 'source', undefined, undefined, byLabelsStream);\n          }\n        }\n\n        promiseIn = mergeMetricsResponses([promiseRps, promiseStream]);\n      } // Ignore outbound traffic if it is a non-root outsider (because they have no outbound edges) or a\n      // service node or aggregate node (because they don't have \"real\" outbound edges).\n\n\n      if (!([NodeType.SERVICE, NodeType.AGGREGATE].includes(nodeData.nodeType) || nodeData.isOutside && !nodeData.isRoot)) {\n        var filters = [];\n\n        if (this.hasHttpOut(nodeData) || this.hasGrpcOut(nodeData) && isGrpcRequests) {\n          filters.push('request_count', 'request_error_count');\n        }\n\n        if (this.hasGrpcOut(nodeData) && !isGrpcRequests) {\n          filters.push('grpc_sent', 'grpc_received');\n        }\n\n        if (this.hasTcpOut(nodeData)) {\n          filters.push('tcp_sent', 'tcp_received');\n        }\n\n        if (filters.length > 0) {\n          // use source metrics for outbound, except for:\n          // - unknown nodes (no source telemetry)\n          // - istio namespace nodes (no source telemetry)\n          var _reporter = nodeData.nodeType === NodeType.UNKNOWN || nodeData.isIstio ? 'destination' : 'source'; // note: request_protocol is not a valid byLabel for tcp filters but it is ignored by prometheus\n\n\n          var byLabels = nodeData.isOutside ? ['destination_service_namespace', 'request_protocol'] : ['request_protocol'];\n          promiseOut = getNodeMetrics(nodeMetricType, target, props, filters, 'outbound', _reporter, undefined, undefined, byLabels);\n        }\n      }\n\n      this.metricsPromise = makeCancelablePromise(Promise.all([promiseOut, promiseIn]));\n      this.metricsPromise.promise.then(function (responses) {\n        _this2.showTrafficMetrics(responses[0].data, responses[1].data, nodeData, nodeMetricType);\n      }).catch(function (error) {\n        if (error.isCanceled) {\n          console.debug('SummaryPanelNode: Ignore fetch error (canceled).');\n          return;\n        }\n\n        var errorMsg = error.response && error.response.data.error ? error.response.data.error : error.message;\n\n        _this2.setState(_objectSpread({\n          loading: false,\n          metricsLoadError: errorMsg\n        }, defaultMetricsState));\n      });\n      this.setState({\n        loading: true,\n        metricsLoadError: null\n      });\n    }\n  }, {\n    key: \"showTrafficMetrics\",\n    value: function showTrafficMetrics(outbound, inbound, data, nodeMetricType) {\n      var _this3 = this;\n\n      var comparator = function comparator(labels, protocol) {\n        return protocol ? labels.request_protocol === protocol : true;\n      };\n\n      if (this.isServiceDestCornerCase(nodeMetricType)) {\n        comparator = function comparator(labels, protocol) {\n          return (protocol ? labels.request_protocol === protocol : true) && labels.destination_workload === UNKNOWN;\n        };\n      } else if (data.isOutside) {\n        // filter out traffic completely outside the active namespaces\n        comparator = function comparator(labels, protocol) {\n          if (protocol && labels.request_protocol !== protocol) {\n            return false;\n          }\n\n          if (labels.destination_service_namespace && !_this3.isActiveNamespace(labels.destination_service_namespace)) {\n            return false;\n          }\n\n          if (labels.source_workload_namespace && !_this3.isActiveNamespace(labels.source_workload_namespace)) {\n            return false;\n          }\n\n          return true;\n        };\n      }\n\n      var rcOut = outbound.request_count;\n      var ecOut = outbound.request_error_count;\n      var grpcSentOut = outbound.grpc_sent;\n      var grpcReceivedOut = outbound.grpc_received;\n      var tcpSentOut = outbound.tcp_sent;\n      var tcpReceivedOut = outbound.tcp_received;\n      var rcIn = inbound.request_count;\n      var ecIn = inbound.request_error_count;\n      var grpcSentIn = inbound.grpc_sent;\n      var grpcReceivedIn = inbound.grpc_received;\n      var tcpSentIn = inbound.tcp_sent;\n      var tcpReceivedIn = inbound.tcp_received;\n      this.setState({\n        loading: false,\n        grpcErrorCountIn: getDatapoints(ecIn, comparator, Protocol.GRPC),\n        grpcErrorCountOut: getDatapoints(ecOut, comparator, Protocol.GRPC),\n        grpcReceivedIn: getDatapoints(grpcReceivedIn, comparator),\n        grpcReceivedOut: getDatapoints(grpcReceivedOut, comparator),\n        grpcRequestCountIn: getDatapoints(rcIn, comparator, Protocol.GRPC),\n        grpcRequestCountOut: getDatapoints(rcOut, comparator, Protocol.GRPC),\n        grpcSentIn: getDatapoints(grpcSentIn, comparator),\n        grpcSentOut: getDatapoints(grpcSentOut, comparator),\n        httpErrorCountIn: getDatapoints(ecIn, comparator, Protocol.HTTP),\n        httpErrorCountOut: getDatapoints(ecOut, comparator, Protocol.HTTP),\n        httpRequestCountIn: getDatapoints(rcIn, comparator, Protocol.HTTP),\n        httpRequestCountOut: getDatapoints(rcOut, comparator, Protocol.HTTP),\n        tcpReceivedIn: getDatapoints(tcpReceivedIn, comparator),\n        tcpReceivedOut: getDatapoints(tcpReceivedOut, comparator),\n        tcpSentIn: getDatapoints(tcpSentIn, comparator),\n        tcpSentOut: getDatapoints(tcpSentOut, comparator)\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var node = this.props.data.summaryTarget;\n      var nodeData = decoratedNodeData(node);\n      var hasGrpc = this.hasGrpcTraffic(nodeData);\n      var hasGrpcIn = hasGrpc && this.hasGrpcIn(nodeData);\n      var hasGrpcOut = hasGrpc && this.hasGrpcOut(nodeData);\n      var hasHttp = this.hasHttpTraffic(nodeData);\n      var hasHttpIn = hasHttp && this.hasHttpIn(nodeData);\n      var hasHttpOut = hasHttp && this.hasHttpOut(nodeData);\n      var hasTcp = this.hasTcpTraffic(nodeData);\n      var hasTcpIn = hasTcp && this.hasTcpIn(nodeData);\n      var hasTcpOut = hasTcp && this.hasTcpOut(nodeData);\n      return /*#__PURE__*/React.createElement(React.Fragment, null, hasGrpc && this.isGrpcRequests() && /*#__PURE__*/React.createElement(React.Fragment, null, this.renderGrpcRates(node), hr()), hasHttp && /*#__PURE__*/React.createElement(React.Fragment, null, this.renderHttpRates(node), hr()), /*#__PURE__*/React.createElement(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 373,\n          columnNumber: 9\n        }\n      }, this.renderSparklines(node), hr()), hasGrpc && !hasGrpcIn && renderNoTraffic('gRPC inbound'), hasGrpc && !hasGrpcOut && renderNoTraffic('gRPC outbound'), !hasGrpc && renderNoTraffic('gRPC'), hasHttp && !hasHttpIn && renderNoTraffic('HTTP inbound'), hasHttp && !hasHttpOut && renderNoTraffic('HTTP outbound'), !hasHttp && renderNoTraffic('HTTP'), hasTcp && !hasTcpIn && renderNoTraffic('TCP inbound'), hasTcp && !hasTcpOut && renderNoTraffic('TCP outbound'), !hasTcp && renderNoTraffic('TCP'));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      // if the summaryTarget (i.e. selected node) has changed, then init the state and set to loading. The loading\n      // will actually be kicked off after the render (in componentDidMount/Update).\n      return props.data.summaryTarget !== state.node ? _objectSpread({\n        node: props.data.summaryTarget,\n        loading: true\n      }, defaultMetricsState) : null;\n    }\n  }]);\n\n  return SummaryPanelNodeTraffic;\n}(React.Component);","map":{"version":3,"sources":["/root/GraduateProject/src/pages/Graph/SummaryPanelNodeTraffic.tsx"],"names":["React","getAccumulatedTrafficRateGrpc","getAccumulatedTrafficRateHttp","getTrafficRateGrpc","getTrafficRateHttp","InOutRateTableGrpc","InOutRateTableHttp","RequestChart","StreamChart","GraphType","NodeType","Protocol","UNKNOWN","TrafficRate","shouldRefreshData","NodeMetricType","getDatapoints","getNodeMetrics","getNodeMetricType","renderNoTraffic","mergeMetricsResponses","hr","makeCancelablePromise","CyNode","decoratedNodeData","KialiIcon","defaultMetricsState","grpcRequestCountIn","grpcRequestCountOut","grpcErrorCountIn","grpcErrorCountOut","grpcSentIn","grpcSentOut","grpcReceivedIn","grpcReceivedOut","httpRequestCountIn","httpRequestCountOut","httpErrorCountIn","httpErrorCountOut","tcpSentIn","tcpSentOut","tcpReceivedIn","tcpReceivedOut","defaultState","node","loading","metricsLoadError","SummaryPanelNodeTraffic","props","metricsPromise","isActiveNamespace","namespace","namespaces","ns","name","renderGrpcRates","inbound","outbound","data","summaryTarget","edgesTo","rate","rateGrpcErr","rateNoResponse","renderHttpRates","rate3xx","rate4xx","rate5xx","renderSparklines","nodeData","nodeType","isInaccessible","isServiceEntry","state","isServiceNode","SERVICE","isInOutSameNode","AGGREGATE","serviceWithUnknownSource","incomers","forEach","n","undefined","grpcCharts","httpCharts","tcpCharts","hasGrpcTraffic","isGrpcRequests","hasGrpcIn","isIstioOutboundCornerCase","hasGrpcOut","hasHttpTraffic","hasHttpIn","hasHttpOut","hasTcpTraffic","hasTcpIn","hasTcpOut","isServiceDestCornerCase","nodeMetricType","injectServiceNodes","graphType","isIstio","size","trafficRates","includes","GRPC_REQUEST","grpcIn","httpIn","tcpIn","grpcOut","httpOut","tcpOut","showTrafficMetrics","bind","updateCharts","prevProps","cancel","target","setState","promiseIn","Promise","resolve","promiseOut","isRoot","promiseRps","promiseStream","filtersRps","reporter","byLabelsRps","isOutside","push","filtersStream","length","byLabelsStream","filters","byLabels","all","promise","then","responses","catch","error","isCanceled","console","debug","errorMsg","response","message","comparator","labels","protocol","request_protocol","destination_workload","destination_service_namespace","source_workload_namespace","rcOut","request_count","ecOut","request_error_count","grpc_sent","grpc_received","tcp_sent","tcp_received","rcIn","ecIn","GRPC","HTTP","hasGrpc","hasHttp","hasTcp","Component"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getAccumulatedTrafficRateGrpc,\n  getAccumulatedTrafficRateHttp,\n  getTrafficRateGrpc,\n  getTrafficRateHttp\n} from '../../utils/TrafficRate';\nimport { InOutRateTableGrpc, InOutRateTableHttp } from '../../components/SummaryPanel/InOutRateTable';\nimport { RequestChart, StreamChart } from '../../components/SummaryPanel/RpsChart';\nimport {\n  GraphType,\n  NodeType,\n  SummaryPanelPropType,\n  Protocol,\n  DecoratedGraphNodeData,\n  UNKNOWN,\n  TrafficRate\n} from '../../types/Graph';\nimport { IstioMetricsMap, Datapoint, Labels } from '../../types/Metrics';\nimport {\n  shouldRefreshData,\n  NodeMetricType,\n  getDatapoints,\n  getNodeMetrics,\n  getNodeMetricType,\n  renderNoTraffic,\n  mergeMetricsResponses,\n  hr\n} from './SummaryPanelCommon';\nimport { CancelablePromise, makeCancelablePromise } from '../../utils/CancelablePromises';\nimport { Response } from '../../services/Api';\nimport { Reporter } from '../../types/MetricsOptions';\nimport { CyNode, decoratedNodeData } from '../../components/CytoscapeGraph/CytoscapeGraphUtils';\nimport { KialiIcon } from 'config/KialiIcon';\n\ntype SummaryPanelNodeMetricsState = {\n  grpcRequestCountIn: Datapoint[];\n  grpcRequestCountOut: Datapoint[];\n  grpcErrorCountIn: Datapoint[];\n  grpcErrorCountOut: Datapoint[];\n  grpcSentIn: Datapoint[];\n  grpcSentOut: Datapoint[];\n  grpcReceivedIn: Datapoint[];\n  grpcReceivedOut: Datapoint[];\n  httpRequestCountIn: Datapoint[] | null;\n  httpRequestCountOut: Datapoint[];\n  httpErrorCountIn: Datapoint[];\n  httpErrorCountOut: Datapoint[];\n  tcpSentIn: Datapoint[];\n  tcpSentOut: Datapoint[];\n  tcpReceivedIn: Datapoint[];\n  tcpReceivedOut: Datapoint[];\n};\n\ntype SummaryPanelNodeState = SummaryPanelNodeMetricsState & {\n  node: any;\n  loading: boolean;\n  metricsLoadError: string | null;\n};\n\nconst defaultMetricsState: SummaryPanelNodeMetricsState = {\n  grpcRequestCountIn: [],\n  grpcRequestCountOut: [],\n  grpcErrorCountIn: [],\n  grpcErrorCountOut: [],\n  grpcSentIn: [],\n  grpcSentOut: [],\n  grpcReceivedIn: [],\n  grpcReceivedOut: [],\n  httpRequestCountIn: [],\n  httpRequestCountOut: [],\n  httpErrorCountIn: [],\n  httpErrorCountOut: [],\n  tcpSentIn: [],\n  tcpSentOut: [],\n  tcpReceivedIn: [],\n  tcpReceivedOut: []\n};\n\nconst defaultState: SummaryPanelNodeState = {\n  node: null,\n  loading: false,\n  metricsLoadError: null,\n  ...defaultMetricsState\n};\n\ntype SummaryPanelNodeProps = SummaryPanelPropType;\n\nexport class SummaryPanelNodeTraffic extends React.Component<SummaryPanelNodeProps, SummaryPanelNodeState> {\n  private metricsPromise?: CancelablePromise<Response<IstioMetricsMap>[]>;\n\n  constructor(props: SummaryPanelNodeProps) {\n    super(props);\n    this.showTrafficMetrics = this.showTrafficMetrics.bind(this);\n\n    this.state = { ...defaultState };\n  }\n\n  static getDerivedStateFromProps(props: SummaryPanelNodeProps, state: SummaryPanelNodeState) {\n    // if the summaryTarget (i.e. selected node) has changed, then init the state and set to loading. The loading\n    // will actually be kicked off after the render (in componentDidMount/Update).\n    return props.data.summaryTarget !== state.node\n      ? { node: props.data.summaryTarget, loading: true, ...defaultMetricsState }\n      : null;\n  }\n\n  componentDidMount() {\n    this.updateCharts(this.props);\n  }\n\n  componentDidUpdate(prevProps: SummaryPanelNodeProps) {\n    if (shouldRefreshData(prevProps, this.props)) {\n      this.updateCharts(this.props);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.metricsPromise) {\n      this.metricsPromise.cancel();\n    }\n  }\n\n  updateCharts(props: SummaryPanelNodeProps) {\n    const target = props.data.summaryTarget;\n    const nodeData = decoratedNodeData(target);\n    const nodeMetricType = getNodeMetricType(nodeData);\n    const isGrpcRequests = this.isGrpcRequests();\n\n    if (this.metricsPromise) {\n      this.metricsPromise.cancel();\n      this.metricsPromise = undefined;\n    }\n\n    if (!this.hasGrpcTraffic(nodeData) && !this.hasHttpTraffic(nodeData) && !this.hasTcpTraffic(nodeData)) {\n      this.setState({ loading: false });\n      return;\n    }\n\n    // If destination node is inaccessible, we cannot query the data.\n    if (nodeData.isInaccessible) {\n      this.setState({ loading: false });\n      return;\n    }\n\n    let promiseIn: Promise<Response<IstioMetricsMap>> = Promise.resolve({ data: {} });\n    let promiseOut: Promise<Response<IstioMetricsMap>> = Promise.resolve({ data: {} });\n\n    // set inbound unless it is a root (because they have no inbound edges)\n    if (!nodeData.isRoot) {\n      const isServiceDestCornerCase = this.isServiceDestCornerCase(nodeMetricType);\n      let promiseRps: Promise<Response<IstioMetricsMap>> = Promise.resolve({ data: {} });\n      let promiseStream: Promise<Response<IstioMetricsMap>> = Promise.resolve({ data: {} });\n\n      if (this.hasHttpIn(nodeData) || (this.hasGrpcIn(nodeData) && isGrpcRequests)) {\n        const filtersRps = ['request_count', 'request_error_count'];\n        // use dest metrics for inbound, except for service nodes which need source metrics to capture source errors\n        const reporter: Reporter =\n          nodeData.nodeType === NodeType.SERVICE && nodeData.isIstio ? 'source' : 'destination';\n        // For special service dest nodes we want to narrow the data to only TS with 'unknown' workloads (see the related\n        // comparator in getNodeDatapoints).\n\n        const byLabelsRps = isServiceDestCornerCase\n          ? ['destination_workload', 'request_protocol']\n          : ['request_protocol'];\n        if (nodeData.isOutside) {\n          byLabelsRps.push('source_workload_namespace');\n        }\n        promiseRps = getNodeMetrics(\n          nodeMetricType,\n          target,\n          props,\n          filtersRps,\n          'inbound',\n          reporter,\n          undefined,\n          undefined,\n          byLabelsRps\n        );\n      }\n\n      // Aggregate nodes currently only deal with request traffic\n      if (nodeData.nodeType !== NodeType.AGGREGATE) {\n        const filtersStream = [] as string[];\n        if (this.hasGrpcIn(nodeData)) {\n          filtersStream.push('grpc_sent', 'grpc_received');\n        }\n        if (this.hasTcpIn(nodeData)) {\n          filtersStream.push('tcp_sent', 'tcp_received');\n        }\n        if (filtersStream.length > 0) {\n          const byLabelsStream = isServiceDestCornerCase ? ['destination_workload'] : [];\n          if (nodeData.isOutside) {\n            byLabelsStream.push('source_workload_namespace');\n          }\n          promiseStream = getNodeMetrics(\n            nodeMetricType,\n            target,\n            props,\n            filtersStream,\n            'inbound',\n            'source',\n            undefined,\n            undefined,\n            byLabelsStream\n          );\n        }\n      }\n\n      promiseIn = mergeMetricsResponses([promiseRps, promiseStream]);\n    }\n\n    // Ignore outbound traffic if it is a non-root outsider (because they have no outbound edges) or a\n    // service node or aggregate node (because they don't have \"real\" outbound edges).\n    if (\n      !([NodeType.SERVICE, NodeType.AGGREGATE].includes(nodeData.nodeType) || (nodeData.isOutside && !nodeData.isRoot))\n    ) {\n      const filters = [] as string[];\n      if (this.hasHttpOut(nodeData) || (this.hasGrpcOut(nodeData) && isGrpcRequests)) {\n        filters.push('request_count', 'request_error_count');\n      }\n      if (this.hasGrpcOut(nodeData) && !isGrpcRequests) {\n        filters.push('grpc_sent', 'grpc_received');\n      }\n      if (this.hasTcpOut(nodeData)) {\n        filters.push('tcp_sent', 'tcp_received');\n      }\n\n      if (filters.length > 0) {\n        // use source metrics for outbound, except for:\n        // - unknown nodes (no source telemetry)\n        // - istio namespace nodes (no source telemetry)\n        const reporter: Reporter =\n          nodeData.nodeType === NodeType.UNKNOWN || nodeData.isIstio ? 'destination' : 'source';\n        // note: request_protocol is not a valid byLabel for tcp filters but it is ignored by prometheus\n        const byLabels = nodeData.isOutside\n          ? ['destination_service_namespace', 'request_protocol']\n          : ['request_protocol'];\n        promiseOut = getNodeMetrics(\n          nodeMetricType,\n          target,\n          props,\n          filters,\n          'outbound',\n          reporter,\n          undefined,\n          undefined,\n          byLabels\n        );\n      }\n    }\n\n    this.metricsPromise = makeCancelablePromise(Promise.all([promiseOut, promiseIn]));\n    this.metricsPromise.promise\n      .then(responses => {\n        this.showTrafficMetrics(responses[0].data, responses[1].data, nodeData, nodeMetricType);\n      })\n      .catch(error => {\n        if (error.isCanceled) {\n          console.debug('SummaryPanelNode: Ignore fetch error (canceled).');\n          return;\n        }\n        const errorMsg = error.response && error.response.data.error ? error.response.data.error : error.message;\n        this.setState({\n          loading: false,\n          metricsLoadError: errorMsg,\n          ...defaultMetricsState\n        });\n      });\n\n    this.setState({ loading: true, metricsLoadError: null });\n  }\n\n  showTrafficMetrics(\n    outbound: IstioMetricsMap,\n    inbound: IstioMetricsMap,\n    data: DecoratedGraphNodeData,\n    nodeMetricType: NodeMetricType\n  ) {\n    let comparator = (labels: Labels, protocol?: Protocol) => {\n      return protocol ? labels.request_protocol === protocol : true;\n    };\n    if (this.isServiceDestCornerCase(nodeMetricType)) {\n      comparator = (labels: Labels, protocol?: Protocol) => {\n        return (protocol ? labels.request_protocol === protocol : true) && labels.destination_workload === UNKNOWN;\n      };\n    } else if (data.isOutside) {\n      // filter out traffic completely outside the active namespaces\n      comparator = (labels: Labels, protocol?: Protocol) => {\n        if (protocol && labels.request_protocol !== protocol) {\n          return false;\n        }\n        if (labels.destination_service_namespace && !this.isActiveNamespace(labels.destination_service_namespace)) {\n          return false;\n        }\n        if (labels.source_workload_namespace && !this.isActiveNamespace(labels.source_workload_namespace)) {\n          return false;\n        }\n        return true;\n      };\n    }\n    const rcOut = outbound.request_count;\n    const ecOut = outbound.request_error_count;\n    const grpcSentOut = outbound.grpc_sent;\n    const grpcReceivedOut = outbound.grpc_received;\n    const tcpSentOut = outbound.tcp_sent;\n    const tcpReceivedOut = outbound.tcp_received;\n    const rcIn = inbound.request_count;\n    const ecIn = inbound.request_error_count;\n    const grpcSentIn = inbound.grpc_sent;\n    const grpcReceivedIn = inbound.grpc_received;\n    const tcpSentIn = inbound.tcp_sent;\n    const tcpReceivedIn = inbound.tcp_received;\n    this.setState({\n      loading: false,\n      grpcErrorCountIn: getDatapoints(ecIn, comparator, Protocol.GRPC),\n      grpcErrorCountOut: getDatapoints(ecOut, comparator, Protocol.GRPC),\n      grpcReceivedIn: getDatapoints(grpcReceivedIn, comparator),\n      grpcReceivedOut: getDatapoints(grpcReceivedOut, comparator),\n      grpcRequestCountIn: getDatapoints(rcIn, comparator, Protocol.GRPC),\n      grpcRequestCountOut: getDatapoints(rcOut, comparator, Protocol.GRPC),\n      grpcSentIn: getDatapoints(grpcSentIn, comparator),\n      grpcSentOut: getDatapoints(grpcSentOut, comparator),\n      httpErrorCountIn: getDatapoints(ecIn, comparator, Protocol.HTTP),\n      httpErrorCountOut: getDatapoints(ecOut, comparator, Protocol.HTTP),\n      httpRequestCountIn: getDatapoints(rcIn, comparator, Protocol.HTTP),\n      httpRequestCountOut: getDatapoints(rcOut, comparator, Protocol.HTTP),\n      tcpReceivedIn: getDatapoints(tcpReceivedIn, comparator),\n      tcpReceivedOut: getDatapoints(tcpReceivedOut, comparator),\n      tcpSentIn: getDatapoints(tcpSentIn, comparator),\n      tcpSentOut: getDatapoints(tcpSentOut, comparator)\n    });\n  }\n\n  isActiveNamespace = (namespace: string): boolean => {\n    if (!namespace) {\n      return false;\n    }\n    for (const ns of this.props.namespaces) {\n      if (ns.name === namespace) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  render() {\n    const node = this.props.data.summaryTarget;\n    const nodeData = decoratedNodeData(node);\n    const hasGrpc = this.hasGrpcTraffic(nodeData);\n    const hasGrpcIn = hasGrpc && this.hasGrpcIn(nodeData);\n    const hasGrpcOut = hasGrpc && this.hasGrpcOut(nodeData);\n    const hasHttp = this.hasHttpTraffic(nodeData);\n    const hasHttpIn = hasHttp && this.hasHttpIn(nodeData);\n    const hasHttpOut = hasHttp && this.hasHttpOut(nodeData);\n    const hasTcp = this.hasTcpTraffic(nodeData);\n    const hasTcpIn = hasTcp && this.hasTcpIn(nodeData);\n    const hasTcpOut = hasTcp && this.hasTcpOut(nodeData);\n\n    return (\n      <>\n        {hasGrpc && this.isGrpcRequests() && (\n          <>\n            {this.renderGrpcRates(node)}\n            {hr()}\n          </>\n        )}\n        {hasHttp && (\n          <>\n            {this.renderHttpRates(node)}\n            {hr()}\n          </>\n        )}\n        <div>\n          {this.renderSparklines(node)}\n          {hr()}\n        </div>\n        {hasGrpc && !hasGrpcIn && renderNoTraffic('gRPC inbound')}\n        {hasGrpc && !hasGrpcOut && renderNoTraffic('gRPC outbound')}\n        {!hasGrpc && renderNoTraffic('gRPC')}\n        {hasHttp && !hasHttpIn && renderNoTraffic('HTTP inbound')}\n        {hasHttp && !hasHttpOut && renderNoTraffic('HTTP outbound')}\n        {!hasHttp && renderNoTraffic('HTTP')}\n        {hasTcp && !hasTcpIn && renderNoTraffic('TCP inbound')}\n        {hasTcp && !hasTcpOut && renderNoTraffic('TCP outbound')}\n        {!hasTcp && renderNoTraffic('TCP')}\n      </>\n    );\n  }\n\n  private renderGrpcRates = node => {\n    const inbound = getTrafficRateGrpc(node);\n    const outbound = getAccumulatedTrafficRateGrpc(this.props.data.summaryTarget.edgesTo('*'));\n\n    return (\n      <>\n        <InOutRateTableGrpc\n          title=\"gRPC Traffic (requests per second):\"\n          inRate={inbound.rate}\n          inRateGrpcErr={inbound.rateGrpcErr}\n          inRateNR={inbound.rateNoResponse}\n          outRate={outbound.rate}\n          outRateGrpcErr={outbound.rateGrpcErr}\n          outRateNR={outbound.rateNoResponse}\n        />\n      </>\n    );\n  };\n\n  private renderHttpRates = node => {\n    const inbound = getTrafficRateHttp(node);\n    const outbound = getAccumulatedTrafficRateHttp(this.props.data.summaryTarget.edgesTo('*'));\n\n    return (\n      <>\n        <InOutRateTableHttp\n          title=\"HTTP (requests per second):\"\n          inRate={inbound.rate}\n          inRate3xx={inbound.rate3xx}\n          inRate4xx={inbound.rate4xx}\n          inRate5xx={inbound.rate5xx}\n          inRateNR={inbound.rateNoResponse}\n          outRate={outbound.rate}\n          outRate3xx={outbound.rate3xx}\n          outRate4xx={outbound.rate4xx}\n          outRate5xx={outbound.rate5xx}\n          outRateNR={outbound.rateNoResponse}\n        />\n      </>\n    );\n  };\n\n  private renderSparklines = node => {\n    const nodeData = decoratedNodeData(node);\n\n    if (NodeType.UNKNOWN === nodeData.nodeType) {\n      return (\n        <>\n          <div>\n            <KialiIcon.Info /> Sparkline charts not supported for unknown node. Use edge for details.\n          </div>\n        </>\n      );\n    } else if (nodeData.isInaccessible) {\n      return (\n        <>\n          <div>\n            <KialiIcon.Info /> Sparkline charts cannot be shown because the selected node is inaccessible.\n          </div>\n        </>\n      );\n    } else if (nodeData.isServiceEntry) {\n      return (\n        <>\n          <div>\n            <KialiIcon.Info /> Sparkline charts cannot be shown because the selected node is a serviceEntry.\n          </div>\n        </>\n      );\n    }\n    if (this.state.loading) {\n      return <strong>Loading charts...</strong>;\n    }\n    if (this.state.metricsLoadError) {\n      return (\n        <div>\n          <KialiIcon.Warning /> <strong>Error loading metrics: </strong>\n          {this.state.metricsLoadError}\n        </div>\n      );\n    }\n\n    const isServiceNode = nodeData.nodeType === NodeType.SERVICE;\n    const isInOutSameNode = isServiceNode || nodeData.nodeType === NodeType.AGGREGATE;\n    let serviceWithUnknownSource: boolean = false;\n    if (isServiceNode) {\n      node.incomers().forEach(n => {\n        if (NodeType.UNKNOWN === n.data(CyNode.nodeType)) {\n          serviceWithUnknownSource = true;\n          return false; // Equivalent of break for cytoscapejs forEach API\n        }\n        return undefined; // Every code paths needs to return something to avoid the wrath of the linter.\n      });\n    }\n\n    let grpcCharts, httpCharts, tcpCharts;\n\n    if (this.hasGrpcTraffic(nodeData)) {\n      grpcCharts = this.isGrpcRequests() ? (\n        <>\n          {this.hasGrpcIn(nodeData) && (\n            <>\n              <RequestChart\n                label={isInOutSameNode ? 'gRPC - Request Traffic' : 'gRPC - Inbound Request Traffic'}\n                dataRps={this.state.grpcRequestCountIn!}\n                dataErrors={this.state.grpcErrorCountIn}\n              />\n              {serviceWithUnknownSource && (\n                <>\n                  <div>\n                    <KialiIcon.Info /> Traffic from unknown not included. Use edge for details.\n                  </div>\n                </>\n              )}\n            </>\n          )}\n          {this.hasGrpcIn(nodeData) && (\n            <>\n              <RequestChart\n                label=\"gRPC - Outbound Request Traffic\"\n                dataRps={this.state.grpcRequestCountOut}\n                dataErrors={this.state.grpcErrorCountOut}\n                hide={isInOutSameNode}\n              />\n              {this.isIstioOutboundCornerCase(node) && (\n                <>\n                  <div>\n                    <KialiIcon.Info /> Traffic to Istio namespaces not included. Use edge for details.\n                  </div>\n                </>\n              )}\n            </>\n          )}\n        </>\n      ) : (\n        <>\n          {this.hasGrpcIn(nodeData) && (\n            <StreamChart\n              label={isInOutSameNode ? 'gRPC - Traffic' : 'gRPC - Inbound Traffic'}\n              receivedRates={this.state.grpcReceivedIn}\n              sentRates={this.state.grpcSentIn}\n              unit=\"messages\"\n            />\n          )}\n          {this.hasGrpcOut(nodeData) && (\n            <StreamChart\n              label=\"gRPC - Outbound Traffic\"\n              receivedRates={this.state.grpcReceivedOut}\n              sentRates={this.state.grpcSentOut}\n              hide={isInOutSameNode}\n              unit=\"messages\"\n            />\n          )}\n        </>\n      );\n    }\n\n    if (this.hasHttpTraffic(nodeData)) {\n      httpCharts = (\n        <>\n          {this.hasHttpIn(nodeData) && (\n            <>\n              <RequestChart\n                label={isInOutSameNode ? 'HTTP - Request Traffic' : 'HTTP - Inbound Request Traffic'}\n                dataRps={this.state.httpRequestCountIn!}\n                dataErrors={this.state.httpErrorCountIn}\n              />\n              {serviceWithUnknownSource && (\n                <>\n                  <div>\n                    <KialiIcon.Info /> Traffic from unknown not included. Use edge for details.\n                  </div>\n                </>\n              )}\n            </>\n          )}\n          {this.hasHttpOut(nodeData) && (\n            <>\n              <RequestChart\n                label=\"HTTP - Outbound Request Traffic\"\n                dataRps={this.state.httpRequestCountOut}\n                dataErrors={this.state.httpErrorCountOut}\n                hide={isInOutSameNode}\n              />\n              {this.isIstioOutboundCornerCase(node) && (\n                <>\n                  <div>\n                    <KialiIcon.Info />\" Traffic to Istio namespaces not included. Use edge for details.\n                  </div>\n                </>\n              )}\n            </>\n          )}\n        </>\n      );\n    }\n\n    if (this.hasTcpTraffic(nodeData)) {\n      tcpCharts = (\n        <>\n          {this.hasTcpIn(nodeData) && (\n            <StreamChart\n              label={isInOutSameNode ? 'TCP - Traffic' : 'TCP - Inbound Traffic'}\n              receivedRates={this.state.tcpReceivedIn}\n              sentRates={this.state.tcpSentIn}\n              unit=\"bytes\"\n            />\n          )}\n          {this.hasTcpOut(nodeData) && (\n            <StreamChart\n              label=\"TCP - Outbound Traffic\"\n              receivedRates={this.state.tcpReceivedOut}\n              sentRates={this.state.tcpSentOut}\n              hide={isInOutSameNode}\n              unit=\"bytes\"\n            />\n          )}\n        </>\n      );\n    }\n\n    return (\n      <>\n        {grpcCharts}\n        {httpCharts}\n        {tcpCharts}\n      </>\n    );\n  };\n\n  // We need to handle the special case of a dest service node showing client failures. These service nodes show up in\n  // non-service graphs, even when not injecting service nodes.\n  private isServiceDestCornerCase = (nodeMetricType: NodeMetricType): boolean => {\n    return (\n      nodeMetricType === NodeMetricType.SERVICE &&\n      !this.props.injectServiceNodes &&\n      this.props.graphType !== GraphType.SERVICE\n    );\n  };\n\n  // We need to handle the special case of a non-istio, non-unknown node with outbound traffic to istio.\n  // The traffic is lost because it is dest-only and we use source-reporting.\n  private isIstioOutboundCornerCase = (node): boolean => {\n    const nodeData = decoratedNodeData(node);\n    if (nodeData.nodeType === NodeType.UNKNOWN || nodeData.isIstio) {\n      return false;\n    }\n    return node.edgesTo(`node[?${CyNode.isIstio}]`).size() > 0;\n  };\n\n  private hasGrpcTraffic = (data: DecoratedGraphNodeData): boolean => {\n    return this.hasGrpcIn(data) || this.hasGrpcOut(data);\n  };\n\n  private isGrpcRequests = (): boolean => {\n    return this.props.trafficRates.includes(TrafficRate.GRPC_REQUEST);\n  };\n\n  private hasHttpTraffic = (data: DecoratedGraphNodeData): boolean => {\n    return this.hasHttpIn(data) || this.hasHttpOut(data);\n  };\n\n  private hasTcpTraffic = (data: DecoratedGraphNodeData): boolean => {\n    return this.hasTcpIn(data) || this.hasTcpOut(data);\n  };\n\n  private hasGrpcIn = (data: DecoratedGraphNodeData): boolean => {\n    return data.grpcIn > 0;\n  };\n\n  private hasHttpIn = (data: DecoratedGraphNodeData): boolean => {\n    return data.httpIn > 0;\n  };\n\n  private hasTcpIn = (data: DecoratedGraphNodeData): boolean => {\n    return data.tcpIn > 0;\n  };\n\n  private hasGrpcOut = (data: DecoratedGraphNodeData): boolean => {\n    return data.grpcOut > 0;\n  };\n\n  private hasHttpOut = (data: DecoratedGraphNodeData): boolean => {\n    return data.httpOut > 0;\n  };\n\n  private hasTcpOut = (data: DecoratedGraphNodeData): boolean => {\n    return data.tcpOut > 0;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}