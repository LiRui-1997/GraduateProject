{"ast":null,"code":"import _slicedToArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar _jsxFileName = \"/root/kiali-ui/src/components/JaegerIntegration/TracesComponent.tsx\";\nimport * as React from 'react';\nimport { Card, CardBody, Tab, Tabs, Toolbar, ToolbarGroup, ToolbarItem, Tooltip } from '@patternfly/react-core';\nimport { ExternalLinkAltIcon } from '@patternfly/react-icons';\nimport { connect } from 'react-redux';\nimport * as API from 'services/Api';\nimport * as AlertUtils from 'utils/AlertUtils';\nimport { RenderComponentScroll } from '../Nav/Page';\nimport TraceDetails from './JaegerResults/TraceDetails';\nimport JaegerScatter from './JaegerScatter';\nimport { TracesFetcher } from './TracesFetcher';\nimport { SpanDetails } from './JaegerResults/SpanDetails';\nimport { isEqualTimeRange } from 'types/Common';\nimport { timeRangeSelector } from 'store/Selectors';\nimport { getTimeRangeMicros } from 'utils/tracing/TracingHelper';\nimport { TracesDisplayOptions, percentilesOptions } from './TracesDisplayOptions';\nimport { genStatsKey } from 'types/MetricsOptions';\nimport { getSpanId } from 'utils/SearchParamUtils';\nvar traceDetailsTab = 0;\nvar spansDetailsTab = 1;\n\nvar TracesComponent = /*#__PURE__*/function (_React$Component) {\n  _inherits(TracesComponent, _React$Component);\n\n  var _super = _createSuper(TracesComponent);\n\n  function TracesComponent(props) {\n    var _this;\n\n    _classCallCheck(this, TracesComponent);\n\n    _this = _super.call(this, props);\n    _this.fetcher = void 0;\n    _this.percentilesPromise = void 0;\n\n    _this.getTags = function () {\n      return _this.state.querySettings.errorsOnly ? '{\"error\":\"true\"}' : '';\n    };\n\n    _this.fetchTraces = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var options, percentiles;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = {\n                namespace: _this.props.namespace,\n                target: _this.props.target,\n                targetKind: _this.props.targetKind,\n                spanLimit: _this.state.querySettings.limit,\n                tags: _this.getTags()\n              };\n\n              if (!(_this.state.querySettings.percentile && _this.state.querySettings.percentile !== 'all')) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.prev = 2;\n              _context.next = 5;\n              return _this.percentilesPromise;\n\n            case 5:\n              percentiles = _context.sent;\n              options.minDuration = percentiles.get(_this.state.querySettings.percentile);\n\n              if (!options.minDuration) {\n                AlertUtils.addWarning('Cannot perform query above the requested percentile (value unknown).');\n              }\n\n              _context.next = 13;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](2);\n              AlertUtils.addError('Could not fetch percentiles.', _context.t0);\n\n            case 13:\n              _this.fetcher.fetch(options, _this.state.traces);\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 10]]);\n    }));\n\n    _this.fetchPercentiles = function () {\n      // We'll fetch percentiles on a large enough interval (unrelated to the selected interval)\n      // in order to have stable values and avoid constantly fetching again\n      var query = {\n        queryTime: Math.floor(Date.now() / 1000),\n        target: {\n          namespace: _this.props.namespace,\n          name: _this.props.target,\n          kind: _this.props.targetKind\n        },\n        interval: '1h',\n        direction: 'inbound',\n        avg: false,\n        quantiles: percentilesOptions.map(function (p) {\n          return p.id;\n        }).filter(function (id) {\n          return id !== 'all';\n        })\n      };\n      var queries = _this.props.targetKind === 'service' ? [query] : [query, _objectSpread(_objectSpread({}, query), {}, {\n        direction: 'outbound'\n      })];\n      return API.getMetricsStats(queries).then(function (r) {\n        return _this.percentilesFetched(query, r.data);\n      });\n    };\n\n    _this.percentilesFetched = function (q, r) {\n      if (r.warnings) {\n        AlertUtils.addWarning(r.warnings.join(', '));\n      }\n\n      var _map = ['inbound', 'outbound'].map(function (dir) {\n        var map = new Map();\n        var key = genStatsKey(q.target, undefined, dir, q.interval);\n\n        if (key) {\n          var statsForKey = r.stats[key];\n\n          if (statsForKey) {\n            statsForKey.responseTimes.forEach(function (rt) {\n              if (q.quantiles.includes(rt.name)) {\n                map.set(rt.name, rt.value);\n              }\n            });\n          }\n        }\n\n        return map;\n      }),\n          _map2 = _slicedToArray(_map, 2),\n          mapInbound = _map2[0],\n          mapOutbound = _map2[1]; // Merge the two maps; if a value exists in both of them, take the mean\n\n\n      var minDurations = new Map();\n      mapInbound.forEach(function (v1, k) {\n        var v2 = mapOutbound.get(k);\n\n        if (v2) {\n          minDurations.set(k, (v1 + v2) / 2);\n          mapOutbound.delete(k);\n        } else {\n          minDurations.set(k, v1);\n        }\n      });\n      mapOutbound.forEach(function (v, k) {\n        return minDurations.set(k, v);\n      });\n      return minDurations;\n    };\n\n    _this.onTracesUpdated = function (traces, jaegerServiceName) {\n      var newState = {\n        traces: traces,\n        jaegerErrors: undefined,\n        toolbarDisabled: false\n      };\n\n      if (_this.state.targetApp === undefined && jaegerServiceName) {\n        newState.targetApp = jaegerServiceName;\n      }\n\n      _this.setState(newState);\n    };\n\n    _this.getJaegerUrl = function () {\n      if (_this.props.urlJaeger === '' || !_this.state.targetApp) {\n        return undefined;\n      }\n\n      var range = getTimeRangeMicros();\n      var url = \"\".concat(_this.props.urlJaeger, \"/search?service=\").concat(_this.state.targetApp, \"&start=\").concat(range.from, \"&limit=\").concat(_this.state.querySettings.limit);\n\n      if (range.to) {\n        url += \"&end=\".concat(range.to);\n      }\n\n      var tags = _this.getTags();\n\n      if (tags) {\n        url += \"&tags=\".concat(tags);\n      }\n\n      return url;\n    };\n\n    _this.onQuerySettingsChanged = function (settings) {\n      _this.fetcher.resetLastFetchTime();\n\n      _this.setState({\n        querySettings: settings\n      }, _this.fetchTraces);\n    };\n\n    _this.onDisplaySettingsChanged = function (settings) {\n      _this.setState({\n        displaySettings: settings\n      });\n    };\n\n    var targetApp = undefined;\n\n    if (_this.props.targetKind === 'app') {\n      targetApp = _this.props.namespaceSelector ? _this.props.target + '.' + _this.props.namespace : _this.props.target;\n    }\n\n    _this.state = {\n      url: '',\n      width: 0,\n      querySettings: TracesDisplayOptions.retrieveQuerySettings(),\n      displaySettings: TracesDisplayOptions.retrieveDisplaySettings(),\n      traces: [],\n      jaegerErrors: [],\n      targetApp: targetApp,\n      activeTab: getSpanId() ? spansDetailsTab : traceDetailsTab,\n      toolbarDisabled: false\n    };\n    _this.fetcher = new TracesFetcher(_this.onTracesUpdated, function (errors) {\n      // If there was traces displayed already, do not hide them so that the user can still interact with them\n      // (consider it's probably a temporary failure)\n      // Note that the error message is anyway displayed in the notifications component, so it's not going unnoticed\n      if (_this.state.traces.length === 0) {\n        _this.setState({\n          jaegerErrors: errors,\n          toolbarDisabled: true\n        });\n      }\n    });\n    _this.percentilesPromise = _this.fetchPercentiles();\n    return _this;\n  }\n\n  _createClass(TracesComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.fetchTraces();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      // Selected trace (coming from redux) might have been reloaded and needs to be updated within the traces list\n      // Check reference of selected trace\n      if (this.props.selectedTrace && prevProps.selectedTrace !== this.props.selectedTrace) {\n        var traces = this.state.traces;\n        var trace = this.props.selectedTrace;\n        var index = traces.findIndex(function (t) {\n          return t.traceID === trace.traceID;\n        });\n\n        if (index >= 0) {\n          traces[index] = this.props.selectedTrace;\n          this.setState({\n            traces: traces\n          });\n        }\n      }\n\n      var changedTimeRange = !isEqualTimeRange(this.props.timeRange, prevProps.timeRange);\n\n      if (this.props.lastRefreshAt !== prevProps.lastRefreshAt || changedTimeRange) {\n        if (changedTimeRange) {\n          this.fetcher.resetLastFetchTime();\n        }\n\n        this.fetchTraces();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var jaegerURL = this.getJaegerUrl();\n      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RenderComponentScroll, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 227,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(Card, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 228,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(CardBody, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 229,\n          columnNumber: 13\n        }\n      }, /*#__PURE__*/React.createElement(Toolbar, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 230,\n          columnNumber: 15\n        }\n      }, /*#__PURE__*/React.createElement(ToolbarGroup, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 231,\n          columnNumber: 17\n        }\n      }, /*#__PURE__*/React.createElement(ToolbarItem, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 232,\n          columnNumber: 19\n        }\n      }, /*#__PURE__*/React.createElement(TracesDisplayOptions, {\n        onDisplaySettingsChanged: this.onDisplaySettingsChanged,\n        onQuerySettingsChanged: this.onQuerySettingsChanged,\n        percentilesPromise: this.percentilesPromise,\n        disabled: this.state.toolbarDisabled,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 233,\n          columnNumber: 21\n        }\n      }))), jaegerURL && /*#__PURE__*/React.createElement(ToolbarGroup, {\n        style: {\n          marginLeft: 'auto'\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 242,\n          columnNumber: 19\n        }\n      }, /*#__PURE__*/React.createElement(ToolbarItem, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 243,\n          columnNumber: 21\n        }\n      }, /*#__PURE__*/React.createElement(Tooltip, {\n        content: /*#__PURE__*/React.createElement(React.Fragment, null, \"Open Chart in Jaeger UI\"),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 244,\n          columnNumber: 23\n        }\n      }, /*#__PURE__*/React.createElement(\"a\", {\n        href: jaegerURL,\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        style: {\n          marginLeft: '10px'\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 245,\n          columnNumber: 25\n        }\n      }, \"View in Tracing \", /*#__PURE__*/React.createElement(ExternalLinkAltIcon, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 246,\n          columnNumber: 43\n        }\n      })))))), /*#__PURE__*/React.createElement(JaegerScatter, {\n        showSpansAverage: this.state.displaySettings.showSpansAverage,\n        traces: this.state.traces,\n        errorFetchTraces: this.state.jaegerErrors,\n        errorTraces: true,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 253,\n          columnNumber: 15\n        }\n      }))), this.props.selectedTrace && /*#__PURE__*/React.createElement(\"div\", {\n        style: {\n          marginTop: 25\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 262,\n          columnNumber: 13\n        }\n      }, /*#__PURE__*/React.createElement(Tabs, {\n        id: \"trace-details\",\n        activeKey: this.state.activeTab,\n        onSelect: function onSelect(_, idx) {\n          return _this2.setState({\n            activeTab: idx\n          });\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 267,\n          columnNumber: 15\n        }\n      }, /*#__PURE__*/React.createElement(Tab, {\n        eventKey: traceDetailsTab,\n        title: \"Trace Details\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 272,\n          columnNumber: 17\n        }\n      }, /*#__PURE__*/React.createElement(TraceDetails, {\n        namespace: this.props.namespace,\n        target: this.props.target,\n        targetKind: this.props.targetKind,\n        jaegerURL: this.props.urlJaeger,\n        otherTraces: this.state.traces,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 273,\n          columnNumber: 19\n        }\n      })), /*#__PURE__*/React.createElement(Tab, {\n        eventKey: spansDetailsTab,\n        title: \"Spans Details\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 281,\n          columnNumber: 17\n        }\n      }, /*#__PURE__*/React.createElement(SpanDetails, {\n        namespace: this.props.namespace,\n        target: this.props.target,\n        externalURL: this.props.urlJaeger,\n        items: this.props.selectedTrace.spans,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 282,\n          columnNumber: 19\n        }\n      }))))));\n    }\n  }]);\n\n  return TracesComponent;\n}(React.Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    timeRange: timeRangeSelector(state),\n    urlJaeger: state.jaegerState.info ? state.jaegerState.info.url : '',\n    namespaceSelector: state.jaegerState.info ? state.jaegerState.info.namespaceSelector : true,\n    selectedTrace: state.jaegerState.selectedTrace,\n    lastRefreshAt: state.globalState.lastRefreshAt\n  };\n};\n\nexport var TracesContainer = connect(mapStateToProps)(TracesComponent);\nexport default TracesContainer;","map":{"version":3,"sources":["/root/kiali-ui/src/components/JaegerIntegration/TracesComponent.tsx"],"names":["React","Card","CardBody","Tab","Tabs","Toolbar","ToolbarGroup","ToolbarItem","Tooltip","ExternalLinkAltIcon","connect","API","AlertUtils","RenderComponentScroll","TraceDetails","JaegerScatter","TracesFetcher","SpanDetails","isEqualTimeRange","timeRangeSelector","getTimeRangeMicros","TracesDisplayOptions","percentilesOptions","genStatsKey","getSpanId","traceDetailsTab","spansDetailsTab","TracesComponent","props","fetcher","percentilesPromise","getTags","state","querySettings","errorsOnly","fetchTraces","options","namespace","target","targetKind","spanLimit","limit","tags","percentile","percentiles","minDuration","get","addWarning","addError","fetch","traces","fetchPercentiles","query","queryTime","Math","floor","Date","now","name","kind","interval","direction","avg","quantiles","map","p","id","filter","queries","getMetricsStats","then","r","percentilesFetched","data","q","warnings","join","dir","Map","key","undefined","statsForKey","stats","responseTimes","forEach","rt","includes","set","value","mapInbound","mapOutbound","minDurations","v1","k","v2","delete","v","onTracesUpdated","jaegerServiceName","newState","jaegerErrors","toolbarDisabled","targetApp","setState","getJaegerUrl","urlJaeger","range","url","from","to","onQuerySettingsChanged","settings","resetLastFetchTime","onDisplaySettingsChanged","displaySettings","namespaceSelector","width","retrieveQuerySettings","retrieveDisplaySettings","activeTab","errors","length","prevProps","selectedTrace","trace","index","findIndex","t","traceID","changedTimeRange","timeRange","lastRefreshAt","jaegerURL","marginLeft","showSpansAverage","marginTop","_","idx","spans","Component","mapStateToProps","jaegerState","info","globalState","TracesContainer"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Card, CardBody, Tab, Tabs, Toolbar, ToolbarGroup, ToolbarItem, Tooltip } from '@patternfly/react-core';\nimport { ExternalLinkAltIcon } from '@patternfly/react-icons';\nimport { connect } from 'react-redux';\n\nimport * as API from 'services/Api';\nimport * as AlertUtils from 'utils/AlertUtils';\nimport { RenderComponentScroll } from '../Nav/Page';\nimport { KialiAppState } from 'store/Store';\nimport { JaegerError, JaegerTrace } from 'types/JaegerInfo';\nimport TraceDetails from './JaegerResults/TraceDetails';\nimport JaegerScatter from './JaegerScatter';\nimport { TracesFetcher, FetchOptions } from './TracesFetcher';\nimport { SpanDetails } from './JaegerResults/SpanDetails';\nimport { isEqualTimeRange, TargetKind, TimeInMilliseconds, TimeRange } from 'types/Common';\nimport { timeRangeSelector } from 'store/Selectors';\nimport { getTimeRangeMicros } from 'utils/tracing/TracingHelper';\nimport { TracesDisplayOptions, QuerySettings, DisplaySettings, percentilesOptions } from './TracesDisplayOptions';\nimport { Direction, genStatsKey, MetricsStatsQuery } from 'types/MetricsOptions';\nimport { MetricsStatsResult } from 'types/Metrics';\nimport { getSpanId } from 'utils/SearchParamUtils';\n\ninterface TracesProps {\n  namespace: string;\n  target: string;\n  targetKind: TargetKind;\n  urlJaeger: string;\n  namespaceSelector: boolean;\n  timeRange: TimeRange;\n  selectedTrace?: JaegerTrace;\n  lastRefreshAt: TimeInMilliseconds;\n}\n\ninterface TracesState {\n  url: string;\n  width: number;\n  querySettings: QuerySettings;\n  displaySettings: DisplaySettings;\n  traces: JaegerTrace[];\n  jaegerErrors: JaegerError[];\n  targetApp?: string;\n  activeTab: number;\n  toolbarDisabled: boolean;\n}\n\nconst traceDetailsTab = 0;\nconst spansDetailsTab = 1;\n\nclass TracesComponent extends React.Component<TracesProps, TracesState> {\n  private fetcher: TracesFetcher;\n  private percentilesPromise: Promise<Map<string, number>>;\n\n  constructor(props: TracesProps) {\n    super(props);\n    let targetApp: string | undefined = undefined;\n    if (this.props.targetKind === 'app') {\n      targetApp = this.props.namespaceSelector ? this.props.target + '.' + this.props.namespace : this.props.target;\n    }\n    this.state = {\n      url: '',\n      width: 0,\n      querySettings: TracesDisplayOptions.retrieveQuerySettings(),\n      displaySettings: TracesDisplayOptions.retrieveDisplaySettings(),\n      traces: [],\n      jaegerErrors: [],\n      targetApp: targetApp,\n      activeTab: getSpanId() ? spansDetailsTab : traceDetailsTab,\n      toolbarDisabled: false\n    };\n    this.fetcher = new TracesFetcher(this.onTracesUpdated, errors => {\n      // If there was traces displayed already, do not hide them so that the user can still interact with them\n      // (consider it's probably a temporary failure)\n      // Note that the error message is anyway displayed in the notifications component, so it's not going unnoticed\n      if (this.state.traces.length === 0) {\n        this.setState({ jaegerErrors: errors, toolbarDisabled: true });\n      }\n    });\n    this.percentilesPromise = this.fetchPercentiles();\n  }\n\n  componentDidMount() {\n    this.fetchTraces();\n  }\n\n  componentDidUpdate(prevProps: TracesProps) {\n    // Selected trace (coming from redux) might have been reloaded and needs to be updated within the traces list\n    // Check reference of selected trace\n    if (this.props.selectedTrace && prevProps.selectedTrace !== this.props.selectedTrace) {\n      const traces = this.state.traces;\n      const trace = this.props.selectedTrace;\n      const index = traces.findIndex(t => t.traceID === trace.traceID);\n      if (index >= 0) {\n        traces[index] = this.props.selectedTrace;\n        this.setState({ traces: traces });\n      }\n    }\n\n    const changedTimeRange = !isEqualTimeRange(this.props.timeRange, prevProps.timeRange);\n    if (this.props.lastRefreshAt !== prevProps.lastRefreshAt || changedTimeRange) {\n      if (changedTimeRange) {\n        this.fetcher.resetLastFetchTime();\n      }\n      this.fetchTraces();\n    }\n  }\n\n  private getTags = () => {\n    return this.state.querySettings.errorsOnly ? '{\"error\":\"true\"}' : '';\n  };\n\n  private fetchTraces = async () => {\n    const options: FetchOptions = {\n      namespace: this.props.namespace,\n      target: this.props.target,\n      targetKind: this.props.targetKind,\n      spanLimit: this.state.querySettings.limit,\n      tags: this.getTags()\n    };\n    if (this.state.querySettings.percentile && this.state.querySettings.percentile !== 'all') {\n      // Fetching traces above a percentile\n      // Percentiles (99th, 90th, 75th) are pre-computed from metrics bound to this app/workload/service object.\n      try {\n        const percentiles = await this.percentilesPromise;\n        options.minDuration = percentiles.get(this.state.querySettings.percentile);\n        if (!options.minDuration) {\n          AlertUtils.addWarning('Cannot perform query above the requested percentile (value unknown).');\n        }\n      } catch (err) {\n        AlertUtils.addError('Could not fetch percentiles.', err);\n      }\n    }\n    this.fetcher.fetch(options, this.state.traces);\n  };\n\n  private fetchPercentiles = (): Promise<Map<string, number>> => {\n    // We'll fetch percentiles on a large enough interval (unrelated to the selected interval)\n    // in order to have stable values and avoid constantly fetching again\n    const query: MetricsStatsQuery = {\n      queryTime: Math.floor(Date.now() / 1000),\n      target: {\n        namespace: this.props.namespace,\n        name: this.props.target,\n        kind: this.props.targetKind\n      },\n      interval: '1h',\n      direction: 'inbound',\n      avg: false,\n      quantiles: percentilesOptions.map(p => p.id).filter(id => id !== 'all')\n    };\n    const queries: MetricsStatsQuery[] =\n      this.props.targetKind === 'service' ? [query] : [query, { ...query, direction: 'outbound' }];\n    return API.getMetricsStats(queries).then(r => this.percentilesFetched(query, r.data));\n  };\n\n  private percentilesFetched = (q: MetricsStatsQuery, r: MetricsStatsResult): Map<string, number> => {\n    if (r.warnings) {\n      AlertUtils.addWarning(r.warnings.join(', '));\n    }\n    const [mapInbound, mapOutbound] = (['inbound', 'outbound'] as Direction[]).map(dir => {\n      const map = new Map<string, number>();\n      const key = genStatsKey(q.target, undefined, dir, q.interval);\n      if (key) {\n        const statsForKey = r.stats[key];\n        if (statsForKey) {\n          statsForKey.responseTimes.forEach(rt => {\n            if (q.quantiles.includes(rt.name)) {\n              map.set(rt.name, rt.value);\n            }\n          });\n        }\n      }\n      return map;\n    });\n    // Merge the two maps; if a value exists in both of them, take the mean\n    const minDurations = new Map<string, number>();\n    mapInbound.forEach((v1, k) => {\n      const v2 = mapOutbound.get(k);\n      if (v2) {\n        minDurations.set(k, (v1 + v2) / 2);\n        mapOutbound.delete(k);\n      } else {\n        minDurations.set(k, v1);\n      }\n    });\n    mapOutbound.forEach((v, k) => minDurations.set(k, v));\n    return minDurations;\n  };\n\n  private onTracesUpdated = (traces: JaegerTrace[], jaegerServiceName: string) => {\n    const newState: Partial<TracesState> = { traces: traces, jaegerErrors: undefined, toolbarDisabled: false };\n    if (this.state.targetApp === undefined && jaegerServiceName) {\n      newState.targetApp = jaegerServiceName;\n    }\n    this.setState(newState as TracesState);\n  };\n\n  private getJaegerUrl = () => {\n    if (this.props.urlJaeger === '' || !this.state.targetApp) {\n      return undefined;\n    }\n\n    const range = getTimeRangeMicros();\n    let url = `${this.props.urlJaeger}/search?service=${this.state.targetApp}&start=${range.from}&limit=${this.state.querySettings.limit}`;\n    if (range.to) {\n      url += `&end=${range.to}`;\n    }\n    const tags = this.getTags();\n    if (tags) {\n      url += `&tags=${tags}`;\n    }\n    return url;\n  };\n\n  private onQuerySettingsChanged = (settings: QuerySettings) => {\n    this.fetcher.resetLastFetchTime();\n    this.setState({ querySettings: settings }, this.fetchTraces);\n  };\n\n  private onDisplaySettingsChanged = (settings: DisplaySettings) => {\n    this.setState({ displaySettings: settings });\n  };\n\n  render() {\n    const jaegerURL = this.getJaegerUrl();\n    return (\n      <>\n        <RenderComponentScroll>\n          <Card>\n            <CardBody>\n              <Toolbar>\n                <ToolbarGroup>\n                  <ToolbarItem>\n                    <TracesDisplayOptions\n                      onDisplaySettingsChanged={this.onDisplaySettingsChanged}\n                      onQuerySettingsChanged={this.onQuerySettingsChanged}\n                      percentilesPromise={this.percentilesPromise}\n                      disabled={this.state.toolbarDisabled}\n                    />\n                  </ToolbarItem>\n                </ToolbarGroup>\n                {jaegerURL && (\n                  <ToolbarGroup style={{ marginLeft: 'auto' }}>\n                    <ToolbarItem>\n                      <Tooltip content={<>Open Chart in Jaeger UI</>}>\n                        <a href={jaegerURL} target=\"_blank\" rel=\"noopener noreferrer\" style={{ marginLeft: '10px' }}>\n                          View in Tracing <ExternalLinkAltIcon />\n                        </a>\n                      </Tooltip>\n                    </ToolbarItem>\n                  </ToolbarGroup>\n                )}\n              </Toolbar>\n              <JaegerScatter\n                showSpansAverage={this.state.displaySettings.showSpansAverage}\n                traces={this.state.traces}\n                errorFetchTraces={this.state.jaegerErrors}\n                errorTraces={true}\n              />\n            </CardBody>\n          </Card>\n          {this.props.selectedTrace && (\n            <div\n              style={{\n                marginTop: 25\n              }}\n            >\n              <Tabs\n                id=\"trace-details\"\n                activeKey={this.state.activeTab}\n                onSelect={(_, idx: any) => this.setState({ activeTab: idx })}\n              >\n                <Tab eventKey={traceDetailsTab} title=\"Trace Details\">\n                  <TraceDetails\n                    namespace={this.props.namespace}\n                    target={this.props.target}\n                    targetKind={this.props.targetKind}\n                    jaegerURL={this.props.urlJaeger}\n                    otherTraces={this.state.traces}\n                  />\n                </Tab>\n                <Tab eventKey={spansDetailsTab} title=\"Spans Details\">\n                  <SpanDetails\n                    namespace={this.props.namespace}\n                    target={this.props.target}\n                    externalURL={this.props.urlJaeger}\n                    items={this.props.selectedTrace.spans}\n                  />\n                </Tab>\n              </Tabs>\n            </div>\n          )}\n        </RenderComponentScroll>\n      </>\n    );\n  }\n}\n\nconst mapStateToProps = (state: KialiAppState) => {\n  return {\n    timeRange: timeRangeSelector(state),\n    urlJaeger: state.jaegerState.info ? state.jaegerState.info.url : '',\n    namespaceSelector: state.jaegerState.info ? state.jaegerState.info.namespaceSelector : true,\n    selectedTrace: state.jaegerState.selectedTrace,\n    lastRefreshAt: state.globalState.lastRefreshAt\n  };\n};\n\nexport const TracesContainer = connect(mapStateToProps)(TracesComponent);\n\nexport default TracesContainer;\n"]},"metadata":{},"sourceType":"module"}