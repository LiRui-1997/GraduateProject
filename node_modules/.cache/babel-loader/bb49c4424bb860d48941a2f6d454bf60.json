{"ast":null,"code":"import _toConsumableArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { PFColors } from 'components/Pf/PfColors';\nimport * as API from 'services/Api';\nimport { durationToBounds, guardTimeRange } from 'types/Common';\nimport * as AlertUtils from 'utils/AlertUtils';\nimport { MetricsObjectTypes } from 'types/Metrics';\nimport { toOverlay } from 'utils/VictoryChartsUtils';\nimport { defaultMetricsDuration } from './Helper';\nexport var SpanOverlay = /*#__PURE__*/function () {\n  function SpanOverlay(onChange) {\n    _classCallCheck(this, SpanOverlay);\n\n    this.onChange = onChange;\n    this.spans = [];\n    this.lastFetchError = false;\n  }\n\n  _createClass(SpanOverlay, [{\n    key: \"reset\",\n    value: function reset() {\n      this.spans = [];\n    }\n  }, {\n    key: \"setSpans\",\n    value: function setSpans(spans) {\n      this.spans = spans;\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(opts) {\n      var _this = this;\n\n      var boundsMillis = guardTimeRange(opts.range, durationToBounds, function (b) {\n        return b;\n      });\n      var defaultFrom = new Date().getTime() - defaultMetricsDuration * 1000;\n      var q = {\n        startMicros: boundsMillis.from ? boundsMillis.from * 1000 : defaultFrom * 1000,\n        endMicros: boundsMillis.to ? boundsMillis.to * 1000 : undefined\n      }; // Remove any out-of-bound spans\n\n      this.spans = this.spans.filter(function (s) {\n        return s.startTime >= q.startMicros && (q.endMicros === undefined || s.startTime <= q.endMicros);\n      }); // Start fetching from last fetched data when available\n\n      if (this.spans.length > 0) {\n        q.startMicros = 1 + Math.max.apply(Math, _toConsumableArray(this.spans.map(function (s) {\n          return s.startTime;\n        })));\n      }\n\n      var apiCall = opts.targetKind === MetricsObjectTypes.APP ? API.getAppSpans : opts.targetKind === MetricsObjectTypes.SERVICE ? API.getServiceSpans : API.getWorkloadSpans;\n      apiCall(opts.namespace, opts.target, q).then(function (res) {\n        _this.lastFetchError = false; // Incremental refresh: we keep existing spans\n\n        _this.spans = _this.spans.concat(res.data);\n\n        _this.onChange(_this.buildOverlay());\n      }).catch(function (err) {\n        if (!_this.lastFetchError) {\n          AlertUtils.addError('Could not fetch spans.', err);\n          _this.lastFetchError = true;\n        }\n      });\n    }\n  }, {\n    key: \"buildOverlay\",\n    value: function buildOverlay() {\n      if (this.spans.length > 0) {\n        var info = {\n          lineInfo: {\n            name: 'Span duration',\n            unit: 'seconds',\n            color: PFColors.Cyan300,\n            symbol: 'circle',\n            size: 10\n          },\n          dataStyle: {\n            fill: function fill(_ref) {\n              var datum = _ref.datum;\n              return datum.error ? PFColors.Danger : PFColors.Cyan300;\n            },\n            fillOpacity: 0.6\n          },\n          buckets: this.spans.length > 1000 ? 15 : 0\n        };\n        var dps = this.spans.map(function (span) {\n          var hasError = span.tags.some(function (tag) {\n            return tag.key === 'error' && tag.value;\n          });\n          var methodTags = span.tags.filter(function (tag) {\n            return tag.key === 'http.method';\n          });\n          var method = methodTags.length > 0 ? methodTags[0].value : undefined;\n          return {\n            name: \"\".concat(method && \"[\".concat(method, \"] \")).concat(span.operationName),\n            x: new Date(span.startTime / 1000),\n            y: Number(span.duration / 1000000),\n            error: hasError,\n            color: hasError ? PFColors.Danger : PFColors.Cyan300,\n            size: 4,\n            traceId: span.traceID,\n            spanId: span.spanID\n          };\n        });\n        return toOverlay(info, dps);\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return SpanOverlay;\n}();","map":{"version":3,"sources":["/root/kiali-ui/src/components/Metrics/SpanOverlay.ts"],"names":["PFColors","API","durationToBounds","guardTimeRange","AlertUtils","MetricsObjectTypes","toOverlay","defaultMetricsDuration","SpanOverlay","onChange","spans","lastFetchError","opts","boundsMillis","range","b","defaultFrom","Date","getTime","q","startMicros","from","endMicros","to","undefined","filter","s","startTime","length","Math","max","map","apiCall","targetKind","APP","getAppSpans","SERVICE","getServiceSpans","getWorkloadSpans","namespace","target","then","res","concat","data","buildOverlay","catch","err","addError","info","lineInfo","name","unit","color","Cyan300","symbol","size","dataStyle","fill","datum","error","Danger","fillOpacity","buckets","dps","span","hasError","tags","some","tag","key","value","methodTags","method","operationName","x","y","Number","duration","traceId","traceID","spanId","spanID"],"mappings":"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","sourcesContent":["import { PFColors } from 'components/Pf/PfColors';\nimport * as API from 'services/Api';\nimport { TimeRange, durationToBounds, guardTimeRange } from 'types/Common';\nimport * as AlertUtils from 'utils/AlertUtils';\nimport { Span, TracingQuery } from 'types/Tracing';\nimport { MetricsObjectTypes } from 'types/Metrics';\nimport { LineInfo } from 'types/VictoryChartInfo';\nimport { Overlay, OverlayInfo } from 'types/Overlay';\nimport { toOverlay } from 'utils/VictoryChartsUtils';\nimport { defaultMetricsDuration } from './Helper';\n\nexport type JaegerLineInfo = LineInfo & { traceId?: string; spanId?: string };\n\ntype FetchOptions = {\n  namespace: string;\n  target: string;\n  targetKind: MetricsObjectTypes;\n  range: TimeRange;\n};\n\nexport class SpanOverlay {\n  private spans: Span[] = [];\n  private lastFetchError = false;\n\n  constructor(public onChange: (overlay?: Overlay<JaegerLineInfo>) => void) {}\n\n  reset() {\n    this.spans = [];\n  }\n\n  setSpans(spans: Span[]) {\n    this.spans = spans;\n  }\n\n  fetch(opts: FetchOptions) {\n    const boundsMillis = guardTimeRange(opts.range, durationToBounds, b => b);\n    const defaultFrom = new Date().getTime() - defaultMetricsDuration * 1000;\n    const q: TracingQuery = {\n      startMicros: boundsMillis.from ? boundsMillis.from * 1000 : defaultFrom * 1000,\n      endMicros: boundsMillis.to ? boundsMillis.to * 1000 : undefined\n    };\n    // Remove any out-of-bound spans\n    this.spans = this.spans.filter(\n      s => s.startTime >= q.startMicros && (q.endMicros === undefined || s.startTime <= q.endMicros)\n    );\n    // Start fetching from last fetched data when available\n    if (this.spans.length > 0) {\n      q.startMicros = 1 + Math.max(...this.spans.map(s => s.startTime));\n    }\n    const apiCall =\n      opts.targetKind === MetricsObjectTypes.APP\n        ? API.getAppSpans\n        : opts.targetKind === MetricsObjectTypes.SERVICE\n        ? API.getServiceSpans\n        : API.getWorkloadSpans;\n    apiCall(opts.namespace, opts.target, q)\n      .then(res => {\n        this.lastFetchError = false;\n        // Incremental refresh: we keep existing spans\n        this.spans = this.spans.concat(res.data);\n        this.onChange(this.buildOverlay());\n      })\n      .catch(err => {\n        if (!this.lastFetchError) {\n          AlertUtils.addError('Could not fetch spans.', err);\n          this.lastFetchError = true;\n        }\n      });\n  }\n\n  private buildOverlay(): Overlay<JaegerLineInfo> | undefined {\n    if (this.spans.length > 0) {\n      const info: OverlayInfo<JaegerLineInfo> = {\n        lineInfo: {\n          name: 'Span duration',\n          unit: 'seconds',\n          color: PFColors.Cyan300,\n          symbol: 'circle',\n          size: 10\n        },\n        dataStyle: { fill: ({ datum }) => (datum.error ? PFColors.Danger : PFColors.Cyan300), fillOpacity: 0.6 },\n        buckets: this.spans.length > 1000 ? 15 : 0\n      };\n      const dps = this.spans.map(span => {\n        const hasError = span.tags.some(tag => tag.key === 'error' && tag.value);\n        const methodTags = span.tags.filter(tag => tag.key === 'http.method');\n        const method = methodTags.length > 0 ? methodTags[0].value : undefined;\n        return {\n          name: `${method && `[${method}] `}${span.operationName}`,\n          x: new Date(span.startTime / 1000),\n          y: Number(span.duration / 1000000),\n          error: hasError,\n          color: hasError ? PFColors.Danger : PFColors.Cyan300,\n          size: 4,\n          traceId: span.traceID,\n          spanId: span.spanID\n        };\n      });\n      return toOverlay(info, dps);\n    }\n    return undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}