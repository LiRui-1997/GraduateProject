{"ast":null,"code":"import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\nimport { getModifier } from '@patternfly/react-styles';\n/**\n * @param {string} input - String to capitalize\n */\n\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pf';\n  var uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return \"\".concat(prefix, \"-\").concat(uid);\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  var _this = this;\n\n  var timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(_this, args);\n    }, wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.floor(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.floor(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  var isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  var isPartiallyInView = partial && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.floor(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.floor(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  var isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  var isOffRight = elementBoundsRight > containerBoundsRight;\n  var side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, function (_, match) {\n    return templateVars[match] || '';\n  });\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids) {\n  var custom = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  var isMultiDimensional = refsCollection.filter(function (ref) {\n    return ref;\n  })[0].constructor === Array;\n  var nextIndex = index;\n  var nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    var element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  var nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === null) {\n    getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = \"\".concat(singular, \"s\");\n  }\n\n  return \"\".concat(i || 0, \" \").concat(i === 1 ? singular : plural);\n}\n/** This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {(DataToolbarBreakpointMod | FlexBreakpointMod | FlexItemBreakpointMod)[]} breakpointMods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport var formatBreakpointMods = function formatBreakpointMods(breakpointMods, styles) {\n  return breakpointMods.reduce(function (acc, curr) {\n    return \"\".concat(acc).concat(acc && ' ').concat(getModifier(styles, \"\".concat(curr.modifier).concat(curr.breakpoint ? \"-on-\".concat(curr.breakpoint) : '')));\n  }, '');\n};\nexport var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);","map":{"version":3,"sources":["/root/kiali-ui/node_modules/@patternfly/react-core/dist/esm/helpers/util.js"],"names":["ReactDOM","SIDE","getModifier","capitalize","input","toUpperCase","substring","getUniqueId","prefix","uid","Date","getTime","Math","random","toString","slice","debounce","func","wait","timeout","args","clearTimeout","setTimeout","apply","isElementInView","container","element","partial","containerBounds","getBoundingClientRect","elementBounds","containerBoundsLeft","floor","left","containerBoundsRight","right","elementBoundsLeft","elementBoundsRight","isTotallyInView","isPartiallyInView","sideElementIsOutOfView","isOffLeft","isOffRight","side","NONE","BOTH","RIGHT","LEFT","fillTemplate","templateString","templateVars","replace","_","match","keyHandler","index","innerIndex","position","refsCollection","kids","custom","Array","isArray","isMultiDimensional","filter","ref","constructor","nextIndex","nextInnerIndex","length","undefined","focus","findDOMNode","getNextIndex","collection","pluralize","i","singular","plural","formatBreakpointMods","breakpointMods","styles","reduce","acc","curr","modifier","breakpoint","canUseDOM","window","document","createElement"],"mappings":"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","sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { SIDE } from './constants';\nimport { getModifier } from '@patternfly/react-styles';\n\n/**\n * @param {string} input - String to capitalize\n */\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\n\nexport function getUniqueId(prefix = 'pf') {\n  const uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return `${prefix}-${uid}`;\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\n\nexport function debounce(func, wait) {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n *\n * @returns { boolean } True if the component is in View.\n */\n\nexport function isElementInView(container, element, partial) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView = partial && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight); // Return outcome\n\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\n\nexport function sideElementIsOutOfView(container, element) {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right); // Check if in view\n\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  } // Return outcome\n\n\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\n\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\n\nexport function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    } // eslint-disable-next-line react/no-find-dom-node\n\n\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\n\nexport function getNextIndex(index, position, collection) {\n  let nextIndex;\n\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n\n  if (collection[nextIndex] === null) {\n    getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\n\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n/** This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {(DataToolbarBreakpointMod | FlexBreakpointMod | FlexItemBreakpointMod)[]} breakpointMods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\n\nexport const formatBreakpointMods = (breakpointMods, styles) => breakpointMods.reduce((acc, curr) => `${acc}${acc && ' '}${getModifier(styles, `${curr.modifier}${curr.breakpoint ? `-on-${curr.breakpoint}` : ''}`)}`, '');\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}