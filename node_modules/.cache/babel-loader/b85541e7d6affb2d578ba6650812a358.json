{"ast":null,"code":"import _slicedToArray from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { getRequestErrorsStatus, HEALTHY, NA, RATIO_NA } from '../Health';\nimport { checkExpr, emptyRate, getRateHealthConfig, getErrorCodeRate } from './utils';\nimport { RateHealth } from '../HealthAnnotation'; // Sum the inbound and outbound request for calculating the global status\n\nexport var sumRequests = function sumRequests(inbound, outbound) {\n  var result = {}; // init result with a deep clone of inbound\n\n  for (var _i = 0, _Object$entries = Object.entries(inbound); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        protocol = _Object$entries$_i[0],\n        req = _Object$entries$_i[1];\n\n    result[protocol] = {};\n\n    for (var _i2 = 0, _Object$entries2 = Object.entries(req); _i2 < _Object$entries2.length; _i2++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n          code = _Object$entries2$_i[0],\n          rate = _Object$entries2$_i[1];\n\n      result[protocol][code] = rate;\n    }\n  }\n\n  for (var _i3 = 0, _Object$entries3 = Object.entries(outbound); _i3 < _Object$entries3.length; _i3++) {\n    var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),\n        _protocol = _Object$entries3$_i[0],\n        _req = _Object$entries3$_i[1];\n\n    if (!Object.keys(result).includes(_protocol)) {\n      result[_protocol] = {};\n    }\n\n    for (var _i4 = 0, _Object$entries4 = Object.entries(_req); _i4 < _Object$entries4.length; _i4++) {\n      var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i4], 2),\n          _code = _Object$entries4$_i[0],\n          _rate = _Object$entries4$_i[1];\n\n      if (!Object.keys(result[_protocol]).includes(_code)) {\n        result[_protocol][_code] = 0;\n      }\n\n      result[_protocol][_code] += _rate;\n    }\n  }\n\n  return result;\n};\n\nvar getAggregate = function getAggregate(requests, conf) {\n  // Get all tolerances where direction is inbound\n  var inboundTolerances = conf.filter(function (tol) {\n    return checkExpr(tol.direction, 'inbound');\n  }); // Get all tolerances where direction is outbound\n\n  var outboundTolerances = conf.filter(function (tol) {\n    return checkExpr(tol.direction, 'outbound');\n  });\n  return {\n    global: aggregate(sumRequests(requests.inbound, requests.outbound), conf),\n    inbound: aggregate(requests.inbound, inboundTolerances),\n    outbound: aggregate(requests.outbound, outboundTolerances)\n  };\n};\n\nexport var calculateErrorRate = function calculateErrorRate(ns, name, kind, requests) {\n  // Get the first configuration that match with the case\n  var rateAnnotation = new RateHealth(requests.healthAnnotations);\n  var conf = rateAnnotation.toleranceConfig || getRateHealthConfig(ns, name, kind).tolerance; // Get aggregate\n\n  var status = getAggregate(requests, conf);\n  var globalStatus = calculateStatus(status.global);\n\n  if (globalStatus.status.status !== HEALTHY) {\n    return {\n      errorRatio: {\n        global: globalStatus,\n        inbound: calculateStatus(status.inbound),\n        outbound: calculateStatus(status.outbound)\n      },\n      config: conf\n    };\n  }\n\n  var result = {\n    errorRatio: {\n      global: globalStatus,\n      inbound: calculateStatus(status.inbound),\n      outbound: calculateStatus(status.outbound)\n    },\n    config: conf\n  }; // IF status is HEALTHY return errorCodes\n\n  if (result.errorRatio.inbound.status.status === HEALTHY || result.errorRatio.outbound.status.status === HEALTHY) {\n    var valuesErrorCodes = getErrorCodeRate(requests);\n    result.errorRatio.inbound.status.value = result.errorRatio.inbound.status.status === HEALTHY ? valuesErrorCodes.inbound : result.errorRatio.inbound.status.value;\n    result.errorRatio.outbound.status.value = result.errorRatio.outbound.status.status === HEALTHY ? valuesErrorCodes.outbound : result.errorRatio.outbound.status.value;\n  } // In that case we want to keep values\n\n\n  return result;\n};\nexport var calculateStatus = function calculateStatus(requestTolerances) {\n  var result = {\n    status: {\n      value: RATIO_NA,\n      status: NA\n    },\n    protocol: '',\n    toleranceConfig: undefined\n  };\n\n  for (var _i5 = 0, _Object$values = Object.values(requestTolerances); _i5 < _Object$values.length; _i5++) {\n    var reqTol = _Object$values[_i5];\n\n    for (var _i6 = 0, _Object$entries5 = Object.entries(reqTol.requests); _i6 < _Object$entries5.length; _i6++) {\n      var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i6], 2),\n          protocol = _Object$entries5$_i[0],\n          rate = _Object$entries5$_i[1];\n\n      var tolerance = reqTol.tolerance && checkExpr(reqTol.tolerance.protocol, protocol) ? reqTol.tolerance : undefined; // Calculate the status for the tolerance provided\n\n      var auxStatus = getRequestErrorsStatus(rate.errorRatio, tolerance); // Check the priority of the status\n\n      if (auxStatus.status.priority > result.status.status.priority) {\n        result.status = auxStatus;\n        result.protocol = protocol;\n        result.toleranceConfig = reqTol.tolerance;\n      }\n    }\n  }\n\n  return result;\n};\nexport var generateRateForTolerance = function generateRateForTolerance(tol, requests) {\n  for (var _i7 = 0, _Object$entries6 = Object.entries(requests); _i7 < _Object$entries6.length; _i7++) {\n    var _Object$entries6$_i = _slicedToArray(_Object$entries6[_i7], 2),\n        protocol = _Object$entries6$_i[0],\n        req = _Object$entries6$_i[1];\n\n    if (checkExpr(tol.tolerance.protocol, protocol)) {\n      for (var _i8 = 0, _Object$entries7 = Object.entries(req); _i8 < _Object$entries7.length; _i8++) {\n        var _Object$entries7$_i = _slicedToArray(_Object$entries7[_i8], 2),\n            code = _Object$entries7$_i[0],\n            value = _Object$entries7$_i[1];\n\n        if (!Object.keys(tol.requests).includes(protocol)) {\n          tol.requests[protocol] = emptyRate();\n        }\n\n        tol.requests[protocol].requestRate += Number(value);\n\n        if (checkExpr(tol.tolerance.code, code)) {\n          tol.requests[protocol].errorRate += Number(value);\n        }\n      }\n    }\n\n    if (Object.keys(tol.requests).includes(protocol)) {\n      if (tol.requests[protocol].requestRate === 0) {\n        tol.requests[protocol].errorRatio = -1;\n      } else {\n        tol.requests[protocol].errorRatio = tol.requests[protocol].errorRate / tol.requests[protocol].requestRate;\n      }\n    }\n  }\n}; // Aggregate the results\n\nexport var aggregate = function aggregate(request, tolerances) {\n  var result = [];\n\n  if (request && tolerances) {\n    for (var _i9 = 0, _Object$values2 = Object.values(tolerances); _i9 < _Object$values2.length; _i9++) {\n      var tol = _Object$values2[_i9];\n      var newReqTol = {\n        tolerance: tol,\n        requests: {}\n      };\n      generateRateForTolerance(newReqTol, request);\n      result.push(newReqTol);\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/root/kiali-ui/src/types/ErrorRate/ErrorRate.ts"],"names":["getRequestErrorsStatus","HEALTHY","NA","RATIO_NA","checkExpr","emptyRate","getRateHealthConfig","getErrorCodeRate","RateHealth","sumRequests","inbound","outbound","result","Object","entries","protocol","req","code","rate","keys","includes","getAggregate","requests","conf","inboundTolerances","filter","tol","direction","outboundTolerances","global","aggregate","calculateErrorRate","ns","name","kind","rateAnnotation","healthAnnotations","toleranceConfig","tolerance","status","globalStatus","calculateStatus","errorRatio","config","valuesErrorCodes","value","requestTolerances","undefined","values","reqTol","auxStatus","priority","generateRateForTolerance","requestRate","Number","errorRate","request","tolerances","newReqTol","push"],"mappings":"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","sourcesContent":["import { getRequestErrorsStatus, HEALTHY, NA, RATIO_NA, RequestHealth, RequestType, ThresholdStatus } from '../Health';\nimport { ToleranceConfig } from '../ServerConfig';\nimport { checkExpr, emptyRate, getRateHealthConfig, getErrorCodeRate } from './utils';\nimport { ErrorRatio, Rate, RequestTolerance } from './types';\nimport { RateHealth } from '../HealthAnnotation';\n\n// Sum the inbound and outbound request for calculating the global status\nexport const sumRequests = (inbound: RequestType, outbound: RequestType): RequestType => {\n  let result: RequestType = {};\n  // init result with a deep clone of inbound\n  for (let [protocol, req] of Object.entries(inbound)) {\n    result[protocol] = {};\n    for (let [code, rate] of Object.entries(req)) {\n      result[protocol][code] = rate;\n    }\n  }\n  for (let [protocol, req] of Object.entries(outbound)) {\n    if (!Object.keys(result).includes(protocol)) {\n      result[protocol] = {};\n    }\n    for (let [code, rate] of Object.entries(req)) {\n      if (!Object.keys(result[protocol]).includes(code)) {\n        result[protocol][code] = 0;\n      }\n      result[protocol][code] += rate;\n    }\n  }\n  return result;\n};\n\nconst getAggregate = (\n  requests: RequestHealth,\n  conf: ToleranceConfig[]\n): { global: RequestTolerance[]; inbound: RequestTolerance[]; outbound: RequestTolerance[] } => {\n  // Get all tolerances where direction is inbound\n  const inboundTolerances = conf.filter(tol => checkExpr(tol.direction, 'inbound'));\n  // Get all tolerances where direction is outbound\n  const outboundTolerances = conf.filter(tol => checkExpr(tol.direction, 'outbound'));\n\n  return {\n    global: aggregate(sumRequests(requests.inbound, requests.outbound), conf),\n    inbound: aggregate(requests.inbound, inboundTolerances),\n    outbound: aggregate(requests.outbound, outboundTolerances)\n  };\n};\n\nexport const calculateErrorRate = (\n  ns: string,\n  name: string,\n  kind: string,\n  requests: RequestHealth\n): { errorRatio: ErrorRatio; config: ToleranceConfig[] } => {\n  // Get the first configuration that match with the case\n  const rateAnnotation = new RateHealth(requests.healthAnnotations);\n  const conf = rateAnnotation.toleranceConfig || getRateHealthConfig(ns, name, kind).tolerance;\n\n  // Get aggregate\n  let status = getAggregate(requests, conf);\n  const globalStatus = calculateStatus(status.global);\n\n  if (globalStatus.status.status !== HEALTHY) {\n    return {\n      errorRatio: {\n        global: globalStatus,\n        inbound: calculateStatus(status.inbound),\n        outbound: calculateStatus(status.outbound)\n      },\n      config: conf\n    };\n  }\n  const result = {\n    errorRatio: {\n      global: globalStatus,\n      inbound: calculateStatus(status.inbound),\n      outbound: calculateStatus(status.outbound)\n    },\n    config: conf\n  };\n\n  // IF status is HEALTHY return errorCodes\n  if (result.errorRatio.inbound.status.status === HEALTHY || result.errorRatio.outbound.status.status === HEALTHY) {\n    const valuesErrorCodes = getErrorCodeRate(requests);\n    result.errorRatio.inbound.status.value =\n      result.errorRatio.inbound.status.status === HEALTHY\n        ? valuesErrorCodes.inbound\n        : result.errorRatio.inbound.status.value;\n    result.errorRatio.outbound.status.value =\n      result.errorRatio.outbound.status.status === HEALTHY\n        ? valuesErrorCodes.outbound\n        : result.errorRatio.outbound.status.value;\n  }\n  // In that case we want to keep values\n  return result;\n};\n\nexport const calculateStatus = (\n  requestTolerances: RequestTolerance[]\n): { status: ThresholdStatus; protocol: string; toleranceConfig?: ToleranceConfig } => {\n  let result: { status: ThresholdStatus; protocol: string; toleranceConfig?: ToleranceConfig } = {\n    status: {\n      value: RATIO_NA,\n      status: NA\n    },\n    protocol: '',\n    toleranceConfig: undefined\n  };\n\n  for (let reqTol of Object.values(requestTolerances)) {\n    for (let [protocol, rate] of Object.entries(reqTol.requests)) {\n      const tolerance =\n        reqTol.tolerance && checkExpr(reqTol!.tolerance!.protocol, protocol) ? reqTol.tolerance : undefined;\n      // Calculate the status for the tolerance provided\n      const auxStatus = getRequestErrorsStatus((rate as Rate).errorRatio, tolerance);\n      // Check the priority of the status\n      if (auxStatus.status.priority > result.status.status.priority) {\n        result.status = auxStatus;\n        result.protocol = protocol;\n        result.toleranceConfig = reqTol.tolerance;\n      }\n    }\n  }\n  return result;\n};\n\nexport const generateRateForTolerance = (\n  tol: RequestTolerance,\n  requests: { [key: string]: { [key: string]: number } }\n) => {\n  for (let [protocol, req] of Object.entries(requests)) {\n    if (checkExpr(tol!.tolerance!.protocol, protocol)) {\n      for (let [code, value] of Object.entries(req)) {\n        if (!Object.keys(tol.requests).includes(protocol)) {\n          tol.requests[protocol] = emptyRate();\n        }\n        (tol.requests[protocol] as Rate).requestRate += Number(value);\n        if (checkExpr(tol!.tolerance!.code, code)) {\n          (tol.requests[protocol] as Rate).errorRate += Number(value);\n        }\n      }\n    }\n    if (Object.keys(tol.requests).includes(protocol)) {\n      if ((tol.requests[protocol] as Rate).requestRate === 0) {\n        (tol.requests[protocol] as Rate).errorRatio = -1;\n      } else {\n        (tol.requests[protocol] as Rate).errorRatio =\n          (tol.requests[protocol] as Rate).errorRate / (tol.requests[protocol] as Rate).requestRate;\n      }\n    }\n  }\n};\n\n// Aggregate the results\nexport const aggregate = (request: RequestType, tolerances?: ToleranceConfig[]): RequestTolerance[] => {\n  let result: RequestTolerance[] = [];\n  if (request && tolerances) {\n    for (let tol of Object.values(tolerances)) {\n      let newReqTol: RequestTolerance = { tolerance: tol, requests: {} };\n      generateRateForTolerance(newReqTol, request);\n      result.push(newReqTol);\n    }\n  }\n  return result;\n};\n"]},"metadata":{},"sourceType":"module"}