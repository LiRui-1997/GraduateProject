{"ast":null,"code":"import * as FreeStyle from \"free-style\";\nimport { ensureStringObj, explodeKeyframes } from './formatting';\nimport { extend, raf } from './utilities';\n/**\n * Creates an instance of free style with our options\n */\n\nvar createFreeStyle = function createFreeStyle() {\n  return FreeStyle.create(\n  /** Use the default hash function */\n  undefined,\n  /** Preserve $debugName values */\n  true);\n};\n/**\n * Maintains a single stylesheet and keeps it in sync with requested styles\n */\n\n\nvar TypeStyle =\n/** @class */\nfunction () {\n  function TypeStyle(_a) {\n    var autoGenerateTag = _a.autoGenerateTag;\n\n    var _this = this;\n    /**\n     * Insert `raw` CSS as a string. This is useful for e.g.\n     * - third party CSS that you are customizing with template strings\n     * - generating raw CSS in JavaScript\n     * - reset libraries like normalize.css that you can use without loaders\n     */\n\n\n    this.cssRaw = function (mustBeValidCSS) {\n      if (!mustBeValidCSS) {\n        return;\n      }\n\n      _this._raw += mustBeValidCSS || '';\n      _this._pendingRawChange = true;\n\n      _this._styleUpdated();\n    };\n    /**\n     * Takes CSSProperties and registers it to a global selector (body, html, etc.)\n     */\n\n\n    this.cssRule = function (selector) {\n      var objects = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n      }\n\n      var object = ensureStringObj(extend.apply(void 0, objects)).result;\n\n      _this._freeStyle.registerRule(selector, object);\n\n      _this._styleUpdated();\n\n      return;\n    };\n    /**\n     * Renders styles to the singleton tag imediately\n     * NOTE: You should only call it on initial render to prevent any non CSS flash.\n     * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.\n     **/\n\n\n    this.forceRenderStyles = function () {\n      var target = _this._getTag();\n\n      if (!target) {\n        return;\n      }\n\n      target.textContent = _this.getStyles();\n    };\n    /**\n     * Utility function to register an @font-face\n     */\n\n\n    this.fontFace = function () {\n      var fontFace = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        fontFace[_i] = arguments[_i];\n      }\n\n      var freeStyle = _this._freeStyle;\n\n      for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {\n        var face = _b[_a];\n        freeStyle.registerRule('@font-face', face);\n      }\n\n      _this._styleUpdated();\n\n      return;\n    };\n    /**\n     * Allows use to use the stylesheet in a node.js environment\n     */\n\n\n    this.getStyles = function () {\n      return (_this._raw || '') + _this._freeStyle.getStyles();\n    };\n    /**\n     * Takes keyframes and returns a generated animationName\n     */\n\n\n    this.keyframes = function (frames) {\n      var _a = explodeKeyframes(frames),\n          keyframes = _a.keyframes,\n          $debugName = _a.$debugName; // TODO: replace $debugName with display name\n\n\n      var animationName = _this._freeStyle.registerKeyframes(keyframes, $debugName);\n\n      _this._styleUpdated();\n\n      return animationName;\n    };\n    /**\n     * Helps with testing. Reinitializes FreeStyle + raw\n     */\n\n\n    this.reinit = function () {\n      /** reinit freestyle */\n      var freeStyle = createFreeStyle();\n      _this._freeStyle = freeStyle;\n      _this._lastFreeStyleChangeId = freeStyle.changeId;\n      /** reinit raw */\n\n      _this._raw = '';\n      _this._pendingRawChange = false;\n      /** Clear any styles that were flushed */\n\n      var target = _this._getTag();\n\n      if (target) {\n        target.textContent = '';\n      }\n    };\n    /** Sets the target tag where we write the css on style updates */\n\n\n    this.setStylesTarget = function (tag) {\n      /** Clear any data in any previous tag */\n      if (_this._tag) {\n        _this._tag.textContent = '';\n      }\n\n      _this._tag = tag;\n      /** This special time buffer immediately */\n\n      _this.forceRenderStyles();\n    };\n    /**\n     * Takes an object where property names are ideal class names and property values are CSSProperties, and\n     * returns an object where property names are the same ideal class names and the property values are\n     * the actual generated class names using the ideal class name as the $debugName\n     */\n\n\n    this.stylesheet = function (classes) {\n      var classNames = Object.getOwnPropertyNames(classes);\n      var result = {};\n\n      for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {\n        var className = classNames_1[_i];\n        var classDef = classes[className];\n\n        if (classDef) {\n          classDef.$debugName = className;\n          result[className] = _this.style(classDef);\n        }\n      }\n\n      return result;\n    };\n\n    var freeStyle = createFreeStyle();\n    this._autoGenerateTag = autoGenerateTag;\n    this._freeStyle = freeStyle;\n    this._lastFreeStyleChangeId = freeStyle.changeId;\n    this._pending = 0;\n    this._pendingRawChange = false;\n    this._raw = '';\n    this._tag = undefined; // rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}\n\n    this.style = this.style.bind(this);\n  }\n  /**\n   * Only calls cb all sync operations settle\n   */\n\n\n  TypeStyle.prototype._afterAllSync = function (cb) {\n    var _this = this;\n\n    this._pending++;\n    var pending = this._pending;\n    raf(function () {\n      if (pending !== _this._pending) {\n        return;\n      }\n\n      cb();\n    });\n  };\n\n  TypeStyle.prototype._getTag = function () {\n    if (this._tag) {\n      return this._tag;\n    }\n\n    if (this._autoGenerateTag) {\n      var tag = typeof window === 'undefined' ? {\n        textContent: ''\n      } : document.createElement('style');\n\n      if (typeof document !== 'undefined') {\n        document.head.appendChild(tag);\n      }\n\n      this._tag = tag;\n      return tag;\n    }\n\n    return undefined;\n  };\n  /** Checks if the style tag needs updating and if so queues up the change */\n\n\n  TypeStyle.prototype._styleUpdated = function () {\n    var _this = this;\n\n    var changeId = this._freeStyle.changeId;\n    var lastChangeId = this._lastFreeStyleChangeId;\n\n    if (!this._pendingRawChange && changeId === lastChangeId) {\n      return;\n    }\n\n    this._lastFreeStyleChangeId = changeId;\n    this._pendingRawChange = false;\n\n    this._afterAllSync(function () {\n      return _this.forceRenderStyles();\n    });\n  };\n\n  TypeStyle.prototype.style = function () {\n    var freeStyle = this._freeStyle;\n\n    var _a = ensureStringObj(extend.apply(undefined, arguments)),\n        result = _a.result,\n        debugName = _a.debugName;\n\n    var className = debugName ? freeStyle.registerStyle(result, debugName) : freeStyle.registerStyle(result);\n\n    this._styleUpdated();\n\n    return className;\n  };\n\n  return TypeStyle;\n}();\n\nexport { TypeStyle };","map":null,"metadata":{},"sourceType":"module"}