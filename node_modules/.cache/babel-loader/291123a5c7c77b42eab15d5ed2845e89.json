{"ast":null,"code":"import _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nexport var CancelablePromise = /*#__PURE__*/function () {\n  function CancelablePromise(promise) {\n    var _this = this;\n\n    _classCallCheck(this, CancelablePromise);\n\n    this.promise = void 0;\n    this.next = void 0;\n    this.hasCanceled = false;\n    this.promise = new Promise(function (resolve, reject) {\n      promise.then(function (val) {\n        return _this.hasCanceled ? reject({\n          isCanceled: true\n        }) : resolve(val);\n      }, function (error) {\n        return _this.hasCanceled ? reject({\n          isCanceled: true\n        }) : reject(error);\n      });\n    });\n  }\n\n  _createClass(CancelablePromise, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.hasCanceled = true;\n\n      if (this.next) {\n        this.next.cancel();\n      }\n    }\n  }, {\n    key: \"chain\",\n    value: function chain(mapper) {\n      var _this2 = this;\n\n      var last = this;\n\n      while (last.next) {\n        last = last.next;\n      }\n\n      last.next = new CancelablePromise(this.promise.then(function (t) {\n        return _this2.hasCanceled ? t : mapper(t);\n      }));\n      this.promise = last.next.promise;\n      return last.next;\n    }\n  }]);\n\n  return CancelablePromise;\n}();\nexport var makeCancelablePromise = function makeCancelablePromise(promise) {\n  return new CancelablePromise(promise);\n};\nexport var PromisesRegistry = /*#__PURE__*/function () {\n  function PromisesRegistry() {\n    _classCallCheck(this, PromisesRegistry);\n\n    this.promises = new Map();\n  }\n\n  _createClass(PromisesRegistry, [{\n    key: \"register\",\n    value: function register(key, promise) {\n      var previous = this.promises.get(key);\n\n      if (previous) {\n        previous.cancel();\n      }\n\n      var cancelable = makeCancelablePromise(promise);\n      this.promises.set(key, cancelable);\n      return cancelable.promise;\n    }\n  }, {\n    key: \"registerChained\",\n    value: function registerChained(key, initial, mapper) {\n      var previous = this.promises.get(key);\n\n      if (previous) {\n        previous.chain(mapper);\n        return previous.promise;\n      } else {\n        var cancelable = new CancelablePromise(mapper(initial));\n        this.promises.set(key, cancelable);\n        return cancelable.promise;\n      }\n    }\n  }, {\n    key: \"registerAll\",\n    value: function registerAll(key, promises) {\n      return this.register(key, Promise.all(promises));\n    }\n  }, {\n    key: \"cancelAll\",\n    value: function cancelAll() {\n      this.promises.forEach(function (promise) {\n        return promise.cancel();\n      });\n      this.promises.clear();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(key) {\n      var previous = this.promises.get(key);\n\n      if (previous) {\n        previous.cancel();\n        this.promises.delete(key);\n      }\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.promises.has(key);\n    }\n  }]);\n\n  return PromisesRegistry;\n}();","map":{"version":3,"sources":["/root/kiali-ui/src/utils/CancelablePromises.ts"],"names":["CancelablePromise","promise","next","hasCanceled","Promise","resolve","reject","then","val","isCanceled","error","cancel","mapper","last","t","makeCancelablePromise","PromisesRegistry","promises","Map","key","previous","get","cancelable","set","initial","chain","register","all","forEach","clear","delete","has"],"mappings":";;AAAA,WAAaA,iBAAb;AAKE,6BAAYC,OAAZ,EAAiC;AAAA;;AAAA;;AAAA,SAJjCA,OAIiC;AAAA,SAHjCC,IAGiC;AAAA,SAFzBC,WAEyB,GAFX,KAEW;AAC/B,SAAKF,OAAL,GAAe,IAAIG,OAAJ,CAAe,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACjDL,MAAAA,OAAO,CAACM,IAAR,CACE,UAAAC,GAAG;AAAA,eAAK,KAAI,CAACL,WAAL,GAAmBG,MAAM,CAAC;AAAEG,UAAAA,UAAU,EAAE;AAAd,SAAD,CAAzB,GAAkDJ,OAAO,CAACG,GAAD,CAA9D;AAAA,OADL,EAEE,UAAAE,KAAK;AAAA,eAAK,KAAI,CAACP,WAAL,GAAmBG,MAAM,CAAC;AAAEG,UAAAA,UAAU,EAAE;AAAd,SAAD,CAAzB,GAAkDH,MAAM,CAACI,KAAD,CAA7D;AAAA,OAFP;AAID,KALc,CAAf;AAMD;;AAZH;AAAA;AAAA,WAcE,kBAAS;AACP,WAAKP,WAAL,GAAmB,IAAnB;;AACA,UAAI,KAAKD,IAAT,EAAe;AACb,aAAKA,IAAL,CAAUS,MAAV;AACD;AACF;AAnBH;AAAA;AAAA,WAqBE,eAAMC,MAAN,EAA0D;AAAA;;AACxD,UAAIC,IAA0B,GAAG,IAAjC;;AACA,aAAOA,IAAI,CAACX,IAAZ,EAAkB;AAChBW,QAAAA,IAAI,GAAGA,IAAI,CAACX,IAAZ;AACD;;AACDW,MAAAA,IAAI,CAACX,IAAL,GAAY,IAAIF,iBAAJ,CAAyB,KAAKC,OAAL,CAAaM,IAAb,CAAkB,UAAAO,CAAC;AAAA,eAAK,MAAI,CAACX,WAAL,GAAmBW,CAAnB,GAAuBF,MAAM,CAACE,CAAD,CAAlC;AAAA,OAAnB,CAAzB,CAAZ;AACA,WAAKb,OAAL,GAAeY,IAAI,CAACX,IAAL,CAAUD,OAAzB;AACA,aAAOY,IAAI,CAACX,IAAZ;AACD;AA7BH;;AAAA;AAAA;AAgCA,OAAO,IAAMa,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAId,OAAJ,EAAkD;AACrF,SAAO,IAAID,iBAAJ,CAAsBC,OAAtB,CAAP;AACD,CAFM;AAIP,WAAae,gBAAb;AAAA;AAAA;;AAAA,SACUC,QADV,GAC0D,IAAIC,GAAJ,EAD1D;AAAA;;AAAA;AAAA;AAAA,WAGE,kBAAYC,GAAZ,EAAyBlB,OAAzB,EAA0D;AACxD,UAAMmB,QAAQ,GAAG,KAAKH,QAAL,CAAcI,GAAd,CAAkBF,GAAlB,CAAjB;;AACA,UAAIC,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACT,MAAT;AACD;;AACD,UAAMW,UAAU,GAAGP,qBAAqB,CAACd,OAAD,CAAxC;AACA,WAAKgB,QAAL,CAAcM,GAAd,CAAkBJ,GAAlB,EAAuBG,UAAvB;AACA,aAAOA,UAAU,CAACrB,OAAlB;AACD;AAXH;AAAA;AAAA,WAaE,yBAAmBkB,GAAnB,EAAgCK,OAAhC,EAA4CZ,MAA5C,EAAsF;AACpF,UAAMQ,QAAQ,GAAG,KAAKH,QAAL,CAAcI,GAAd,CAAkBF,GAAlB,CAAjB;;AACA,UAAIC,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACK,KAAT,CAAeb,MAAf;AACA,eAAOQ,QAAQ,CAACnB,OAAhB;AACD,OAHD,MAGO;AACL,YAAMqB,UAAU,GAAG,IAAItB,iBAAJ,CAAsBY,MAAM,CAACY,OAAD,CAA5B,CAAnB;AACA,aAAKP,QAAL,CAAcM,GAAd,CAAkBJ,GAAlB,EAAuBG,UAAvB;AACA,eAAOA,UAAU,CAACrB,OAAlB;AACD;AACF;AAvBH;AAAA;AAAA,WAyBE,qBAAekB,GAAf,EAA4BF,QAA5B,EAAkE;AAChE,aAAO,KAAKS,QAAL,CAAcP,GAAd,EAAmBf,OAAO,CAACuB,GAAR,CAAYV,QAAZ,CAAnB,CAAP;AACD;AA3BH;AAAA;AAAA,WA6BE,qBAAY;AACV,WAAKA,QAAL,CAAcW,OAAd,CAAsB,UAAA3B,OAAO;AAAA,eAAIA,OAAO,CAACU,MAAR,EAAJ;AAAA,OAA7B;AACA,WAAKM,QAAL,CAAcY,KAAd;AACD;AAhCH;AAAA;AAAA,WAkCE,gBAAOV,GAAP,EAAoB;AAClB,UAAMC,QAAQ,GAAG,KAAKH,QAAL,CAAcI,GAAd,CAAkBF,GAAlB,CAAjB;;AACA,UAAIC,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAACT,MAAT;AACA,aAAKM,QAAL,CAAca,MAAd,CAAqBX,GAArB;AACD;AACF;AAxCH;AAAA;AAAA,WA0CE,aAAIA,GAAJ,EAA0B;AACxB,aAAO,KAAKF,QAAL,CAAcc,GAAd,CAAkBZ,GAAlB,CAAP;AACD;AA5CH;;AAAA;AAAA","sourcesContent":["export class CancelablePromise<T> {\n  promise: Promise<T>;\n  next?: CancelablePromise<T>;\n  private hasCanceled = false;\n\n  constructor(promise: Promise<T>) {\n    this.promise = new Promise<T>((resolve, reject) => {\n      promise.then(\n        val => (this.hasCanceled ? reject({ isCanceled: true }) : resolve(val)),\n        error => (this.hasCanceled ? reject({ isCanceled: true }) : reject(error))\n      );\n    });\n  }\n\n  cancel() {\n    this.hasCanceled = true;\n    if (this.next) {\n      this.next.cancel();\n    }\n  }\n\n  chain(mapper: (t: T) => Promise<T>): CancelablePromise<T> {\n    let last: CancelablePromise<T> = this;\n    while (last.next) {\n      last = last.next;\n    }\n    last.next = new CancelablePromise<T>(this.promise.then(t => (this.hasCanceled ? t : mapper(t))));\n    this.promise = last.next.promise;\n    return last.next;\n  }\n}\n\nexport const makeCancelablePromise = <T>(promise: Promise<T>): CancelablePromise<T> => {\n  return new CancelablePromise(promise);\n};\n\nexport class PromisesRegistry {\n  private promises: Map<string, CancelablePromise<any>> = new Map();\n\n  register<T>(key: string, promise: Promise<T>): Promise<T> {\n    const previous = this.promises.get(key);\n    if (previous) {\n      previous.cancel();\n    }\n    const cancelable = makeCancelablePromise(promise);\n    this.promises.set(key, cancelable);\n    return cancelable.promise;\n  }\n\n  registerChained<T>(key: string, initial: T, mapper: (t: T) => Promise<T>): Promise<T> {\n    const previous = this.promises.get(key);\n    if (previous) {\n      previous.chain(mapper);\n      return previous.promise;\n    } else {\n      const cancelable = new CancelablePromise(mapper(initial));\n      this.promises.set(key, cancelable);\n      return cancelable.promise;\n    }\n  }\n\n  registerAll<T>(key: string, promises: Promise<T>[]): Promise<T[]> {\n    return this.register(key, Promise.all(promises));\n  }\n\n  cancelAll() {\n    this.promises.forEach(promise => promise.cancel());\n    this.promises.clear();\n  }\n\n  cancel(key: string) {\n    const previous = this.promises.get(key);\n    if (previous) {\n      previous.cancel();\n      this.promises.delete(key);\n    }\n  }\n\n  has(key: string): boolean {\n    return this.promises.has(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}