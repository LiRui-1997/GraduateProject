{"ast":null,"code":"import _createForOfIteratorHelper from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n  BoxLayout\n\n  This is a synthetic layout that helps to better layout the contents of box (i.e. compound)\n  nodes, in this way we ensure that the box nodes themselves are as small as possible, and avoiding\n  overlaps with other nodes.\n\n  It finishes by executing the default (i.e. user-selected) layout but prior to that will\n  individually layout the box node contents using the requested layouts.\n\n  Is composed of:\n   - The [optional] configured box layouts will layout the children of the box node.\n     - appBoxLayout, clusterBoxLayout, namespaceBoxLayout\n   - The [required] configured defaultLayout is used for any box layouts not otherwise specified, and is\n     applied for the final layout.\n   - A Synthetic edge generator creates synthetic edges (more info below).\n\n  The algorithm is roughly as follow:\n\n  1. For every box type (working inner to outer)\n       2. For every box node:\n          a. The box layout is run for every box and its relative positions (to the parent)\n             are saved for later use.\n          b. Get the resulting bounding box of the compound node, set the width and height of the node\n             using `cy.style`, so that the real layout honors the size when doing the layout.\n          c. For every edge that goes to a child (or comes from a child), create a synthetic edge\n            that goes to (or comes from) the compound node and remove the original\n            edge. We can cull away repeated edges as they are not needed.\n          d. Remove the children. This is important, else cytoscape won't honor the size specified\n             in previous step. \"A compound parent node does not have independent dimensions (position\n             and size), as those values are automatically inferred by the positions and dimensions\n             of the descendant nodes.\" http://js.cytoscape.org/#notation/compound-nodes\n  3. Run the default layout on this new graph and wait until it finishes.\n     a. Restore the children.\n     b. Remove the synthetic edges.\n     c. For every child set the relative position to its parent\n */\nimport { CyNode } from '../CytoscapeGraphUtils';\nimport { BoxByType } from 'types/Graph';\nimport { getLayoutByName } from '../graphs/LayoutDictionary';\nexport var BOX_NODE_CLASS = '__boxNodeClass';\nvar NAMESPACE_KEY = 'box-layout';\nvar STYLES_KEY = NAMESPACE_KEY + 'styles';\nvar RELATIVE_POSITION_KEY = NAMESPACE_KEY + 'relative_position';\nvar PARENT_POSITION_KEY = NAMESPACE_KEY + '.parent_position'; // Styles used to have more control on how the compound nodes are going to be seen by the Layout algorithm.\n\n/**\n * Synthetic edge generator replaces edges to and from boxed nodes with edges to/from their boxes. Care is\n * taken to not generate duplicate edges when sourceA has multiple real edges into the same box.\n */\nvar SyntheticEdgeGenerator = /*#__PURE__*/function () {\n  function SyntheticEdgeGenerator() {\n    _classCallCheck(this, SyntheticEdgeGenerator);\n\n    this.nextId = 0;\n    this.generatedMap = {};\n  }\n\n  _createClass(SyntheticEdgeGenerator, [{\n    key: \"getEdge\",\n    value: function getEdge(parentBoxType, source, target) {\n      var sourceId = this.normalizeToParent(parentBoxType, source).id();\n      var targetId = this.normalizeToParent(parentBoxType, target).id();\n\n      if (sourceId === targetId) {\n        return false;\n      }\n\n      var key = \"\".concat(sourceId, \"->\").concat(targetId);\n\n      if (this.generatedMap[key]) {\n        return false;\n      }\n\n      this.generatedMap[key] = true;\n      return {\n        group: 'edges',\n        data: {\n          id: 'synthetic-edge-' + this.nextId++,\n          source: sourceId,\n          target: targetId\n        }\n      };\n    } // Returns the element's parent if it exists and is also of the correct boxType.\n\n  }, {\n    key: \"normalizeToParent\",\n    value: function normalizeToParent(parentBoxType, element) {\n      var parent = element.parent();\n      return parent && parent.data(CyNode.isBox) === parentBoxType ? parent : element;\n    }\n  }]);\n\n  return SyntheticEdgeGenerator;\n}();\n/**\n * Main class for the BoxLayout, used to bridge with cytoscape to make it easier to integrate with current code\n */\n\n\nvar BoxLayout = /*#__PURE__*/function () {\n  function BoxLayout(options) {\n    _classCallCheck(this, BoxLayout);\n\n    this.appBoxLayout = void 0;\n    this.clusterBoxLayout = void 0;\n    this.defaultLayout = void 0;\n    this.namespaceBoxLayout = void 0;\n    this.cy = void 0;\n    this.elements = void 0;\n    this.syntheticEdgeGenerator = void 0;\n    this.appBoxLayout = options.appBoxLayout || options.defaultLayout;\n    this.clusterBoxLayout = options.clusterBoxLayout || options.defaultLayout;\n    this.defaultLayout = options.defaultLayout;\n    this.namespaceBoxLayout = options.namespaceBoxLayout || options.defaultLayout;\n    this.cy = options.cy;\n    this.elements = options.eles;\n    this.syntheticEdgeGenerator = new SyntheticEdgeGenerator();\n  }\n  /**\n   * This code gets executed on the cy.layout(...).  run() is the entrypoint of this algorithm.\n   */\n\n\n  _createClass(BoxLayout, [{\n    key: \"run\",\n    value: function run() {\n      this.runAsync();\n    }\n    /**\n     * This is a stub required by cytoscape to allow the layout impl to emit events\n     * @param _events space separated string of event names\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(_events) {// intentionally empty\n    } // Discrete layouts (dagre) always stop before layout.run() returns. Continuous layouts (cose,cola)\n    // are started by layout.run() but may stop after run() returns. Because outer boxes require the inner\n    // box layouts to complete, we need to force discrete behavior regardless of layout, and that is why\n    // this code is complicated with a variety of async handling.  Note that because namespace or cluster\n    // boxes may comprise large portions of the graph, we need to be flexible with the layout support (in\n    // other words, we can't force dagre like we do for app boxes).\n\n  }, {\n    key: \"runAsync\",\n    value: function () {\n      var _runAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var allBoxNodes, removedElements, syntheticEdges, result, layoutElements, layout;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                allBoxNodes = this.cy.collection();\n                removedElements = this.cy.collection();\n                syntheticEdges = this.cy.collection();\n                _context.next = 5;\n                return this.layoutBoxType(BoxByType.APP);\n\n              case 5:\n                result = _context.sent;\n                allBoxNodes = allBoxNodes.add(result.boxNodes);\n                removedElements = removedElements.add(result.removedElements);\n                syntheticEdges = syntheticEdges.add(result.syntheticEdges);\n                _context.next = 11;\n                return this.layoutBoxType(BoxByType.NAMESPACE);\n\n              case 11:\n                result = _context.sent;\n                allBoxNodes = allBoxNodes.add(result.boxNodes);\n                removedElements = removedElements.add(result.removedElements);\n                syntheticEdges = syntheticEdges.add(result.syntheticEdges);\n                _context.next = 17;\n                return this.layoutBoxType(BoxByType.CLUSTER);\n\n              case 17:\n                result = _context.sent;\n                allBoxNodes = allBoxNodes.add(result.boxNodes);\n                removedElements = removedElements.add(result.removedElements);\n                syntheticEdges = syntheticEdges.add(result.syntheticEdges); // (3) perform the final layout...\n                // Before running the layout, reset the elements positions.\n                // This is not absolutely necessary, but without this we have seen some problems with\n                //  `cola` + firefox + a particular mesh\n                // Ensure we only touch the requested elements and not the whole graph.\n\n                layoutElements = this.cy.collection().add(this.elements).subtract(removedElements).add(syntheticEdges);\n                layoutElements.position({\n                  x: 0,\n                  y: 0\n                });\n                layout = this.cy.layout(_objectSpread(_objectSpread({}, getLayoutByName(this.defaultLayout)), {}, {\n                  // Sharing the main options\n                  eles: this.cy.elements() // and the current elements\n\n                })); // Add a one-time callback to be fired when the layout stops\n\n                layout.one('layoutstop', function (_event) {\n                  // If we add any children back, our parent nodes position are going to take the bounding box's position of all\n                  // their children. Before doing it, save this position in order to add this up to their children.\n                  allBoxNodes.each(function (boxNode) {\n                    boxNode.scratch(PARENT_POSITION_KEY, _objectSpread({}, boxNode.position())); // Make a copy of the position, its an internal data from cy.\n                  }); // (3.a) Add back the child nodes (with edges still attached)\n\n                  removedElements.restore(); // (3.b) Remove synthetic edges\n\n                  _this.cy.remove(syntheticEdges); // (3.c) Add and position the children nodes according to the layout\n\n\n                  allBoxNodes.each(function (boxNode) {\n                    var parentPosition = boxNode.scratch(PARENT_POSITION_KEY);\n                    boxNode.children().each(function (child) {\n                      var relativePosition = child.scratch(RELATIVE_POSITION_KEY);\n                      child.position({\n                        x: parentPosition.x + relativePosition.x,\n                        y: parentPosition.y + relativePosition.y\n                      });\n                      child.removeData(RELATIVE_POSITION_KEY);\n                    });\n                    boxNode.style(boxNode.scratch(STYLES_KEY));\n                    boxNode.removeClass(BOX_NODE_CLASS); // Discard the saved values\n\n                    boxNode.removeScratch(STYLES_KEY);\n                    boxNode.removeScratch(PARENT_POSITION_KEY);\n                  });\n\n                  _this.emit('layoutstop');\n                });\n                layout.run();\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function runAsync() {\n        return _runAsync.apply(this, arguments);\n      }\n\n      return runAsync;\n    }()\n  }, {\n    key: \"layoutBoxType\",\n    value: function () {\n      var _layoutBoxType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(boxByType) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, _reject) {\n                  var boxNodes = _this2.getBoxNodes(boxByType);\n\n                  var boxLayoutOptions;\n\n                  switch (boxByType) {\n                    case BoxByType.APP:\n                      boxLayoutOptions = getLayoutByName(_this2.appBoxLayout);\n                      break;\n\n                    case BoxByType.CLUSTER:\n                      boxLayoutOptions = getLayoutByName(_this2.clusterBoxLayout);\n                      break;\n\n                    case BoxByType.NAMESPACE:\n                      boxLayoutOptions = getLayoutByName(_this2.namespaceBoxLayout);\n                      break;\n\n                    default:\n                      boxLayoutOptions = getLayoutByName(_this2.defaultLayout);\n                  } // Before completing work for the box type we must wait for all individual box work to complete\n\n\n                  // Before completing work for the box type we must wait for all individual box work to complete\n                  var boxNodePromises = []; // (2) Prepare each box node by assigning a size and running the compound layout\n\n                  // (2) Prepare each box node by assigning a size and running the compound layout\n                  boxNodes.each(function (boxNode) {\n                    var boxedNodes = boxNode.children();\n                    var boxedElements = boxedNodes.add(boxedNodes.edgesTo(boxedNodes));\n                    var boxLayout = boxedElements.layout(boxLayoutOptions);\n                    boxNodePromises.push(new Promise(function (resolve, _reject) {\n                      // (2.a) This promise resolves when the layout actually stops.\n                      _this2.runLayout(boxLayoutOptions.name, boxLayout).then(function (_response) {\n                        // (2.b) get the bounding box\n                        // see https://github.com/cytoscape/cytoscape.js/issues/2402\n                        var boundingBox = boxNode.boundingBox(); // Save the relative positions, as we will need them later.\n\n                        // Save the relative positions, as we will need them later.\n                        boxedNodes.each(function (boxedNode) {\n                          boxedNode.scratch(RELATIVE_POSITION_KEY, boxedNode.relativePosition());\n                        });\n                        var backupStyles = {\n                          shape: boxNode.style('shape'),\n                          height: boxNode.style('height'),\n                          width: boxNode.style('width')\n                        };\n                        var newStyles = {\n                          shape: 'rectangle',\n                          height: \"\".concat(boundingBox.h, \"px\"),\n                          width: \"\".concat(boundingBox.w, \"px\")\n                        }; // Saves a backup of current styles to restore them after we finish\n\n                        // Saves a backup of current styles to restore them after we finish\n                        boxNode.scratch(STYLES_KEY, backupStyles);\n                        boxNode.addClass(BOX_NODE_CLASS);\n                        boxNode.style(newStyles);\n                        resolve(true);\n                      });\n                    }));\n                  });\n                  Promise.all(boxNodePromises).then(function (_results) {\n                    var removedElements = _this2.cy.collection();\n\n                    var syntheticEdges = _this2.cy.collection(); // (2.c) Add synthetic edges for every edge that touches a child node.\n\n\n                    // (2.c) Add synthetic edges for every edge that touches a child node.\n                    var boxedNodes = boxNodes.children();\n\n                    var _iterator = _createForOfIteratorHelper(boxedNodes),\n                        _step;\n\n                    try {\n                      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                        var boxedNode = _step.value;\n\n                        var _iterator2 = _createForOfIteratorHelper(boxedNode.connectedEdges()),\n                            _step2;\n\n                        try {\n                          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                            var edge = _step2.value;\n\n                            var syntheticEdge = _this2.syntheticEdgeGenerator.getEdge(boxByType, edge.source(), edge.target());\n\n                            if (syntheticEdge) {\n                              syntheticEdges = syntheticEdges.add(_this2.cy.add(syntheticEdge));\n                            }\n                          }\n                        } catch (err) {\n                          _iterator2.e(err);\n                        } finally {\n                          _iterator2.f();\n                        }\n                      } // (2.d) Remove all child nodes from parents (and their edges).\n\n                    } catch (err) {\n                      _iterator.e(err);\n                    } finally {\n                      _iterator.f();\n                    } // (2.d) Remove all child nodes from parents (and their edges).\n\n\n                    // (2.d) Remove all child nodes from parents (and their edges).\n                    removedElements = removedElements.add(_this2.cy.remove(boxedNodes));\n                    resolve({\n                      boxNodes: boxNodes,\n                      syntheticEdges: syntheticEdges,\n                      removedElements: removedElements\n                    });\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function layoutBoxType(_x) {\n        return _layoutBoxType.apply(this, arguments);\n      }\n\n      return layoutBoxType;\n    }()\n  }, {\n    key: \"runLayout\",\n    value: function () {\n      var _runLayout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(layoutName, layout) {\n        var promise;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // Avoid propagating any local layout events up to cy, this would yield a global operation before the nodes are ready.\n                layout.on('layoutstart layoutready layoutstop', function (_event) {\n                  return false;\n                }); // We know dagre is discrete, we can resolve when run() returns\n\n                if (!(layoutName === 'dagre')) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", layout.run());\n\n              case 3:\n                promise = layout.promiseOn('layoutstop');\n                layout.run();\n                return _context3.abrupt(\"return\", promise);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function runLayout(_x2, _x3) {\n        return _runLayout.apply(this, arguments);\n      }\n\n      return runLayout;\n    }()\n  }, {\n    key: \"getBoxNodes\",\n    value: function getBoxNodes(boxByType) {\n      return this.elements.nodes(\"[\".concat(CyNode.isBox, \"=\\\"\").concat(boxByType, \"\\\"]\"));\n    }\n  }]);\n\n  return BoxLayout;\n}();\n\nexport { BoxLayout as default };","map":{"version":3,"sources":["/root/GraduateProject/src/components/CytoscapeGraph/Layout/BoxLayout.ts"],"names":["CyNode","BoxByType","getLayoutByName","BOX_NODE_CLASS","NAMESPACE_KEY","STYLES_KEY","RELATIVE_POSITION_KEY","PARENT_POSITION_KEY","SyntheticEdgeGenerator","nextId","generatedMap","parentBoxType","source","target","sourceId","normalizeToParent","id","targetId","key","group","data","element","parent","isBox","BoxLayout","options","appBoxLayout","clusterBoxLayout","defaultLayout","namespaceBoxLayout","cy","elements","syntheticEdgeGenerator","eles","runAsync","_events","allBoxNodes","collection","removedElements","syntheticEdges","layoutBoxType","APP","result","add","boxNodes","NAMESPACE","CLUSTER","layoutElements","subtract","position","x","y","layout","one","_event","each","boxNode","scratch","restore","remove","parentPosition","children","child","relativePosition","removeData","style","removeClass","removeScratch","emit","run","boxByType","Promise","resolve","_reject","getBoxNodes","boxLayoutOptions","boxNodePromises","boxedNodes","boxedElements","edgesTo","boxLayout","push","runLayout","name","then","_response","boundingBox","boxedNode","backupStyles","shape","height","width","newStyles","h","w","addClass","all","_results","connectedEdges","edge","syntheticEdge","getEdge","layoutName","on","promise","promiseOn","nodes"],"mappings":"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","sourcesContent":["/*\n  BoxLayout\n\n  This is a synthetic layout that helps to better layout the contents of box (i.e. compound)\n  nodes, in this way we ensure that the box nodes themselves are as small as possible, and avoiding\n  overlaps with other nodes.\n\n  It finishes by executing the default (i.e. user-selected) layout but prior to that will\n  individually layout the box node contents using the requested layouts.\n\n  Is composed of:\n   - The [optional] configured box layouts will layout the children of the box node.\n     - appBoxLayout, clusterBoxLayout, namespaceBoxLayout\n   - The [required] configured defaultLayout is used for any box layouts not otherwise specified, and is\n     applied for the final layout.\n   - A Synthetic edge generator creates synthetic edges (more info below).\n\n  The algorithm is roughly as follow:\n\n  1. For every box type (working inner to outer)\n       2. For every box node:\n          a. The box layout is run for every box and its relative positions (to the parent)\n             are saved for later use.\n          b. Get the resulting bounding box of the compound node, set the width and height of the node\n             using `cy.style`, so that the real layout honors the size when doing the layout.\n          c. For every edge that goes to a child (or comes from a child), create a synthetic edge\n            that goes to (or comes from) the compound node and remove the original\n            edge. We can cull away repeated edges as they are not needed.\n          d. Remove the children. This is important, else cytoscape won't honor the size specified\n             in previous step. \"A compound parent node does not have independent dimensions (position\n             and size), as those values are automatically inferred by the positions and dimensions\n             of the descendant nodes.\" http://js.cytoscape.org/#notation/compound-nodes\n  3. Run the default layout on this new graph and wait until it finishes.\n     a. Restore the children.\n     b. Remove the synthetic edges.\n     c. For every child set the relative position to its parent\n */\n\nimport { CyNode } from '../CytoscapeGraphUtils';\nimport { BoxByType } from 'types/Graph';\nimport { getLayoutByName } from '../graphs/LayoutDictionary';\n\nexport const BOX_NODE_CLASS = '__boxNodeClass';\n\nconst NAMESPACE_KEY = 'box-layout';\nconst STYLES_KEY = NAMESPACE_KEY + 'styles';\nconst RELATIVE_POSITION_KEY = NAMESPACE_KEY + 'relative_position';\nconst PARENT_POSITION_KEY = NAMESPACE_KEY + '.parent_position';\n\n// Styles used to have more control on how the compound nodes are going to be seen by the Layout algorithm.\ntype OverridenStyles = {\n  shape: string;\n  width: string;\n  height: string;\n};\n\ntype LayoutBoxTypeResult = {\n  boxNodes: any;\n  syntheticEdges: any;\n  removedElements: any;\n};\n\n/**\n * Synthetic edge generator replaces edges to and from boxed nodes with edges to/from their boxes. Care is\n * taken to not generate duplicate edges when sourceA has multiple real edges into the same box.\n */\nclass SyntheticEdgeGenerator {\n  private nextId = 0;\n  private generatedMap = {};\n\n  public getEdge(parentBoxType: BoxByType, source: any, target: any) {\n    const sourceId = this.normalizeToParent(parentBoxType, source).id();\n    const targetId = this.normalizeToParent(parentBoxType, target).id();\n\n    if (sourceId === targetId) {\n      return false;\n    }\n\n    const key = `${sourceId}->${targetId}`;\n\n    if (this.generatedMap[key]) {\n      return false;\n    }\n\n    this.generatedMap[key] = true;\n\n    return {\n      group: 'edges',\n      data: {\n        id: 'synthetic-edge-' + this.nextId++,\n        source: sourceId,\n        target: targetId\n      }\n    };\n  }\n\n  // Returns the element's parent if it exists and is also of the correct boxType.\n  private normalizeToParent(parentBoxType: BoxByType, element: any) {\n    const parent = element.parent();\n    return parent && parent.data(CyNode.isBox) === parentBoxType ? parent : element;\n  }\n}\n\n/**\n * Main class for the BoxLayout, used to bridge with cytoscape to make it easier to integrate with current code\n */\nexport default class BoxLayout {\n  readonly appBoxLayout;\n  readonly clusterBoxLayout;\n  readonly defaultLayout;\n  readonly namespaceBoxLayout;\n  readonly cy;\n  readonly elements;\n  readonly syntheticEdgeGenerator;\n\n  constructor(options: any) {\n    this.appBoxLayout = options.appBoxLayout || options.defaultLayout;\n    this.clusterBoxLayout = options.clusterBoxLayout || options.defaultLayout;\n    this.defaultLayout = options.defaultLayout;\n    this.namespaceBoxLayout = options.namespaceBoxLayout || options.defaultLayout;\n    this.cy = options.cy;\n    this.elements = options.eles;\n    this.syntheticEdgeGenerator = new SyntheticEdgeGenerator();\n  }\n\n  /**\n   * This code gets executed on the cy.layout(...).  run() is the entrypoint of this algorithm.\n   */\n  run() {\n    this.runAsync();\n  }\n\n  /**\n   * This is a stub required by cytoscape to allow the layout impl to emit events\n   * @param _events space separated string of event names\n   */\n  emit(_events) {\n    // intentionally empty\n  }\n\n  // Discrete layouts (dagre) always stop before layout.run() returns. Continuous layouts (cose,cola)\n  // are started by layout.run() but may stop after run() returns. Because outer boxes require the inner\n  // box layouts to complete, we need to force discrete behavior regardless of layout, and that is why\n  // this code is complicated with a variety of async handling.  Note that because namespace or cluster\n  // boxes may comprise large portions of the graph, we need to be flexible with the layout support (in\n  // other words, we can't force dagre like we do for app boxes).\n  async runAsync(): Promise<any> {\n    let allBoxNodes = this.cy.collection();\n    let removedElements = this.cy.collection();\n    let syntheticEdges = this.cy.collection();\n    let result;\n\n    // (1) working from inner boxing to outer boxing, perform the box layouts. the inner box layouts\n    // must complete before the outer box layouts can proceed.\n\n    result = await this.layoutBoxType(BoxByType.APP);\n    allBoxNodes = allBoxNodes.add(result.boxNodes);\n    removedElements = removedElements.add(result.removedElements);\n    syntheticEdges = syntheticEdges.add(result.syntheticEdges);\n\n    result = await this.layoutBoxType(BoxByType.NAMESPACE);\n    allBoxNodes = allBoxNodes.add(result.boxNodes);\n    removedElements = removedElements.add(result.removedElements);\n    syntheticEdges = syntheticEdges.add(result.syntheticEdges);\n\n    result = await this.layoutBoxType(BoxByType.CLUSTER);\n    allBoxNodes = allBoxNodes.add(result.boxNodes);\n    removedElements = removedElements.add(result.removedElements);\n    syntheticEdges = syntheticEdges.add(result.syntheticEdges);\n\n    // (3) perform the final layout...\n\n    // Before running the layout, reset the elements positions.\n    // This is not absolutely necessary, but without this we have seen some problems with\n    //  `cola` + firefox + a particular mesh\n    // Ensure we only touch the requested elements and not the whole graph.\n    const layoutElements = this.cy.collection().add(this.elements).subtract(removedElements).add(syntheticEdges);\n    layoutElements.position({ x: 0, y: 0 });\n\n    const layout = this.cy.layout({\n      // Create a new layout\n      ...getLayoutByName(this.defaultLayout), // Sharing the main options\n      eles: this.cy.elements() // and the current elements\n    });\n\n    // Add a one-time callback to be fired when the layout stops\n    layout.one('layoutstop', _event => {\n      // If we add any children back, our parent nodes position are going to take the bounding box's position of all\n      // their children. Before doing it, save this position in order to add this up to their children.\n      allBoxNodes.each(boxNode => {\n        boxNode.scratch(PARENT_POSITION_KEY, { ...boxNode.position() }); // Make a copy of the position, its an internal data from cy.\n      });\n\n      // (3.a) Add back the child nodes (with edges still attached)\n      removedElements.restore();\n\n      // (3.b) Remove synthetic edges\n      this.cy.remove(syntheticEdges);\n\n      // (3.c) Add and position the children nodes according to the layout\n      allBoxNodes.each(boxNode => {\n        const parentPosition = boxNode.scratch(PARENT_POSITION_KEY);\n        boxNode.children().each(child => {\n          const relativePosition = child.scratch(RELATIVE_POSITION_KEY);\n          child.position({\n            x: parentPosition.x + relativePosition.x,\n            y: parentPosition.y + relativePosition.y\n          });\n          child.removeData(RELATIVE_POSITION_KEY);\n        });\n\n        boxNode.style(boxNode.scratch(STYLES_KEY));\n        boxNode.removeClass(BOX_NODE_CLASS);\n\n        // Discard the saved values\n        boxNode.removeScratch(STYLES_KEY);\n        boxNode.removeScratch(PARENT_POSITION_KEY);\n      });\n\n      this.emit('layoutstop');\n    });\n\n    layout.run();\n  }\n\n  async layoutBoxType(boxByType: BoxByType): Promise<LayoutBoxTypeResult> {\n    return new Promise((resolve, _reject) => {\n      const boxNodes = this.getBoxNodes(boxByType);\n\n      let boxLayoutOptions;\n      switch (boxByType) {\n        case BoxByType.APP:\n          boxLayoutOptions = getLayoutByName(this.appBoxLayout);\n          break;\n        case BoxByType.CLUSTER:\n          boxLayoutOptions = getLayoutByName(this.clusterBoxLayout);\n          break;\n        case BoxByType.NAMESPACE:\n          boxLayoutOptions = getLayoutByName(this.namespaceBoxLayout);\n          break;\n        default:\n          boxLayoutOptions = getLayoutByName(this.defaultLayout);\n      }\n\n      // Before completing work for the box type we must wait for all individual box work to complete\n      const boxNodePromises: Promise<any>[] = [];\n\n      // (2) Prepare each box node by assigning a size and running the compound layout\n      boxNodes.each(boxNode => {\n        const boxedNodes = boxNode.children();\n        const boxedElements = boxedNodes.add(boxedNodes.edgesTo(boxedNodes));\n        const boxLayout = boxedElements.layout(boxLayoutOptions);\n\n        boxNodePromises.push(\n          new Promise((resolve, _reject) => {\n            // (2.a) This promise resolves when the layout actually stops.\n            this.runLayout(boxLayoutOptions.name, boxLayout).then(_response => {\n              // (2.b) get the bounding box\n              // see https://github.com/cytoscape/cytoscape.js/issues/2402\n              const boundingBox = boxNode.boundingBox();\n\n              // Save the relative positions, as we will need them later.\n              boxedNodes.each(boxedNode => {\n                boxedNode.scratch(RELATIVE_POSITION_KEY, boxedNode.relativePosition());\n              });\n\n              const backupStyles: OverridenStyles = {\n                shape: boxNode.style('shape'),\n                height: boxNode.style('height'),\n                width: boxNode.style('width')\n              };\n\n              const newStyles: OverridenStyles = {\n                shape: 'rectangle',\n                height: `${boundingBox.h}px`,\n                width: `${boundingBox.w}px`\n              };\n\n              // Saves a backup of current styles to restore them after we finish\n              boxNode.scratch(STYLES_KEY, backupStyles);\n              boxNode.addClass(BOX_NODE_CLASS);\n\n              boxNode.style(newStyles);\n\n              resolve(true);\n            });\n          })\n        );\n      });\n\n      Promise.all(boxNodePromises).then(_results => {\n        let removedElements = this.cy.collection();\n        let syntheticEdges = this.cy.collection();\n\n        // (2.c) Add synthetic edges for every edge that touches a child node.\n        const boxedNodes = boxNodes.children();\n        for (const boxedNode of boxedNodes) {\n          for (const edge of boxedNode.connectedEdges()) {\n            const syntheticEdge = this.syntheticEdgeGenerator.getEdge(boxByType, edge.source(), edge.target());\n            if (syntheticEdge) {\n              syntheticEdges = syntheticEdges.add(this.cy.add(syntheticEdge));\n            }\n          }\n        }\n        // (2.d) Remove all child nodes from parents (and their edges).\n        removedElements = removedElements.add(this.cy.remove(boxedNodes));\n\n        resolve({ boxNodes: boxNodes, syntheticEdges: syntheticEdges, removedElements: removedElements });\n      });\n    });\n  }\n\n  async runLayout(layoutName, layout): Promise<any> {\n    // Avoid propagating any local layout events up to cy, this would yield a global operation before the nodes are ready.\n    layout.on('layoutstart layoutready layoutstop', _event => {\n      return false;\n    });\n\n    // We know dagre is discrete, we can resolve when run() returns\n    if (layoutName === 'dagre') {\n      return layout.run();\n    }\n\n    const promise = layout.promiseOn('layoutstop');\n    layout.run();\n    return promise;\n  }\n\n  getBoxNodes(boxByType: BoxByType): any {\n    return this.elements.nodes(`[${CyNode.isBox}=\"${boxByType}\"]`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}