{"ast":null,"code":"import _regeneratorRuntime from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as API from './Api';\nimport moment from 'moment';\nimport { AuthStrategy, AuthResult } from '../types/Auth';\nimport authenticationConfig from '../config/AuthenticationConfig';\n\nvar AnonymousLogin = /*#__PURE__*/function () {\n  function AnonymousLogin() {\n    _classCallCheck(this, AnonymousLogin);\n  }\n\n  _createClass(AnonymousLogin, [{\n    key: \"prepare\",\n    value: function () {\n      var _prepare = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_info) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", AuthResult.CONTINUE);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function prepare(_x) {\n        return _prepare.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"perform\",\n    value: function () {\n      var _perform = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_request) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", {\n                  status: AuthResult.FAILURE,\n                  session: {\n                    username: API.ANONYMOUS_USER,\n                    expiresOn: moment().add(1, 'd').toISOString()\n                  }\n                });\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function perform(_x2) {\n        return _perform.apply(this, arguments);\n      }\n\n      return perform;\n    }()\n  }]);\n\n  return AnonymousLogin;\n}();\n\nvar TokenLogin = /*#__PURE__*/function () {\n  function TokenLogin() {\n    _classCallCheck(this, TokenLogin);\n  }\n\n  _createClass(TokenLogin, [{\n    key: \"prepare\",\n    value: function () {\n      var _prepare2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_info) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", AuthResult.CONTINUE);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function prepare(_x3) {\n        return _prepare2.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"perform\",\n    value: function () {\n      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(request) {\n        var session;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return API.login({\n                  username: '',\n                  password: '',\n                  token: request.data.password\n                });\n\n              case 2:\n                session = _context4.sent.data;\n                return _context4.abrupt(\"return\", {\n                  status: AuthResult.SUCCESS,\n                  session: session\n                });\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function perform(_x4) {\n        return _perform2.apply(this, arguments);\n      }\n\n      return perform;\n    }()\n  }]);\n\n  return TokenLogin;\n}();\n\nvar HeaderLogin = /*#__PURE__*/function () {\n  function HeaderLogin() {\n    _classCallCheck(this, HeaderLogin);\n  }\n\n  _createClass(HeaderLogin, [{\n    key: \"prepare\",\n    value: function () {\n      var _prepare3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_info) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", AuthResult.CONTINUE);\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function prepare(_x5) {\n        return _prepare3.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"perform\",\n    value: function () {\n      var _perform3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_request) {\n        var session;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return API.login({\n                  username: '',\n                  password: '',\n                  token: ''\n                });\n\n              case 2:\n                session = _context6.sent.data;\n                return _context6.abrupt(\"return\", {\n                  status: AuthResult.SUCCESS,\n                  session: session\n                });\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function perform(_x6) {\n        return _perform3.apply(this, arguments);\n      }\n\n      return perform;\n    }()\n  }]);\n\n  return HeaderLogin;\n}();\n\nvar OAuthLogin = /*#__PURE__*/function () {\n  function OAuthLogin() {\n    _classCallCheck(this, OAuthLogin);\n  }\n\n  _createClass(OAuthLogin, [{\n    key: \"prepare\",\n    value: function () {\n      var _prepare4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(info) {\n        var pattern;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (info.authorizationEndpoint) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", AuthResult.FAILURE);\n\n              case 2:\n                pattern = /[#&](access_token|id_token)=/;\n\n                if (!pattern.test(window.location.hash)) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", AuthResult.CONTINUE);\n\n              case 7:\n                return _context7.abrupt(\"return\", AuthResult.HOLD);\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function prepare(_x7) {\n        return _prepare4.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"perform\",\n    value: function () {\n      var _perform4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(_request) {\n        var session;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return API.checkOpenshiftAuth(window.location.hash.substring(1));\n\n              case 2:\n                session = _context8.sent.data;\n                // remove the data that was passed by the OAuth login. In certain error situations this can cause the\n                // page to enter a refresh loop since it tries to reload the page which then tries to reuse the bad token again.\n                window.history.replaceState('', document.title, window.location.pathname + window.location.search);\n                return _context8.abrupt(\"return\", {\n                  status: AuthResult.SUCCESS,\n                  session: session\n                });\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function perform(_x8) {\n        return _perform4.apply(this, arguments);\n      }\n\n      return perform;\n    }()\n  }]);\n\n  return OAuthLogin;\n}();\n\nexport var LoginDispatcher = /*#__PURE__*/function () {\n  function LoginDispatcher() {\n    _classCallCheck(this, LoginDispatcher);\n\n    this.strategyMapping = void 0;\n    this.info = void 0;\n    this.strategyMapping = new Map();\n    this.strategyMapping.set(AuthStrategy.anonymous, new AnonymousLogin());\n    this.strategyMapping.set(AuthStrategy.openshift, new OAuthLogin());\n    this.strategyMapping.set(AuthStrategy.token, new TokenLogin());\n    this.strategyMapping.set(AuthStrategy.openid, new OAuthLogin());\n    this.strategyMapping.set(AuthStrategy.header, new HeaderLogin());\n  }\n\n  _createClass(LoginDispatcher, [{\n    key: \"prepare\",\n    value: function () {\n      var _prepare5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var info, strategy, delay, result;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                info = authenticationConfig;\n                strategy = this.strategyMapping.get(info.strategy);\n                _context10.prev = 2;\n\n                delay = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n                    var ms,\n                        _args9 = arguments;\n                    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            ms = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 3000;\n                            return _context9.abrupt(\"return\", new Promise(function (resolve) {\n                              return setTimeout(resolve, ms);\n                            }));\n\n                          case 2:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9);\n                  }));\n\n                  return function delay() {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                _context10.next = 6;\n                return strategy.prepare(info);\n\n              case 6:\n                result = _context10.sent;\n\n                if (!(result === AuthResult.HOLD)) {\n                  _context10.next = 13;\n                  break;\n                }\n\n                _context10.next = 10;\n                return delay();\n\n              case 10:\n                return _context10.abrupt(\"return\", Promise.reject({\n                  status: AuthResult.FAILURE,\n                  error: 'Failed to redirect user to authentication page.'\n                }));\n\n              case 13:\n                return _context10.abrupt(\"return\", result);\n\n              case 14:\n                _context10.next = 19;\n                break;\n\n              case 16:\n                _context10.prev = 16;\n                _context10.t0 = _context10[\"catch\"](2);\n                return _context10.abrupt(\"return\", Promise.reject({\n                  status: AuthResult.FAILURE,\n                  error: _context10.t0\n                }));\n\n              case 19:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 16]]);\n      }));\n\n      function prepare() {\n        return _prepare5.apply(this, arguments);\n      }\n\n      return prepare;\n    }()\n  }, {\n    key: \"perform\",\n    value: function () {\n      var _perform5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(request) {\n        var strategy;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                strategy = this.strategyMapping.get(authenticationConfig.strategy);\n                _context11.prev = 1;\n                _context11.next = 4;\n                return strategy.perform(request);\n\n              case 4:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 7:\n                _context11.prev = 7;\n                _context11.t0 = _context11[\"catch\"](1);\n                return _context11.abrupt(\"return\", Promise.reject({\n                  status: AuthResult.FAILURE,\n                  error: _context11.t0\n                }));\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[1, 7]]);\n      }));\n\n      function perform(_x9) {\n        return _perform5.apply(this, arguments);\n      }\n\n      return perform;\n    }()\n  }]);\n\n  return LoginDispatcher;\n}();","map":{"version":3,"sources":["/root/kiali-ui/src/services/Login.ts"],"names":["API","moment","AuthStrategy","AuthResult","authenticationConfig","AnonymousLogin","_info","CONTINUE","_request","status","FAILURE","session","username","ANONYMOUS_USER","expiresOn","add","toISOString","TokenLogin","request","login","password","token","data","SUCCESS","HeaderLogin","OAuthLogin","info","authorizationEndpoint","pattern","test","window","location","hash","HOLD","checkOpenshiftAuth","substring","history","replaceState","document","title","pathname","search","LoginDispatcher","strategyMapping","Map","set","anonymous","openshift","openid","header","strategy","get","delay","ms","Promise","resolve","setTimeout","prepare","result","reject","error","perform"],"mappings":"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","sourcesContent":["import * as API from './Api';\nimport { ThunkDispatch } from 'redux-thunk';\nimport moment from 'moment';\n\nimport { KialiAppAction } from '../actions/KialiAppAction';\nimport { LoginSession, KialiAppState } from '../store/Store';\nimport { AuthStrategy, AuthResult, AuthConfig } from '../types/Auth';\nimport { TimeInMilliseconds } from '../types/Common';\nimport authenticationConfig from '../config/AuthenticationConfig';\n\ntype Dispatch = ThunkDispatch<KialiAppState, void, KialiAppAction>;\n\nexport interface LoginResult {\n  status: AuthResult;\n  session?: LoginSession;\n  error?: any;\n}\n\ninterface LoginStrategy<T extends unknown> {\n  prepare: (info: AuthConfig) => Promise<AuthResult>;\n  perform: (request: DispatchRequest<T>) => Promise<LoginResult>;\n}\n\ninterface DispatchRequest<T> {\n  dispatch: Dispatch;\n  state: KialiAppState;\n  data: T;\n}\n\ntype NullDispatch = DispatchRequest<unknown>;\n\nclass AnonymousLogin implements LoginStrategy<unknown> {\n  public async prepare(_info: AuthConfig) {\n    return AuthResult.CONTINUE;\n  }\n\n  public async perform(_request: NullDispatch): Promise<LoginResult> {\n    return {\n      status: AuthResult.FAILURE,\n      session: {\n        username: API.ANONYMOUS_USER,\n        expiresOn: moment().add(1, 'd').toISOString()\n      }\n    };\n  }\n}\n\ninterface WebLoginData {\n  username: string;\n  password: string;\n}\n\nclass TokenLogin implements LoginStrategy<WebLoginData> {\n  public async prepare(_info: AuthConfig) {\n    return AuthResult.CONTINUE;\n  }\n\n  public async perform(request: DispatchRequest<WebLoginData>): Promise<LoginResult> {\n    const session = (await API.login({ username: '', password: '', token: request.data.password })).data;\n\n    return {\n      status: AuthResult.SUCCESS,\n      session: session\n    };\n  }\n}\n\nclass HeaderLogin implements LoginStrategy<WebLoginData> {\n  public async prepare(_info: AuthConfig) {\n    return AuthResult.CONTINUE;\n  }\n\n  public async perform(_request: NullDispatch): Promise<LoginResult> {\n    const session = (await API.login({ username: '', password: '', token: '' })).data;\n\n    return {\n      status: AuthResult.SUCCESS,\n      session: session\n    };\n  }\n}\n\nclass OAuthLogin implements LoginStrategy<unknown> {\n  public async prepare(info: AuthConfig) {\n    if (!info.authorizationEndpoint) {\n      return AuthResult.FAILURE;\n    }\n\n    const pattern = /[#&](access_token|id_token)=/;\n    if (pattern.test(window.location.hash)) {\n      return AuthResult.CONTINUE;\n    } else {\n      return AuthResult.HOLD;\n    }\n  }\n\n  public async perform(_request: NullDispatch): Promise<LoginResult> {\n    // get the data from the url that was passed by the OAuth login.\n    const session = (await API.checkOpenshiftAuth(window.location.hash.substring(1))).data;\n\n    // remove the data that was passed by the OAuth login. In certain error situations this can cause the\n    // page to enter a refresh loop since it tries to reload the page which then tries to reuse the bad token again.\n    window.history.replaceState('', document.title, window.location.pathname + window.location.search);\n\n    return {\n      status: AuthResult.SUCCESS,\n      session: session\n    };\n  }\n}\n\nexport class LoginDispatcher {\n  strategyMapping: Map<AuthStrategy, LoginStrategy<any>>;\n  info?: AuthConfig;\n\n  constructor() {\n    this.strategyMapping = new Map();\n\n    this.strategyMapping.set(AuthStrategy.anonymous, new AnonymousLogin());\n    this.strategyMapping.set(AuthStrategy.openshift, new OAuthLogin());\n    this.strategyMapping.set(AuthStrategy.token, new TokenLogin());\n    this.strategyMapping.set(AuthStrategy.openid, new OAuthLogin());\n    this.strategyMapping.set(AuthStrategy.header, new HeaderLogin());\n  }\n\n  public async prepare(): Promise<AuthResult> {\n    const info = authenticationConfig;\n    const strategy = this.strategyMapping.get(info.strategy)!;\n\n    try {\n      const delay = async (ms: TimeInMilliseconds = 3000) => {\n        return new Promise(resolve => setTimeout(resolve, ms));\n      };\n\n      const result = await strategy.prepare(info);\n\n      // If preparation requires a hold time, with things such as redirects that\n      // require the auth flow to stop running for a while, we do that.\n      //\n      // If it fails to run for a while, we return a failure state.\n      // This assume that the user is leaving the page for auth, which should be\n      // the case for oauth implementations.\n      if (result === AuthResult.HOLD) {\n        await delay();\n\n        return Promise.reject({\n          status: AuthResult.FAILURE,\n          error: 'Failed to redirect user to authentication page.'\n        });\n      } else {\n        return result;\n      }\n    } catch (error) {\n      return Promise.reject({ status: AuthResult.FAILURE, error });\n    }\n  }\n\n  public async perform(request: DispatchRequest<any>): Promise<LoginResult> {\n    const strategy = this.strategyMapping.get(authenticationConfig.strategy)!;\n\n    try {\n      return await strategy.perform(request);\n    } catch (error) {\n      return Promise.reject({ status: AuthResult.FAILURE, error });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}