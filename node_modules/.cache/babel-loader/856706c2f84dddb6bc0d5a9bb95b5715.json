{"ast":null,"code":"import _slicedToArray from \"/root/GraduateProject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*\n OR Operation for labels\n*/\nvar orLabelOperation = function orLabelOperation(labels, filters) {\n  var _getKeyAndValues = getKeyAndValues(filters),\n      keys = _getKeyAndValues.keys,\n      keyValues = _getKeyAndValues.keyValues; // Get all keys of labels\n\n\n  var labelKeys = Object.keys(labels); // Check presence label\n\n  var filterOkForLabel = labelKeys.filter(function (label) {\n    return keys.some(function (key) {\n      return label.startsWith(key);\n    });\n  }).length > 0;\n\n  if (filterOkForLabel) {\n    return true;\n  } // Check key and value\n\n\n  keyValues.map(function (filter) {\n    var _filter$split = filter.split(':'),\n        _filter$split2 = _slicedToArray(_filter$split, 2),\n        key = _filter$split2[0],\n        value = _filter$split2[1]; // Check if multiple values\n\n\n    value.split(',').map(function (v) {\n      if (key in labels && !filterOkForLabel) {\n        // Split label values for serviceList Case where we can have multiple values for a label\n        filterOkForLabel = labels[key].trim().split(',').some(function (labelValue) {\n          return labelValue.trim().startsWith(v.trim());\n        });\n      }\n\n      return undefined;\n    });\n    return undefined;\n  });\n  return filterOkForLabel;\n};\n/*\n AND Operation for labels\n*/\n\n\nvar andLabelOperation = function andLabelOperation(labels, filters) {\n  // We expect this label is ok for the filters with And Operation\n  var filterOkForLabel = true;\n\n  var _getKeyAndValues2 = getKeyAndValues(filters),\n      keys = _getKeyAndValues2.keys,\n      keyValues = _getKeyAndValues2.keyValues; // Get all keys of labels\n\n\n  var labelKeys = Object.keys(labels); // Start check label presence\n\n  keys.map(function (k) {\n    if (!labelKeys.includes(k) && filterOkForLabel) {\n      filterOkForLabel = false;\n    }\n\n    return undefined;\n  }); // If label presence is validated we continue checking with key,value\n\n  if (filterOkForLabel) {\n    keyValues.map(function (filter) {\n      var _filter$split3 = filter.split(':'),\n          _filter$split4 = _slicedToArray(_filter$split3, 2),\n          key = _filter$split4[0],\n          value = _filter$split4[1];\n\n      if (key in labels && filterOkForLabel) {\n        // We need to check if some value of filter match\n        value.split(',').map(function (val) {\n          // Split label values for serviceList Case where we can have multiple values for a label\n          if (!labels[key].split(',').some(function (labelVal) {\n            return labelVal.trim().startsWith(val.trim());\n          })) {\n            filterOkForLabel = false;\n          }\n\n          return undefined;\n        });\n      } else {\n        // The key is not in the labels so not match AND operation\n        filterOkForLabel = false;\n      }\n\n      return undefined;\n    });\n  }\n\n  return filterOkForLabel;\n};\n\nvar filterLabelByOp = function filterLabelByOp(labels, filters) {\n  var op = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'or';\n  return op === 'or' ? orLabelOperation(labels, filters) : andLabelOperation(labels, filters);\n};\n\nexport var filterByLabel = function filterByLabel(items, filter) {\n  var op = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'or';\n  return filter.length === 0 ? items : items.filter(function (item) {\n    return filterLabelByOp(item.labels, filter, op);\n  });\n};\n\nvar getKeyAndValues = function getKeyAndValues(filters) {\n  // keys => List of filters with only Label Presence\n  // keyValues => List of filters with Label and value\n\n  /*\n    TS Error but this works...\n  */\n  // const [keys, keyValues] = filters.reduce(([p, f], e) => (!e.includes(':') ? [[...p, e], f] : [p, [...f, e]]), [[], []]);\n  var keys = filters.filter(function (f) {\n    return !f.includes(':');\n  });\n  var keyValues = filters.filter(function (f) {\n    return f.includes(':');\n  });\n  return {\n    keys: keys,\n    keyValues: keyValues\n  };\n};","map":{"version":3,"sources":["/root/GraduateProject/src/helpers/LabelFilterHelper.ts"],"names":["orLabelOperation","labels","filters","getKeyAndValues","keys","keyValues","labelKeys","Object","filterOkForLabel","filter","label","some","key","startsWith","length","map","split","value","v","trim","labelValue","undefined","andLabelOperation","k","includes","val","labelVal","filterLabelByOp","op","filterByLabel","items","item","f"],"mappings":"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","sourcesContent":["import { AppListItem } from '../types/AppList';\nimport { WorkloadListItem } from '../types/Workload';\nimport { ServiceListItem } from '../types/ServiceList';\n\ntype itemsType = AppListItem | ServiceListItem | WorkloadListItem;\n\n/*\n OR Operation for labels\n*/\nconst orLabelOperation = (labels: { [key: string]: string }, filters: string[]): boolean => {\n  const { keys, keyValues } = getKeyAndValues(filters);\n\n  // Get all keys of labels\n  const labelKeys = Object.keys(labels);\n\n  // Check presence label\n  let filterOkForLabel = labelKeys.filter(label => keys.some(key => label.startsWith(key))).length > 0;\n\n  if (filterOkForLabel) {\n    return true;\n  }\n  // Check key and value\n  keyValues.map(filter => {\n    const [key, value] = filter.split(':');\n    // Check if multiple values\n    value.split(',').map(v => {\n      if (key in labels && !filterOkForLabel) {\n        // Split label values for serviceList Case where we can have multiple values for a label\n        filterOkForLabel = labels[key]\n          .trim()\n          .split(',')\n          .some(labelValue => labelValue.trim().startsWith(v.trim()));\n      }\n      return undefined;\n    });\n    return undefined;\n  });\n  return filterOkForLabel;\n};\n\n/*\n AND Operation for labels\n*/\n\nconst andLabelOperation = (labels: { [key: string]: string }, filters: string[]): boolean => {\n  // We expect this label is ok for the filters with And Operation\n  let filterOkForLabel: boolean = true;\n\n  const { keys, keyValues } = getKeyAndValues(filters);\n\n  // Get all keys of labels\n  const labelKeys = Object.keys(labels);\n\n  // Start check label presence\n  keys.map(k => {\n    if (!labelKeys.includes(k) && filterOkForLabel) {\n      filterOkForLabel = false;\n    }\n    return undefined;\n  });\n\n  // If label presence is validated we continue checking with key,value\n  if (filterOkForLabel) {\n    keyValues.map(filter => {\n      const [key, value] = filter.split(':');\n      if (key in labels && filterOkForLabel) {\n        // We need to check if some value of filter match\n        value.split(',').map(val => {\n          // Split label values for serviceList Case where we can have multiple values for a label\n          if (!labels[key].split(',').some(labelVal => labelVal.trim().startsWith(val.trim()))) {\n            filterOkForLabel = false;\n          }\n          return undefined;\n        });\n      } else {\n        // The key is not in the labels so not match AND operation\n        filterOkForLabel = false;\n      }\n      return undefined;\n    });\n  }\n\n  return filterOkForLabel;\n};\n\nconst filterLabelByOp = (labels: { [key: string]: string }, filters: string[], op: string = 'or'): boolean => {\n  return op === 'or' ? orLabelOperation(labels, filters) : andLabelOperation(labels, filters);\n};\n\nexport const filterByLabel = (items: itemsType[], filter: string[], op: string = 'or'): itemsType[] => {\n  return filter.length === 0 ? items : items.filter(item => filterLabelByOp(item.labels, filter, op));\n};\n\nconst getKeyAndValues = (filters: string[]): { keys: string[]; keyValues: string[] } => {\n  // keys => List of filters with only Label Presence\n  // keyValues => List of filters with Label and value\n  /*\n    TS Error but this works...\n  */\n  // const [keys, keyValues] = filters.reduce(([p, f], e) => (!e.includes(':') ? [[...p, e], f] : [p, [...f, e]]), [[], []]);\n  const keys = filters.filter(f => !f.includes(':'));\n  const keyValues = filters.filter(f => f.includes(':'));\n  return { keys, keyValues };\n};\n"]},"metadata":{},"sourceType":"module"}