{"ast":null,"code":"import _classCallCheck from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/root/kiali-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nvar _jsxFileName = \"/root/kiali-ui/src/components/JaegerIntegration/JaegerScatter.tsx\";\nimport * as React from 'react';\nimport { connect } from 'react-redux';\nimport { ChartScatter } from '@patternfly/react-charts';\nimport { Title, EmptyState, EmptyStateVariant, EmptyStateBody } from '@patternfly/react-core';\nimport { PFColors } from '../Pf/PfColors';\nimport { evalTimeRange } from 'types/Common';\nimport { JaegerThunkActions } from 'actions/JaegerThunkActions';\nimport { makeLegend } from 'types/VictoryChartInfo';\nimport ChartWithLegend from 'components/Charts/ChartWithLegend';\nimport { durationSelector } from '../../store/Selectors';\nimport { TraceTooltip } from './TraceTooltip';\nimport { isErrorTag } from 'utils/tracing/TracingHelper';\nimport { averageSpanDuration } from 'utils/tracing/TraceStats';\nimport { style } from 'typestyle';\nvar ONE_MILLISECOND = 1000000;\nvar MINIMAL_SIZE = 2;\nvar MAXIMAL_SIZE = 30;\nvar jaegerChartStyle = style({\n  paddingTop: 15,\n  paddingLeft: 25,\n  paddingRight: 25,\n  paddingBottom: 15\n});\nvar emptyStyle = style({\n  display: 'flex',\n  justifyContent: 'center',\n  alignItems: 'center',\n  overflow: 'hidden',\n  // fix height + padding\n  height: '350px',\n  textAlign: 'center'\n});\n\nvar JaegerScatter = /*#__PURE__*/function (_React$Component) {\n  _inherits(JaegerScatter, _React$Component);\n\n  var _super = _createSuper(JaegerScatter);\n\n  function JaegerScatter() {\n    var _this;\n\n    _classCallCheck(this, JaegerScatter);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this.renderFetchEmtpy = function (title, msg) {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        className: emptyStyle,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 59,\n          columnNumber: 7\n        }\n      }, /*#__PURE__*/React.createElement(EmptyState, {\n        variant: EmptyStateVariant.small,\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 60,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(Title, {\n        headingLevel: \"h5\",\n        size: \"lg\",\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 61,\n          columnNumber: 11\n        }\n      }, title), /*#__PURE__*/React.createElement(EmptyStateBody, {\n        __self: _assertThisInitialized(_this),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 64,\n          columnNumber: 11\n        }\n      }, msg)));\n    };\n\n    return _this;\n  }\n\n  _createClass(JaegerScatter, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var tracesRaw = [];\n      var tracesError = []; // Tracing uses Duration instead of TimeRange, evalTimeRange is a helper here\n\n      var timeWindow = evalTimeRange({\n        rangeDuration: this.props.duration\n      });\n      var traces = this.props.traces; // Add currently selected trace in list in case it wasn't\n\n      if (this.props.selectedTrace && !traces.some(function (t) {\n        return t.traceID === _this2.props.selectedTrace.traceID;\n      }) && this.props.selectedTrace.startTime >= 1000 * timeWindow[0].getTime() && this.props.selectedTrace.startTime <= 1000 * timeWindow[1].getTime()) {\n        traces.push(this.props.selectedTrace);\n      }\n\n      traces.forEach(function (trace) {\n        var isSelected = _this2.props.selectedTrace && trace.traceID === _this2.props.selectedTrace.traceID;\n        var traceError = trace.spans.filter(function (sp) {\n          return sp.tags.some(isErrorTag);\n        }).length > 0;\n        var value = _this2.props.showSpansAverage ? averageSpanDuration(trace) || 0 : trace.duration;\n        var traceItem = {\n          x: new Date(trace.startTime / 1000),\n          y: value / ONE_MILLISECOND,\n          name: \"\".concat(trace.traceName !== '' ? trace.traceName : '<trace-without-root-span>', \" (\").concat(trace.traceID.slice(0, 7), \")\"),\n          color: isSelected ? PFColors.Blue500 : PFColors.Blue200,\n          unit: 'seconds',\n          trace: trace,\n          size: Math.min(MAXIMAL_SIZE, trace.spans.length + MINIMAL_SIZE)\n        };\n\n        if (traceError) {\n          traceItem.color = isSelected ? PFColors.Red500 : PFColors.Red200;\n          tracesError.push(traceItem);\n        } else {\n          tracesRaw.push(traceItem);\n        }\n      });\n      var successTraces = {\n        datapoints: tracesRaw,\n        color: function (_ref) {\n          var datum = _ref.datum;\n          return datum.color;\n        },\n        legendItem: makeLegend('Traces', PFColors.Blue200)\n      };\n      var errorTraces = {\n        datapoints: tracesError,\n        color: function (_ref2) {\n          var datum = _ref2.datum;\n          return datum.color;\n        },\n        legendItem: makeLegend('Error Traces', PFColors.Red200)\n      };\n      return this.props.errorFetchTraces && this.props.errorFetchTraces.length > 0 ? this.renderFetchEmtpy('Error fetching traces', this.props.errorFetchTraces[0].msg) : this.props.traces.length > 0 ? /*#__PURE__*/React.createElement(\"div\", {\n        className: jaegerChartStyle,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 124,\n          columnNumber: 7\n        }\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        style: {\n          marginTop: 20\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 125,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(ChartWithLegend, {\n        data: [successTraces, errorTraces],\n        fill: true,\n        unit: \"seconds\",\n        seriesComponent: /*#__PURE__*/React.createElement(ChartScatter, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 130,\n            columnNumber: 30\n          }\n        }),\n        onClick: function onClick(dp) {\n          return _this2.props.setTraceId(dp.trace.traceID);\n        },\n        labelComponent: /*#__PURE__*/React.createElement(TraceTooltip, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 132,\n            columnNumber: 29\n          }\n        }),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 11\n        }\n      }))) : this.renderFetchEmtpy('No traces', 'No trace results. Try another query.');\n    }\n  }]);\n\n  return JaegerScatter;\n}(React.Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    duration: durationSelector(state),\n    selectedTrace: state.jaegerState.selectedTrace\n  };\n};\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    setTraceId: function setTraceId(traceId) {\n      return dispatch(JaegerThunkActions.setTraceId(traceId));\n    }\n  };\n};\n\nvar Container = connect(mapStateToProps, mapDispatchToProps)(JaegerScatter);\nexport default Container;","map":{"version":3,"sources":["/root/kiali-ui/src/components/JaegerIntegration/JaegerScatter.tsx"],"names":["React","connect","ChartScatter","Title","EmptyState","EmptyStateVariant","EmptyStateBody","PFColors","evalTimeRange","JaegerThunkActions","makeLegend","ChartWithLegend","durationSelector","TraceTooltip","isErrorTag","averageSpanDuration","style","ONE_MILLISECOND","MINIMAL_SIZE","MAXIMAL_SIZE","jaegerChartStyle","paddingTop","paddingLeft","paddingRight","paddingBottom","emptyStyle","display","justifyContent","alignItems","overflow","height","textAlign","JaegerScatter","renderFetchEmtpy","title","msg","small","tracesRaw","tracesError","timeWindow","rangeDuration","props","duration","traces","selectedTrace","some","t","traceID","startTime","getTime","push","forEach","trace","isSelected","traceError","spans","filter","sp","tags","length","value","showSpansAverage","traceItem","x","Date","y","name","traceName","slice","color","Blue500","Blue200","unit","size","Math","min","Red500","Red200","successTraces","datapoints","datum","legendItem","errorTraces","errorFetchTraces","marginTop","dp","setTraceId","Component","mapStateToProps","state","jaegerState","mapDispatchToProps","dispatch","traceId","Container"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { ChartScatter } from '@patternfly/react-charts';\nimport { Title, EmptyState, EmptyStateVariant, EmptyStateBody } from '@patternfly/react-core';\n\nimport { JaegerError, JaegerTrace } from '../../types/JaegerInfo';\nimport { PFColors } from '../Pf/PfColors';\n\nimport { evalTimeRange } from 'types/Common';\nimport { KialiAppState } from 'store/Store';\nimport { KialiAppAction } from 'actions/KialiAppAction';\nimport { JaegerThunkActions } from 'actions/JaegerThunkActions';\nimport { LineInfo, makeLegend, VCDataPoint } from 'types/VictoryChartInfo';\nimport ChartWithLegend from 'components/Charts/ChartWithLegend';\nimport { durationSelector } from '../../store/Selectors';\nimport { TraceTooltip } from './TraceTooltip';\nimport { isErrorTag } from 'utils/tracing/TracingHelper';\nimport { averageSpanDuration } from 'utils/tracing/TraceStats';\nimport { style } from 'typestyle';\n\ninterface JaegerScatterProps {\n  duration: number;\n  traces: JaegerTrace[];\n  showSpansAverage: boolean;\n  errorTraces?: boolean;\n  errorFetchTraces?: JaegerError[];\n  setTraceId: (traceId?: string) => void;\n  selectedTrace?: JaegerTrace;\n}\n\nconst ONE_MILLISECOND = 1000000;\nconst MINIMAL_SIZE = 2;\nconst MAXIMAL_SIZE = 30;\n\nexport type JaegerLineInfo = LineInfo & { trace: JaegerTrace };\ntype Datapoint = VCDataPoint & JaegerLineInfo;\n\nconst jaegerChartStyle = style({\n  paddingTop: 15,\n  paddingLeft: 25,\n  paddingRight: 25,\n  paddingBottom: 15\n});\n\nconst emptyStyle = style({\n  display: 'flex',\n  justifyContent: 'center',\n  alignItems: 'center',\n  overflow: 'hidden',\n  // fix height + padding\n  height: '350px',\n  textAlign: 'center'\n});\n\nclass JaegerScatter extends React.Component<JaegerScatterProps> {\n  renderFetchEmtpy = (title, msg) => {\n    return (\n      <div className={emptyStyle}>\n        <EmptyState variant={EmptyStateVariant.small}>\n          <Title headingLevel=\"h5\" size=\"lg\">\n            {title}\n          </Title>\n          <EmptyStateBody>{msg}</EmptyStateBody>\n        </EmptyState>\n      </div>\n    );\n  };\n  render() {\n    const tracesRaw: Datapoint[] = [];\n    const tracesError: Datapoint[] = [];\n    // Tracing uses Duration instead of TimeRange, evalTimeRange is a helper here\n    const timeWindow = evalTimeRange({ rangeDuration: this.props.duration });\n\n    let traces = this.props.traces;\n    // Add currently selected trace in list in case it wasn't\n    if (\n      this.props.selectedTrace &&\n      !traces.some(t => t.traceID === this.props.selectedTrace!.traceID) &&\n      this.props.selectedTrace.startTime >= 1000 * timeWindow[0].getTime() &&\n      this.props.selectedTrace.startTime <= 1000 * timeWindow[1].getTime()\n    ) {\n      traces.push(this.props.selectedTrace);\n    }\n\n    traces.forEach(trace => {\n      const isSelected = this.props.selectedTrace && trace.traceID === this.props.selectedTrace.traceID;\n      const traceError = trace.spans.filter(sp => sp.tags.some(isErrorTag)).length > 0;\n      const value = this.props.showSpansAverage ? averageSpanDuration(trace) || 0 : trace.duration;\n      const traceItem = {\n        x: new Date(trace.startTime / 1000),\n        y: value / ONE_MILLISECOND,\n        name: `${trace.traceName !== '' ? trace.traceName : '<trace-without-root-span>'} (${trace.traceID.slice(\n          0,\n          7\n        )})`,\n        color: isSelected ? PFColors.Blue500 : PFColors.Blue200,\n        unit: 'seconds',\n        trace: trace,\n        size: Math.min(MAXIMAL_SIZE, trace.spans.length + MINIMAL_SIZE)\n      };\n      if (traceError) {\n        traceItem.color = isSelected ? PFColors.Red500 : PFColors.Red200;\n        tracesError.push(traceItem);\n      } else {\n        tracesRaw.push(traceItem);\n      }\n    });\n    const successTraces = {\n      datapoints: tracesRaw,\n      color: (({ datum }) => datum.color) as any,\n      legendItem: makeLegend('Traces', PFColors.Blue200)\n    };\n\n    const errorTraces = {\n      datapoints: tracesError,\n      color: (({ datum }) => datum.color) as any,\n      legendItem: makeLegend('Error Traces', PFColors.Red200)\n    };\n\n    return this.props.errorFetchTraces && this.props.errorFetchTraces.length > 0 ? (\n      this.renderFetchEmtpy('Error fetching traces', this.props.errorFetchTraces![0].msg)\n    ) : this.props.traces.length > 0 ? (\n      <div className={jaegerChartStyle}>\n        <div style={{ marginTop: 20 }}>\n          <ChartWithLegend<Datapoint, JaegerLineInfo>\n            data={[successTraces, errorTraces]}\n            fill={true}\n            unit=\"seconds\"\n            seriesComponent={<ChartScatter />}\n            onClick={dp => this.props.setTraceId(dp.trace.traceID)}\n            labelComponent={<TraceTooltip />}\n          />\n        </div>\n      </div>\n    ) : (\n      this.renderFetchEmtpy('No traces', 'No trace results. Try another query.')\n    );\n  }\n}\n\nconst mapStateToProps = (state: KialiAppState) => ({\n  duration: durationSelector(state),\n  selectedTrace: state.jaegerState.selectedTrace\n});\n\nconst mapDispatchToProps = (dispatch: ThunkDispatch<KialiAppState, void, KialiAppAction>) => ({\n  setTraceId: (traceId?: string) => dispatch(JaegerThunkActions.setTraceId(traceId))\n});\n\nconst Container = connect(mapStateToProps, mapDispatchToProps)(JaegerScatter);\nexport default Container;\n"]},"metadata":{},"sourceType":"module"}